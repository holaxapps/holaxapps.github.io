<!DOCTYPE html><html lang="ko" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Git Flow와 자주 사용되는 Git 명령어들 · 안녕 프로그래밍</title><meta name="description" content="Git 시작하기"><meta name="og:title" content="Git Flow와 자주 사용되는 Git 명령어들"><meta name="og:type" content="website"><meta name="og:url" content="https://www.holaxprogramming.com/2018/11/01/git-commands/"><meta name="og:image" content="http://image.toast.com/aaaaahq/hola_cover.JPG"><meta name="og:description" content="Git 시작하기"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/chiangmai.css"><meta name="steem:author" content="@stunstunstun"><meta name="fb:app_id" content="1258629384258634"><link rel="search" type="application/opensearchdescription+xml" href="https://www.holaxprogramming.com/atom.xml" title="안녕 프로그래밍"></head><body class="post"><div id="fb-root"></div><div class="wrap"><header><nav class="navi-post"><a class="navi-post-back" href="javascript:history.back()"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="navi-post-home" href="/"><i class="fa fa-home" aria-hidden="true"></i></a></nav></header><main class="post"><div class="post"><article class="post-block"><h1 class="post-title">Git Flow와 자주 사용되는 Git 명령어들</h1><div class="post-info"><div class="post-info-profile"><a href="https://github.com/stunstunstun" target="_blank"><img src="/image/profile.jpg"></a></div><div class="post-info-details"><div class="post-categories"><a href="/categories/git" target="_self"><span>GIT</span></a></div><div class="post-date">2018년 11월 1일</div></div></div><div class="post-share"><div class="fb-like" data-href="https://www.holaxprogramming.com/2018/11/01/git-commands/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false">                 </div><div class="fb-share-button" data-href="https://www.holaxprogramming.com/2018/11/01/git-commands/" data-layout="button" data-size="small" data-mobile-iframe="true"></div><div class="fb-follow" data-href="https://www.facebook.com/holaxprogramming/" data-layout="button_count" data-size="small" data-show-faces="true"></div></div><div class="post-content"><p><code>Git Flow</code>는 git을 통해 효율적으로 프로젝트를 관리하고 배포하기 위한 전략이다. 기본적으로 Git은 로컬 저장소와 원격 저장소간의 동기화를 위해 아래와 같은 과정을 거친다.</p>
<a id="more"></a>
<p><img src="https://about.gitlab.com/images/git_flow/four_stages.png" height="400"></p>
<p>하지만 프로젝트의 규모가 커지고 협업하는 동료들이 많아진다면 저장소의 master branch만을 이용하는 것에서 이슈에 따라 다양한 branch를 통해 다양한 인원이 독립적으로 개발이 가능한 전략이 필요하다.</p>
<h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p><img src="https://about.gitlab.com/images/git_flow/gitdashflow.png"></p>
<p>Git Flow는 다양한 branch를 관리하고 통합하기 위한 전략 중 하나이다. 최근에는 Git Flow의 단점을 해소하기 위해 Github Flow, Gitlab Flow 등 다양한 전략이 있지만 이 문서에서는 가장 기본이 되는 Git Flow를 설명하고 여기에 필요한 기본적인 Git 명령어에 대해 알아보도록 하겠다.</p>
<h2 id="브랜치-전략"><a href="#브랜치-전략" class="headerlink" title="브랜치 전략"></a>브랜치 전략</h2><p>Git Flow의 주요 브랜치는 <code>master</code>와 <code>develop</code> 이며, 이 두 브랜치를 중심으로 feature, release와 필요에 따라 hotfixes 브랜치를 정의한다.</p>
<p><img src="https://camo.githubusercontent.com/70f7e458a965f38831d1c50757b3a284c4280328/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f6d61696e2d6272616e636865732e706e67"></p>
<h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>master 브랜치에 merge된 내역은 새로운 버전이 갱신되었다는 것을 의미한다. 즉 master 브랜치에 변경 내역이 생기면 최종 버전인 Tag를 통해 Production에 배포된다. </p>
<h4 id="develop"><a href="#develop" class="headerlink" title="develop"></a>develop</h4><p>hotfix를 제외한 모든 변경내역이 출발하는 지점이다. develop 브랜치의 코드가 안정화되고 배포할 준비가 되면 <code>master</code>를 통해 배포 버전의 태그를 단다.</p>
<h4 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h4><p><code>feature</code> 브랜치는 배포하려고 하는 기능을 개발하는 브랜치다. 기능을 개발하기 시작할 때는 언제 배포할 수 있을지 알 수 없다. 기능을 다 완성할 때까지 유지하고 있다가 다 완성되면 <code>develop</code> 브랜치로 병합한다. </p>
<ul>
<li>브랜치가 생성되는 대상 : develop</li>
<li>merge 대상: develop</li>
</ul>
<p><img src="https://camo.githubusercontent.com/c9cbf25c64dc0519860230cb98d098c3d069eda3/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f6d657267652d776974686f75742d66662e706e67"></p>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p><code>release</code> 브랜치는 실제 배포할 상태가 된 경우에 생성하는 브랜치다.</p>
<ul>
<li>브랜치가 생성되는 대상 : develop</li>
<li>merge 대상: develop, master</li>
</ul>
<h4 id="hotfix"><a href="#hotfix" class="headerlink" title="hotfix"></a>hotfix</h4><p>미리 계획되지 않은 브랜치다. 기본적인 동작방식은 <code>release</code>와 비슷하다. 배포 이후에 생긴 치명적인 버그는 즉시 해결해야하기 때문에 문제가 생기면 <code>master</code> 브랜치에 만들어둔 태그<code>tag</code>로 부터 긴급수정을 위한 브랜치를 생성한다.</p>
<ul>
<li>브랜치가 생성되는 대상 : master</li>
<li>merge 대상 : develop, master</li>
</ul>
<p><img src="https://camo.githubusercontent.com/aee561ae78af58c9756814432473c8dab15dada7/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f686f746669782d6272616e636865732e706e67"></p>
<h2 id="주요-Commands"><a href="#주요-Commands" class="headerlink" title="주요 Commands"></a>주요 Commands</h2><h4 id="소스코드의-origin-저장소를-초기화하고-remote-서버와-처음으로-연결할-때"><a href="#소스코드의-origin-저장소를-초기화하고-remote-서버와-처음으로-연결할-때" class="headerlink" title="소스코드의 origin 저장소를 초기화하고 remote 서버와 처음으로 연결할 때"></a>소스코드의 origin 저장소를 초기화하고 remote 서버와 처음으로 연결할 때</h4><p>최초의 프로젝트(origin)는 로컬 저장소에서 시작될 것이다. 운영체제에 git을 설치하고 여러분의 프로젝트를 관리할 원격 저장소가 준비되었다고 가정했을때 아래와 같이 <code>git init</code> 명령을 통해 git 프로젝트로 초기화할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"# Hola"</span> &gt; README.md</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<h4 id="git-add-commit"><a href="#git-add-commit" class="headerlink" title="git add, commit"></a>git add, commit</h4><p>git add 명령어는 git flow의 첫 단계에 해당되며 인덱스에 새로운 파일이 생겼다는 것을 알리는 행위이다. 이 상태는 저장소에는 반영이 되지 않은 상태이며 git commit 명령을 통해 비로소 저장소에 변경내역이 반영된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add build.gradle <span class="comment"># 특정 파일에 대한 변경 내역을 알린다.</span></span><br><span class="line">$ git add . <span class="comment"># 모든 변경 내역을 알린다</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"이 버전의 변경 내역에 대한 설명"</span></span><br></pre></td></tr></table></figure>
<p>git add, commit은 아래와 같이 동시에 실행할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">"이 버전의 변경 내역에 대한 설명"</span></span><br></pre></td></tr></table></figure>
<h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>commit이 완료된 시점은 변경 내용이 로컬 저장소에 HEAD안에 머물고 있음을 의미한다. 우리는 변경 내역을 동료들도 확인할 수 있도록 remote 서버에 반영할 필요가 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">$ git push <span class="comment"># -u 옵션을 이용하면 다음 push때 이전 히스토리를 기억하고 반영한다.</span></span><br></pre></td></tr></table></figure>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>git add, commit, push 하는 일련의 과정은 내 컴퓨터에서 일어난 변경내역을 관리하고, remote 서버에 반영하는 행위라면 <code>git pull</code>은 remote 서버의 가장 최근의 변경 내역을 내 컴퓨터로 가져오는 행위이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h4 id="새로운-기능을-위해-branch를-생성하는-방법"><a href="#새로운-기능을-위해-branch를-생성하는-방법" class="headerlink" title="새로운 기능을 위해 branch를 생성하는 방법"></a>새로운 기능을 위해 branch를 생성하는 방법</h4><p>git은 강력한 점은 효율적으로 분산된 환경은 제공한다는 것이다. 우리는 master branch가 아닌 더욱 안전하고 격리된 상태에서 새로운 기능을 추가할 수 있다. 새로운 branch를 이용해 개발을 진행하고 개발이 완료가 되면 나중에 master 로 돌아와 merge 하는 프로세스를 의미한다.</p>
<p>아래의 명령을 통해 <code>master branch</code>에서 <code>develop</code> 이라는 새로운 branch를 만들고 갈아탄다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop</span><br></pre></td></tr></table></figure>
<p>stage라는 특정 branch로 부터 새로운 branch를 만들고 싶다면,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop origin/stage</span><br></pre></td></tr></table></figure>
<p>아래와 같이 다시 master branch로 돌아올 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  stage</span><br><span class="line">  develop</span><br></pre></td></tr></table></figure>
<p>당신이 새롭게 만든 branch는 remote 서버에 전송하기 전까지는 동료들이 접근할 수가 없다. branch에 대한 검증이 완료되면 여러분은 Github에서 Pull Request를 전송할 수 있게된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin develop</span><br></pre></td></tr></table></figure>
<p>만약 branch를 여러명과 협업하고 있는 도중 push시에 remote 서버의 최신 내용을 로컬에 반영하지 않았다면 아래와 같이 remote 서버와 연결 후 <code>git pull</code>을 통해 merge 한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/develop develop</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<h4 id="원격-저장소의-기존-branch-확인-후-로컬에-가져오기"><a href="#원격-저장소의-기존-branch-확인-후-로컬에-가져오기" class="headerlink" title="원격 저장소의 기존 branch 확인 후 로컬에 가져오기"></a>원격 저장소의 기존 branch 확인 후 로컬에 가져오기</h4><p>원격 저장소의 브랜치 리스트를 조회한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">  origin/develop</span><br><span class="line">  origin/master</span><br><span class="line">  origin/stage</span><br></pre></td></tr></table></figure>
<p>로컬, 원격 저장소의 브랜치 리스트를 모두 조회한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">  master</span><br><span class="line">  stage</span><br><span class="line">* develop</span><br><span class="line">  remotes/origin/develop</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/stage</span><br></pre></td></tr></table></figure>
<p>원격 저장소의 <code>develop</code>이라는 branch를 로컬 저장소에 가져오고 싶다면</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -t origin/develop</span><br><span class="line">Branch develop <span class="built_in">set</span> up to track remote branch develop from origin.</span><br><span class="line">Switched to a new branch <span class="string">'develop'</span></span><br><span class="line">$ git branch</span><br><span class="line">* develop</span><br><span class="line">  master</span><br><span class="line">  stage</span><br></pre></td></tr></table></figure>
<p><code>fatal: Cannot update paths and switch to branch &#39;develop&#39; at the same time.</code>이라는 에러가 발생한다면 아래와 같이 원격 저장소를 최신 상태를 로컬 저장소에 갱신한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote update</span><br></pre></td></tr></table></figure>
<h4 id="원격-저장소-참고하기"><a href="#원격-저장소-참고하기" class="headerlink" title="원격 저장소 참고하기"></a>원격 저장소 참고하기</h4><p>어떤 경우에는 수정 내역을 원격 저장소에 push 하지는 않지만 해당 branch를 참고하기 위해 로컬에 받아서 테스트 해보고 싶은 경우도 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>아무런 옵션없이 원격 저장소의 branch를 checkout 하면 <code>detached HEAD</code> 상태로 소스를 보고 변경 해볼 수도 있지만 변경 사항들은 commit, push 할 수 없으며 다른 branch로 checkout하면 사라진다.</p>
<h4 id="개발한-내역을-master-branch에-merge하는-과정"><a href="#개발한-내역을-master-branch에-merge하는-과정" class="headerlink" title="개발한 내역을 master branch에 merge하는 과정"></a>개발한 내역을 master branch에 merge하는 과정</h4><p>변경 내역을 master에 merge하는 과정은 아주 중요한 과정이다. 먼저 아래와 같이 remote 서버의 최신 내역을 자신의 로컬 저장소에 갱신하는 습관을 들이는게 좋다. <code>git pull</code>을 통해 remote 서버의 변경 내용이 로컬 저장소에 fetch, merge 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<p>다른 branch에 있는 변경 내용을 현재의 branch(master)에 병합하려면 아래의 명령을 실행하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge some_function</span><br></pre></td></tr></table></figure>
<p>첫번째 명령이든 두번째 명령이든, git은 자동으로 변경 내용을 merge하려고 한다. 문제는, 항상 성공하는 게 아니라 가끔 충돌(conflicts)이 일어나기도 한다는 점이다. 필요하다면 개발이 완료되어 merge된 branch는 아래와 같이 삭제한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D some_function</span><br></pre></td></tr></table></figure>
<h4 id="merge-conflict가-발생한다면"><a href="#merge-conflict가-발생한다면" class="headerlink" title="merge conflict가 발생한다면?"></a>merge conflict가 발생한다면?</h4><p>개발이 완료되면 branch를 merge하는 과정에서 충분히 conflic가 발생할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> foo.java Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD <span class="comment">// conflict 가 발생한 범위의 시작</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">=======</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="number">55737474728739293729138123737392371293123737</span>e <span class="comment">// 모든 commit은 유일한 커밋 ID를 가진다</span></span><br></pre></td></tr></table></figure>
<p>conflict 부분을 직접 수정해서 다시 commit하는 전략을 취한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &apos;Conclude merge&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>merge 전에 변경 내용을 확인하는 방법</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status -sb</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff some_function master</span><br></pre></td></tr></table></figure>
<p>Merge 중에 발생한 충돌을 해결하는 방법은 몇 가지가 있다. 첫 번째는 그저 이 상황을 벗어나는 것이다. 예상하고 있던 일도 아니고 지금 당장 처리할 일도 아니라면 git merge –abort 명령으로 간단히 Merge 하기 전으로 되돌린다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --abort</span><br></pre></td></tr></table></figure>
<h4 id="로컬-변경-내용을-되돌리기"><a href="#로컬-변경-내용을-되돌리기" class="headerlink" title="로컬 변경 내용을 되돌리기"></a>로컬 변경 내용을 되돌리기</h4><p>로컬에서 발생한 변경내역을 되돌리는 일은 빈번히 발생할 수 있다. <code>git status</code> 명령을 통해 현재 branch의 상태와 이후의 상태 변경을 위한 Commands를 확인할 수 도 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   Git/git-commands.md</span><br></pre></td></tr></table></figure>
<p>위의 상태는 소스 코드를 변경하고 <code>git add</code>를 통해 인덱스에 변경 내역을 알리기전의 상태이다. 아래와 같이 변경 내역을 되돌릴 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p><code>git add</code> 이후에 변경 내역을 되돌리고자 한다면,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>이미 commit된 내역을 과거로 되돌리고 싶은 경우가 있을 것이다! 먼저 commit history를 살펴보자</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">8ed5068 (HEAD -&gt; unit-test, origin/unit-test) Update README.md</span><br><span class="line">dfff29e (origin/master, master) Merge pull request <span class="comment">#8 from stunstunstun/unit-test</span></span><br><span class="line">eec3b7a Integration runner is completed</span><br><span class="line">0a087cf <span class="comment">#2 Specification list, create, get, update</span></span><br><span class="line">a603da7 Inialize unit <span class="built_in">test</span> environments</span><br><span class="line">55c3e73 (origin/stage, stage) Update README.md</span><br><span class="line">c354d50 Merge pull request <span class="comment">#7 from stunstunstun/api-test</span></span><br><span class="line">2e6b522 (origin/api-test) <span class="comment">#3 Add eslint to devDendencies</span></span><br><span class="line">5e35c21 <span class="comment">#3 Add eslint to devDendencies</span></span><br><span class="line">f9bbe2a <span class="comment">#3 version fixed</span></span><br></pre></td></tr></table></figure>
<p><code>a603da7</code> 이후의 모든 내역을 삭제하고 돌아가고 싶다면 <code>--hard</code> 옵션과 함께 <code>reset</code> 명령을 이용하자</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard a603da7</span><br></pre></td></tr></table></figure>
<p>특정 commit의 변경 내역을 취소하는 새로운 commit을 발행해야하는 경우도 있다. 이미 commit, push 한 경우 드물게 사용하는 것을 권장한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit_id&gt;</span><br></pre></td></tr></table></figure>
<h4 id="최종-버전-릴리즈하기"><a href="#최종-버전-릴리즈하기" class="headerlink" title="최종 버전 릴리즈하기"></a>최종 버전 릴리즈하기</h4><p>애플리케이션의 빌드 및 테스트가 완료되어 새 버전을 릴리즈한다면 읽기 전용 상태의 tag 버전를 생성하는 것이 좋다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag 1.0.0</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>생성한 tag 버전은 아래와 같이 remote 서버에 최종적으로 반영한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin 0.1.0</span><br></pre></td></tr></table></figure>
<h4 id="gh-pages-브랜치를-통해-정적-페이지-관리하기"><a href="#gh-pages-브랜치를-통해-정적-페이지-관리하기" class="headerlink" title="gh-pages 브랜치를 통해 정적 페이지 관리하기"></a><code>gh-pages</code> 브랜치를 통해 정적 페이지 관리하기</h4><p>GitHub Repository를 운영하다 보면 비어 있는 브랜치를 생성해야할 때가 있다. REST API를 제공하는 프로젝트에서 자동으로 생성되는 API Documentation를 정적 페이지를 통해 제공하는 경우가 좋은 예이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/repo-name</span><br><span class="line">$ git symbolic-ref HEAD refs/heads/gh-pages</span><br><span class="line">$ rm .git/index</span><br><span class="line">$ git clean -fdx</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"My GitHub Page"</span> &gt; index.html</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -a -m <span class="string">"First pages commit"</span></span><br><span class="line">$ git push origin gh-pages</span><br></pre></td></tr></table></figure>
<p><code>git checkout -b gh-pages</code>를 통해 브랜치를 생성할 수도 있겠지만 이는 master 브랜치의 과거내역을 가지고 있음을 의미한다. 위와 같은 방법을 참고하면 <code>root branch</code>로 부터 과거 내역이 깔끔히 빈 새로운 브랜치를 생성할 수 있다.</p>
<p><code>gh-pages</code> 브랜치가 생성되면 아래의 경로를 통해서 정적 페이지에 접속할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;username&gt;.github.io/&lt;projectname&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://gist.github.com/ramnathv/2227408" target="_blank" rel="external">https://gist.github.com/ramnathv/2227408</a></p>
</blockquote>
<h2 id="remote-branch-참조와-업데이트"><a href="#remote-branch-참조와-업데이트" class="headerlink" title="remote branch 참조와 업데이트"></a>remote branch 참조와 업데이트</h2><h4 id="remote-서버를-변경해야-할-때"><a href="#remote-서버를-변경해야-할-때" class="headerlink" title="remote 서버를 변경해야 할 때"></a>remote 서버를 변경해야 할 때</h4><p>git 저장소의 주소가 변경되는 등의 이슈로 인해 remote 서버를 변경해야 한다면 아래의 명령을 참고한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://wjdsupj@github.com/wjdsupj/awesome-wiki (fetch)</span><br><span class="line">origin  https://wjdsupj@github.com/wjdsupj/awesome-wiki (push)</span><br><span class="line">$ git remote <span class="built_in">set</span>-url origin https://stunstunstun@github.com/stunstunstun/awesome-wiki</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://stunstunstun@github.com/stunstunstun/awesome-wiki (fetch)</span><br><span class="line">origin  https://stunstunstun@github.com/stunstunstun/awesome-wiki (push)</span><br></pre></td></tr></table></figure>
<h4 id="remote-branch-상태-보기"><a href="#remote-branch-상태-보기" class="headerlink" title="remote branch 상태 보기"></a>remote branch 상태 보기</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure>
<h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p>로컬 저장소를 리모트 저장소와 동기화하고, 자동적으로 더이상 유효하지 않은 branch 참조를 제거한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin --prune</span><br></pre></td></tr></table></figure>
<h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote update --prune  <span class="comment"># Only prune, don't fetch</span></span><br></pre></td></tr></table></figure>
<h2 id="GitHub의-오픈소스에-기여하기"><a href="#GitHub의-오픈소스에-기여하기" class="headerlink" title="GitHub의 오픈소스에 기여하기"></a>GitHub의 오픈소스에 기여하기</h2><p>GitHub에는 다양한 오픈소스들이 존재하고 경우에 따라서는 직접 참여해 관심있는 오픈소스에 기여할 수도 있다. 이를 위해서는 먼저 오픈소스의 Repository를 아래의 Fork 버튼을 통해 자신의 계정에 추가해야 한다.</p>
<p><img src="https://help.github.com/assets/images/help/repository/fork_button.jpg"></p>
<h4 id="Fork한-Repository-clone-하기"><a href="#Fork한-Repository-clone-하기" class="headerlink" title="Fork한 Repository clone 하기"></a>Fork한 Repository clone 하기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/YOUR-USERNAME/jest</span><br></pre></td></tr></table></figure>
<h4 id="Fork를-위한-remote-설정하기"><a href="#Fork를-위한-remote-설정하기" class="headerlink" title="Fork를 위한 remote 설정하기"></a>Fork를 위한 remote 설정하기</h4><p>Fork한 Repository를 앞으로 자신의 Repository와 동기화하기 위해서는 아래와 같이 <code>upstream</code> remote를 추가한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/stunstunstun/jest (fetch)</span><br><span class="line">origin	https://github.com/stunstunstun/jest (push)</span><br><span class="line">$ git remote add upstream https://github.com/facebook/jest</span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/stunstunstun/jest (fetch)</span><br><span class="line">origin	https://github.com/stunstunstun/jest (push)</span><br><span class="line">upstream	https://github.com/facebook/jest (fetch)</span><br><span class="line">upstream	https://github.com/facebook/jest (push)</span><br></pre></td></tr></table></figure>
<h4 id="Fork와-동기화하기"><a href="#Fork와-동기화하기" class="headerlink" title="Fork와 동기화하기"></a>Fork와 동기화하기</h4><p>아래와 같은 명령순으로 원본 Repository에서 merge할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch upstream</span><br><span class="line">remote: Counting objects: 63, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 63 (delta 46), reused 51 (delta 45), pack-reused 6</span><br><span class="line">Unpacking objects: 100% (63/63), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/facebook/jest</span><br><span class="line"> * [new branch]        ericnakagawa-add-romanian -&gt; upstream/ericnakagawa-add-romanian</span><br><span class="line"> * [new branch]        gh-pages                  -&gt; upstream/gh-pages</span><br><span class="line"> * [new branch]        master                    -&gt; upstream/master</span><br><span class="line">$ git checkout master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git merge upstream/master</span><br><span class="line">Updating 5a378915..4f685d88</span><br><span class="line">Fast-forward</span><br><span class="line"> CHANGELOG.md                                                   |   34 ++-</span><br><span class="line"> docs/GlobalAPI.md                                              |   14 +-</span><br><span class="line"> examples/react-native/package.json                             |    2 +-</span><br><span class="line"> integration_tests/__tests__/__snapshots__/globals.test.js.snap |   17 ++</span><br><span class="line"> integration_tests/__tests__/globals.test.js                    |   18 ++</span><br><span class="line"> integration_tests/__tests__/jasmine_async.test.js              |    6 +</span><br><span class="line"> integration_tests/jasmine_async/__tests__/generator.test.js    |   25 ++</span><br><span class="line"> package.json                                                   |   10 +-</span><br><span class="line"> packages/jest-jasmine2/package.json                            |    2 +</span><br><span class="line"> packages/jest-jasmine2/src/jasmine/Suite.js                    |   29 +-</span><br><span class="line"> packages/jest-jasmine2/src/jasmine_async.js                    |    9 +-</span><br><span class="line"> scripts/browserBuild.js                                        |    4 +-</span><br><span class="line"> types/Circus.js                                                |    2 +-</span><br><span class="line"> yarn.lock                                                      | 1126 ++++++++++++++++++++++++++++++++++++++++++++++++++---------------------</span><br><span class="line"> 14 files changed, 954 insertions(+), 344 deletions(-)</span><br><span class="line"> create mode 100644 integration_tests/jasmine_async/__tests__/generator.test.js</span><br></pre></td></tr></table></figure>
<h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>이 명령을 통해서는 로컬에서 참고하는 다양한 옵션을 설정한다. 예를 들면 Git Repository에서 참조하는 계정을 아래와 같이 설정할 수 있다.</p>
<p><code>global</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;stunstunstun&quot;</span><br><span class="line">$ git config --global user.email &quot;wjdsupj@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<p><code>local</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --local user.name &quot;stunstunstun&quot;</span><br><span class="line">$ git config --local user.email &quot;wjdsupj@gmail.com&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://git-scm.com/docs/git-config" target="_blank" rel="external">https://git-scm.com/docs/git-config</a></p>
</blockquote>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 Git Flow를 통해 기본적인 명령들을 살펴보았다. Git에 대해 더 알고 싶다면 아래의 자료를 참고하면 많은 도움이 될 것이다!</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://git-scm.com/docs/" target="_blank" rel="external">Git Docs</a></li>
<li><a href="https://github.com/k88hudson/git-flight-rules" target="_blank" rel="external">Git Flight Rules</a></li>
<li><a href="https://www.youtube.com/watch?v=MJUJ4wbFm_A" target="_blank" rel="external">An Introduction Git and GitHub</a></li>
<li><a href="https://try.github.io" target="_blank" rel="external">Git Basic Tutorials</a></li>
<li><a href="http://guides.github.com" target="_blank" rel="external">Git Guides</a></li>
<li><a href="https://github.com/mingrammer/git-tips" target="_blank" rel="external">Git Tips</a></li>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="external">Pro Git Book 2nd</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2018/04/15/react-optimizing-virtual-dom-explained/"><i class="fa fa-arrow-left" aria-hidden="true"></i></a></div><ins class="adsbygoogle adsense-bottom" style="display:block;" data-ad-client="ca-pub-6188640546219653" data-ad-slot="6129396565" data-ad-format="auto"></ins><div class="fb-comments-area"><div class="fb-comments" data-href="https://www.holaxprogramming.com/2018/11/01/git-commands/" data-width="700" data-numposts="5"></div></div><div class="copyright"><p>© 2012 - 2022 <a href="https://github.com/stunstunstun" target="_blank">Minhyeok Jung</a>. Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/stunstunstun/hexo-theme-chiangmai" target="_blank">hexo-theme-chiangmai</a>.</p></div></footer></div><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({});</script><script>window.fbAsyncInit=function(){FB.init({appId:"1258629384258634",cookie:!0,xfbml:!0,version:"v2.8"}),FB.AppEvents.logPageView()},function(e,n,t){var o,c=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="//connect.facebook.net/en_US/sdk.js",c.parentNode.insertBefore(o,c))}(document,"script","facebook-jssdk");</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create','UA-97419941-1','auto');ga('send','pageview');</script></body></html>