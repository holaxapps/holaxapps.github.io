<!DOCTYPE html><html lang="ko" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Java 시스템 운영 중 알아두면 쓸모 있는 지식들 · 안녕 프로그래밍</title><meta name="description" content="안녕 프로그래밍"><meta name="og:title" content="Java 시스템 운영 중 알아두면 쓸모 있는 지식들"><meta name="og:type" content="website"><meta name="og:url" content="https://www.holaxprogramming.com/2017/10/09/java-jvm-performance/"><meta name="og:image" content="http://image.toast.com/aaaaahq/hola_cover.JPG"><meta name="og:description" content="안녕 프로그래밍"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/chiangmai.css"><meta name="steem:author" content="@stunstunstun"><meta name="fb:app_id" content="1258629384258634"><link rel="search" type="application/opensearchdescription+xml" href="https://www.holaxprogramming.com/atom.xml" title="안녕 프로그래밍"></head><body class="post"><div id="fb-root"></div><div class="wrap"><header><nav class="navi-post"><a class="navi-post-back" href="javascript:history.back()"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="navi-post-home" href="/"><i class="fa fa-home" aria-hidden="true"></i></a></nav></header><main class="post"><div class="post"><article class="post-block"><h1 class="post-title">Java 시스템 운영 중 알아두면 쓸모 있는 지식들</h1><div class="post-info"><div class="post-info-profile"><a href="https://github.com/stunstunstun" target="_blank"><img src="/image/profile.jpg"></a></div><div class="post-info-details"><div class="post-categories"><a href="/categories/java" target="_self"><span>JAVA</span></a></div><div class="post-date">2017년 10월 9일</div></div></div><div class="post-share"><div class="fb-like" data-href="https://www.holaxprogramming.com/2017/10/09/java-jvm-performance/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false">                 </div><div class="fb-share-button" data-href="https://www.holaxprogramming.com/2017/10/09/java-jvm-performance/" data-layout="button" data-size="small" data-mobile-iframe="true"></div><div class="fb-follow" data-href="https://www.facebook.com/holaxprogramming/" data-layout="button_count" data-size="small" data-show-faces="true"></div></div><div class="post-content"><p>Java 기반의 서버 애플리케이션은 운영 중에 아래와 같은 메세지와 함께 장애로 이어지는 결과가 일어나곤 합니다.</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java.lang.OutOfMemoryError: Permgen space</span><br></pre></td></tr></table></figure>
<p>Java 기반의 애플리케이션의 메모리는 운영체제의 JVM에서 관리하기 때문에 최악의 효율이 발생한다면 Full GC로 인해 애플리케이션이 멈추는 Stop The World 현상에서 자유로울 수 없습니다.</p>
<p>이렇게 우리가 운영하고 있는 서비스는 하루에도 몇 번씩 GC가 발생하고 있고, 이런 상황에서 시스템 이슈로 인한 장애 알람을 받지 않아도 우리의 생각과는 다르게 사용자에게 <code>503(Service Unavailable)</code> 오류가 반환되고 있을지도 모르는 일입니다.</p>
<p>이 글에서는 Java 시스템을 운영 중 문제가 발생할 때 기본적으로 알아두어야할 내용을 다룹니다.</p>
<h2 id="프로세스와-쓰레드"><a href="#프로세스와-쓰레드" class="headerlink" title="프로세스와 쓰레드"></a>프로세스와 쓰레드</h2><p>웹 애플리케이션은 일반적인 경우에는 처리량을 극대화하는 것보다는 많은 사용자에게 지연 시간을 최대한 줄이면서 안정적인 서비스를 제공하는 것이 중요하다.</p>
<p>좋은 시스템은 이와 같이 어떻게 서비스의 특징에 맞게 컴퓨터의 자원을 효율적으로 사용하는지에 대한 고민으로 시작된다.</p>
<p>우리가 알다시피 운영체제는 컴퓨터의 자원을 여러 프로세스가 효율적으로 사용할 수 있도록 도와준다. 예를 들면 웹 애플리케이션을 효율적으로 운영하기 위해 Apache, Tomcat를 사용한다고 가정해보자. Apache, Tomcat 역시 운영체제로부터 프로세스를 할당받아 컴퓨터의 자원을 사용하고 애플리케이션 내부에서는 프로세스의 자원을 활용해 쓰레드를 생성한다.</p>
<p>이것은 운영체제에서 서버 애플리케이션을 효율적으로 운영하기위해서는 먼저 Apache, Tomcat의 특성을 파악해야하는 것을 의미한다.</p>
<h4 id="Apache는-정적-리소스를-효율적으로-제공한다"><a href="#Apache는-정적-리소스를-효율적으로-제공한다" class="headerlink" title="Apache는 정적 리소스를 효율적으로 제공한다"></a>Apache는 정적 리소스를 효율적으로 제공한다</h4><p>웹 애플리케이션을 구성하면서 이미지나 HTML 페이지와 같은 <code>정적(static)</code> 리소스를 Tomcat과 같은 WAS에서 모두 제공할 수도 있지만 정적 리소스는 Apache를 통해 관리하는 것이 유리하다.</p>
<ul>
<li>Tomcat은 정적 페이지에 대해 Apache만큼 빠르지 못하다.</li>
<li>Tomcat은 Apache 만큼 Reverse Proxy 서버를 구성하기 위한 다양한 설정을 제공하지 않는다.</li>
</ul>
<p>그럼 Apache를 통해 얻을 수 있는 유리한 점들을 더 살펴보도록 하자.</p>
<h4 id="Apache와-프로세스"><a href="#Apache와-프로세스" class="headerlink" title="Apache와 프로세스"></a>Apache와 프로세스</h4><p>웹서버 성능에 가장 큰 영향을 주는 것은 메모리다. 스왑은 요청당 지연시간을 늘리기 때문에 웹서버는 스왑을 하면 안된다. 지연시간이 늘어나면 사용자는 정지하고 다시 접속하면 접차 부하가 계속 증가한다. Apache에서는 MaxClients 지시어를 조절하여 웹서버가 스왑을 할 정도로 많은 자식을 만들지않도록 해야 한다.</p>
<p>MaxClients의 이상적인 값을 찾는 방법은 간단하다, 리눅스의 top과 같은 도구에서 프로세스 목록을 보고 아파치 프로세스의 평균 메모리 사용량을 알아낸 후 전체 사용가능한 메모리에서 다른 프로세스들이 사용할 공간을 뺀 값에서 나눈다.</p>
<blockquote>
<p>모든 설정값은 이와 같이 이론적으로 판단할 수 있지만 정답이라는 것은 없다. 최적화를 위해서는 꼭 성능테스트를 동반하여야 한다.</p>
</blockquote>
<p>나머지는 평범하다. 충분히 빠른 CPU, 충분히 빠른 네트워크 카드, 충분히 빠른 디스크, 여기서 <code>충분히 빠른</code>이란 의미는 실험을 통해 결정해야 한다. 운영체제는 보통 각자 알아서 선택할 일이지만 일반적으로 유용하다고 판명된 몇가지 지침은 아래와 같다.</p>
<ul>
<li>선택한 운영체제의 최신 안정 버전과 패치를 실행한다. 많은 운영체제 제작사는 최근 TCP 스택과 쓰레드 라이브러리에 많은 속도향상을 했다.</li>
<li>클라이언트와 서버에 쓰이는 CPU와 메모리 모두 성능이 과거와는 비교할 수 없을 정도로 매우 좋아졌다.</li>
</ul>
<p><code>Keep-Alive</code>를 사용한다면 자식들은 이미 열린 연결에서 추가 요청을 기다리며 아무것도 하지않기 때문에 계속 바쁘다. KeepAliveTimeout의 기본값 15초는 이런 현상을 최소화한다. 네트워크 대역폭과 서버 자원 간의 균형이 맞게 설정한다. 연결유지의 대부분의 이점이 사라지기때문에 어떤 경우에도 이 값을 60 초 이상으로 올리지 마라.</p>
<h4 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h4><p>앞서 말한 <code>Keep-Alive</code>를 활용하는 예를 설명하자면 HTTPS를 들 수 있다.</p>
<p><code>HTTPS의 암호화 비용</code></p>
<p>웹 애플리케이션에서 클라이언트 서버간에 주고 받는 메세지를 보호하기 위해서는 암호화 과정이 필요하다. HTTP는 외부의 공격이나 스니핑에 매우 취약한 프로토콜이기 때문이다. 암호화는 위해서는 HTTP에 TLS 레이어를 입힌 HTTPS 프로토콜을 일반적으로 사용한다.</p>
<p>하지만 암호화를 위해서는 클라이언트와 서버간에 암호화 알고리즘과 키를 교환하는 <code>handshake</code> 과정이 필요하다. 거기다 HTTPS 인증서를 검증하는 Online Certificate Status Protocol를 통해 인증서 및 인증 기관이 유효한지도 판단한다.</p>
<p><img src="https://i.stack.imgur.com/Rcq1a.png"></p>
<blockquote>
<p><a href="https://tech.ssut.me/2017/05/07/https-is-faster-than-http/" target="_blank" rel="external">https://tech.ssut.me/2017/05/07/https-is-faster-than-http/</a></p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/450px-HTTP_persistent_connection.svg.png"></p>
<p>매 요청마다 이런 handshake를 진행하고 비용이 큰 RSA 알고리즘을 통해 통신을 한다면 서버와 클라이언트 모두 큰 부하가 발생할 수 밖에 없다. 다행인 점은 위 과정이 모두 마친 후의 실제 데이터 통신은 대칭키로 암호화하여 진행된다는 점이다, 여기에 Keep-Alive를 이용하면 세션이 유지될테니 암호화 비용은 줄어 들게 된다.</p>
<p><code>예) httpd.conf 에서의 Keep-Alive 설정</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># KeepAlive: Whether or not to allow persistent connections (more than</span><br><span class="line"># one request per connection). Set to &quot;Off&quot; to deactivate.</span><br><span class="line">KeepAlive On</span><br><span class="line"></span><br><span class="line"># MaxKeepAliveRequests: The maximum number of requests to allow</span><br><span class="line"># during a persistent connection. Set to 0 to allow an unlimited amount.</span><br><span class="line"># We recommend you leave this number high, for maximum performance.</span><br><span class="line">MaxKeepAliveRequests 100</span><br><span class="line"></span><br><span class="line"># KeepAliveTimeout: Number of seconds to wait for the next request from the</span><br><span class="line"># same client on the same connection.</span><br><span class="line">KeepAliveTimeout 15</span><br></pre></td></tr></table></figure>
<h4 id="CPU와-메모리-모두-성능이-과거와는-비교할-수-없을-정도로-매우-좋아졌다"><a href="#CPU와-메모리-모두-성능이-과거와는-비교할-수-없을-정도로-매우-좋아졌다" class="headerlink" title="CPU와 메모리 모두 성능이 과거와는 비교할 수 없을 정도로 매우 좋아졌다"></a>CPU와 메모리 모두 성능이 과거와는 비교할 수 없을 정도로 매우 좋아졌다</h4><p>HTTPS 암호화에 쓰이는 TLS는 크게 변한 것이 없는데 반해, 클라이언트와 서버에 쓰이는 CPU와 메모리 모두 성능이 과거와는 비교할 수 없을 정도로 매우 좋아졌다. HTTPS가 HTTP보다 느리다는 논쟁은 앞으로 무의미할 것으로 보인다.</p>
<h2 id="Tomcat-인스턴스의-구성"><a href="#Tomcat-인스턴스의-구성" class="headerlink" title="Tomcat 인스턴스의 구성"></a>Tomcat 인스턴스의 구성</h2><p>웹 애플리케이션은 스케일-업보다는 <code>스케일-아웃</code>하기 적합한 구조적인 특성을 가지고 있어 장비의 성능에 따라 한 대의 물리적인 장비에 한 개의 Apache 서버와 여러 개의 Tomcat 인스턴스를 구성하는 것이 일반적이였다.</p>
<p><img src="http://static.richardnichols.net/wp-content/uploads/2010/08/Tomcat-cluster-diagram.png"></p>
<p>주로 읽기 전용인 환경에 있어서 처리 능력 향상과 가용성의 증대라는 이점도 있다. 이는 하나의 서버가 장애를 일으켜도 다른 서버로 즉시 처리를 할 수 있는 로드 밸런싱을 의미한다.</p>
<blockquote>
<p>스케일 아웃은 개개의 처리는 비교적 단순하지만 다수의 처리를 동시 병행적으로 실시하지 않으면 안 되는 경우에 적합한데 갱신 데이터의 정합성 유지에 대한 요건이 별로 어렵지 않은 경우에 적절하다</p>
</blockquote>
<h4 id="Tomcat-인스턴스-설정하기"><a href="#Tomcat-인스턴스-설정하기" class="headerlink" title="Tomcat 인스턴스 설정하기"></a>Tomcat 인스턴스 설정하기</h4><p><code>인스턴스별 배포경로 및 로그파일 저장경로</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /home/jungminhyuck/deploy/application</span><br><span class="line">$ mkdir -p /home/jungminhyuck/logs/application</span><br></pre></td></tr></table></figure></p>
<p><code>/scripts/application-tomcat-configurations.xml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class="line">&lt;Server port=&quot;8119&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;off&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JasperListener&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Service name=&quot;application&quot;&gt;</span><br><span class="line">    &lt;Connector port=&quot;8219&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8419&quot; enableLookups=&quot;false&quot; connectionTimeout=&quot;5000&quot; maxThreads=&quot;5&quot; /&gt;</span><br><span class="line">    &lt;Connector port=&quot;8019&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8319&quot; URIEncoding=&quot;UTF-8&quot; enableLookups=&quot;false&quot; connectionTimeout=&quot;5000&quot; maxThreads=&quot;2048&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</span><br><span class="line">      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</span><br><span class="line">            &lt;Context docBase=&quot;/home1/jungminhyuck/deploy/application/&quot; path=&quot;&quot; reloadable=&quot;false&quot; /&gt;</span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>
<p><code>/scripts/start-up-tomcat.sh</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">XML=<span class="string">"/home1/jungminhyuck/scripts/application-tomcat-configurations.xml"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">"en_US.utf8"</span></span><br><span class="line"><span class="built_in">export</span> LANG=<span class="string">"en_US.utf8"</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">"/home1/jungminhyuck/apps/jdk"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_HOME=<span class="string">"/home1/jungminhyuck/apps/tomcat"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_BASE=<span class="string">"/home1/jungminhyuck/apps/tomcat"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_TMPDIR=<span class="string">"/home1/jungminhyuck/apps/tomcat/temp"</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="string">"/home1/jungminhyuck/apps/tomcat/bin/bootstrap.jar"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_LOG=<span class="string">"/home1/jungminhyuck/logs/application/catalina.log"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OUT=<span class="string">"/home1/jungminhyuck/logs/application/catalina.log"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CATALINA_BASE&#125;</span>/bin/startup.sh -config <span class="variable">$&#123;XML&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><code>CATALINA_BASE/bin/setenv.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -Djava.awt.headless=true -server"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -Xmx2048m –Xms2048m"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -XX:NewSize=768m -XX:MaxNewSize=768m"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -XX:PermSize=128m -XX:MaxPermSize=256m"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -XX:+DisableExplicitGC -XX:ParallelGCThreads=2 -XX:-UseConcMarkSweepGC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for application specific parameters at startup</span></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$CATALINA_BASE</span>/bin/appenv.sh"</span> ]; <span class="keyword">then</span></span><br><span class="line">  . <span class="string">"<span class="variable">$CATALINA_BASE</span>/bin/appenv.sh"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><code>CATALINA_BASE/bin/appenv.sh</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -Dspring.profiles.active=dev"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Tomcat의-애플리케이션의-maxThread는-어떤-기준으로-정의해야-하나"><a href="#Tomcat의-애플리케이션의-maxThread는-어떤-기준으로-정의해야-하나" class="headerlink" title="Tomcat의 애플리케이션의 maxThread는 어떤 기준으로 정의해야 하나?"></a>Tomcat의 애플리케이션의 maxThread는 어떤 기준으로 정의해야 하나?</h4><p><code>maxThread</code>는 Tomcat이 요청을 처리하기 위해 만들어내는 최대 Thread 개수를 의미한다. Tomcat과 같은 WAS는 설정해야 하는 값이 굉장히 많지만 그 중 가장 성능에 많은 영향을 주는 부분은 maxThread와 같이 Thread Pool에 직접적으로 연관된 설정일 것이다.</p>
<p>Thread Pool에 대한 설정은 메모리를 얼마나 할당할 것인가와 관련이 있기 때문에 Thread를 수를 많이 사용할 수록 메모리를 많이 점유하게 된다. 그렇다고 반대로 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기하는 상황이 생길수 있다.</p>
<h4 id="웹-애플리케이션은-외부의-어떤-시스템과-연관되어-있나"><a href="#웹-애플리케이션은-외부의-어떤-시스템과-연관되어-있나" class="headerlink" title="웹 애플리케이션은 외부의 어떤 시스템과 연관되어 있나?"></a>웹 애플리케이션은 외부의 어떤 시스템과 연관되어 있나?</h4><p>Tomcat의 maxThread 개수를 위해 고려할 점은 웹 애플리케이션과 연관되는 시스템도 고려할 필요가 있다. 예를 들면 실제 운영 중인 서비스에서 DB 커넥션값이 200에 가까운 수치가 설정되어 있어 문제가 발생된 경우를 보았다. 무엇보다 WAS의 maxThread의 개수는 DB 커넥션 풀의 개수에 비해 적게 설정 되어 있었는데 이는 효율적이지 못하다.</p>
<p>그 이유는 애플리케이션에 대한 모든 요청이 DB에 접근하는 것은 아니기 때문이다. WAS의 maxThread는 DB 커넥션 수보다 여유있게 설정하는 것이 좋다.</p>
<h4 id="전환하기"><a href="#전환하기" class="headerlink" title="전환하기"></a>전환하기</h4><p>지금까지의 과정을 통해 우리는 다수의 Tomcat 인스턴스를 운영하기 위한 준비를 마쳤다. 하지만 앞으로 생각해보아야 할 문제가 더욱 중요하다.</p>
<p><img src="http://bpimediagroup.com/blog/wp-content/uploads/2017/01/Why-.jpg" width="500"></p>
<h2 id="정말로-한-Box에서-다수의-Tomcat-인스턴스를-구성하는-것이-효율적일까"><a href="#정말로-한-Box에서-다수의-Tomcat-인스턴스를-구성하는-것이-효율적일까" class="headerlink" title="정말로 한 Box에서 다수의 Tomcat 인스턴스를 구성하는 것이 효율적일까?"></a>정말로 한 Box에서 다수의 Tomcat 인스턴스를 구성하는 것이 효율적일까?</h2><p>우리는 지금까지 다수의 Tomcat 인스턴스를 통해 컴퓨터의 자원을 효율적으로 사용하고 가용성의 측면에서 이득을 본다고 했지만 안정적인 시스템을 위한 설계는 컴퓨터의 자원과 운영체제에 따라 언제든지 달라질 수 있다.</p>
<p>이보다는 다수의 장비를 운용하면서 한 Box에서 하나의 인스턴스를 운영하는 것이 대게 성능이 좋은 경우가 많은데 이는 운영체제에서 CPU의 자원을 각 프로세스에 Scheduling 정책에 따라서 할당하기 때문이다. </p>
<p>거기다 Tomcat의 인스턴스를 다수를 운영할 때에는 한 장비에서 수용할 수 있는 <code>maxThread</code> 설정을 분산해야하는 등 고려해야할 일이 많아지는 것도 단점이다.</p>
<p>덧붙히면 이 이슈는 마이크로 서비스 아키텍쳐에서는 논쟁 거리가 될만하다. 지난 몇 년동안 많은 개발자들이 거대한 시스템을 작은 마이크로 단위로 옮기는 노력을 해왔기 때문이다. </p>
<p>거기다 JVM과 컴퓨터의 성능은 점점 향상되고 있다는 것이다. G1 GC가 안정적으로 작동하는 지금은 한 장비에서 4GB 이하로 자원을 나누어 다수의 Tomcat 인스턴스를 운영하는 것은 재고할만 하다.</p>
<blockquote>
<p><a href="http://openjdk.java.net/jeps/156" target="_blank" rel="external">http://openjdk.java.net/jeps/156</a></p>
</blockquote>
<p>물론 정답이라는 것은 없으며 최적화를 위해서는 꼭 성능테스트를 동반하여야 한다.</p>
<h2 id="컴퓨터-자원과-운영체제에-따라-달라지는-GC-성능"><a href="#컴퓨터-자원과-운영체제에-따라-달라지는-GC-성능" class="headerlink" title="컴퓨터 자원과 운영체제에 따라 달라지는 GC 성능"></a>컴퓨터 자원과 운영체제에 따라 달라지는 GC 성능</h2><p>Tomcat의 인스턴스 개수를 정하여 효율적으로 컴퓨터의 자원을 활용하기 위해서는 CPU의 코어의 개수, 운영체제가 32bit인지 64bit인지, JVM에서는 어떤 Garbage Collector를 사용하는지에 따라 달라질 수 있기 때문에 단순하게 접근하기는 힘들다고 볼 수 있다.</p>
<p><code>CPU 코어의 수</code></p>
<p>보통 하나의 인스턴스를 운용하는데 1개 정도의 CPU를 사용하는게 최적화된 환경이다. 예를 들면 2CPU 머신의 경우 2개의 Tomcat 인스턴스가 적정하다. CPU 수보다 많은 인스턴스를 사용할 경우에는 각각의 인스턴스에 CPU가 배정 되는 시간이 느려지기 때문에 성능 저하로 이어질 가능성이 높다.</p>
<p><code>메모리의 크기, 운영체제의 비트 체계</code></p>
<p>64bit JVM은 32bit보다 30~40%의 Heap을 더 사용한다. 따라서 더 많은 메모리 할당이 필요하고, GC할 때 더 많은 시간이 걸린다. 하지만 32bit의 JVM은 아래와 같은 제약사항을 가진다.</p>
<table>
<thead>
<tr>
<th>운영체제</th>
<th>제약사항</th>
</tr>
</thead>
<tbody>
<tr>
<td>리눅스</td>
<td>최대 2GB Heap, hugemem 커널의 경우 3GB</td>
</tr>
<tr>
<td>윈도우</td>
<td>최대 1.5GB Heap</td>
</tr>
<tr>
<td>Mac OS X</td>
<td>3.8GB</td>
</tr>
</tbody>
</table>
<p>G1 GC를 제외한 GC에서는 JVM Heap을 무한정 늘리면 Full GC 시간 증가로 인해 오히려 성능 병목이 될 수 있다. 32bit JVM을 사용하고 2-4GB 이하의 Heap 설정을 사용하는게 나을 수 있다. JVM의 Heap을 증가시키기 보다는 JVM의 인스턴스를 늘려 클러스터링이나 로드밸런서로 가용성을 확보하는 방법을 권장한다.</p>
<p><code>32bit의 운영체제에서 2GB의 메모리를 활용하는 JVM의 권장 Option</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.awt.headless=true -server -Xmx1024m –Xms1024m -XX:NewSize=384m -XX:MaxNewSize=384m -XX:MaxPermSize=128m</span><br></pre></td></tr></table></figure>
<p><code>JVM의 Garbage Collector</code></p>
<p>JVM에서 어떤 GC를 사용할 것인지, 즉 GC 알고리즘에 따라 성능이 결정되기도 한다.</p>
<h4 id="quot-그렇다면-어떤-컴퓨팅-환경과-JVM의-Garbage-Collector에-따라서-전략이-달라질까-quot"><a href="#quot-그렇다면-어떤-컴퓨팅-환경과-JVM의-Garbage-Collector에-따라서-전략이-달라질까-quot" class="headerlink" title="&quot;그렇다면 어떤 컴퓨팅 환경과 JVM의 Garbage Collector에 따라서 전략이 달라질까?&quot;"></a><code>&quot;그렇다면 어떤 컴퓨팅 환경과 JVM의 Garbage Collector에 따라서 전략이 달라질까?&quot;</code></h4><p>우리가 GC에 대해 이야기할 때, 우리 대부분은 그 개념을 알고 있으며 우리의 일상적인 프로그래밍에 그것을 사용하고 있다. 그럼에도 불구하고, 우리가 이해할 수 없는 일이 발생한다. JVM에 대한 가장 큰 오해 중 하나는 하나의 GC를 보유하고 있다는 점인데 그렇지 않다.</p>
<p>아래에서는 각각 고유한 장점과 단점이 있는 네개의 서로 다른 Garbage Collector를 살펴보도록 하겠다.</p>
<h2 id="JVM의-다양한-Garbage-Collector"><a href="#JVM의-다양한-Garbage-Collector" class="headerlink" title="JVM의 다양한 Garbage Collector"></a>JVM의 다양한 Garbage Collector</h2><p><img src="http://384uqqh5pka2ma24ild282mv.wpengine.netdna-cdn.com/wp-content/uploads/2014/09/Blog_Trash-1.jpg"></p>
<blockquote>
<p><a href="http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/" target="_blank" rel="external">http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/</a></p>
</blockquote>
<p>JDK 7부터 본격적으로 사용할 수 있는 G1 GC를 제외한, Oracle JVM에서 제공하는 모든 GC는 Generational GC이다. 즉 객체는 처음 생성되면 Eden(Young) 영역으로 들어간다. <code>Minor GC</code>가 일어나면 Eden, From 있는 객체 중 살아있는 객체를 To 영역으로 복사하고 나머지는 해제한다. 이러한 과정을 반복적으로 수행하다가 From, To 영역에서 오래된 객체들은 Old 영역으로 옮겨진다. 이러한 GC 알고리즘을 Copy &amp; Scavenge 라고 하며 속도가 빠르다.</p>
<p>Old 영역에서 일어나는 ‘Major GC’는 Full GC 라고도 하는데, JVM에서 Full GC가 일어나면 모든 Thread가 멈추는 Stop the world 현상이 벌어진다. Full GC는 전체 객체들의 참조를 확인하면서 사용되지 않는 객체를 표시하여 삭제한다. 메모리 영역에 대한 compact가 필요하여 속도가 매우 느리다. 이렇게 활용되는 GC 알고리즘은 Mark &amp; Compact 이라고 한다.</p>
<p>JVM을 튜닝한다는 의미는 Old 영역으로 넘어가는 객체의 수를 최소화하는 것과 Full GC의 실행 시간을 줄이는 노력이다.</p>
<p><code>Old 영역으로 넘어가는 객체의 수 최소화하기</code></p>
<p> 즉, Eden 영역에서 객체가 처음 만들어지고, Survivor 영역을 오가다가, 끝까지 남아 있는 객체는 Old 영역으로 이동한다. 간혹 Eden 영역에서 만들어지다가 크기가 커져서 Old 영역으로 바로 넘어가는 객체도 있긴 하다. Old 영역의 GC는 New 영역의 GC에 비하여 상대적으로 시간이 오래 소요되기 때문에 Old 영역으로 이동하는 객체의 수를 줄이면 Full GC가 발생하는 빈도를 많이 줄일 수 있다. Old 영역으로 넘어가는 객체의 수를 줄인다는 말을 잘못 이해하면 객체를 마음대로 New 영역에만 남길 수 있다고 생각할 수 있지만, 그렇게는 할 수는 없다. 하지만 New 영역의 크기를 잘 조절함으로써 큰 효과를 볼 수는 있다.</p>
<p><code>Full GC 시간 줄이기</code></p>
<p>Full GC의 실행 시간은 상대적으로 Minor GC에 비하여 길다. 그래서 Full GC 실행에 시간이 오래 소요되면(1초 이상) 연계된 여러 부분에서 타임아웃이 발생할 수 있다. 그렇다고 Full GC 실행 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 자칫 OutOfMemoryError가 발생하거나 Full GC 횟수가 늘어난다. 반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다. Old 영역의 크기를 적절하게 ‘잘’ 설정해야 한다.</p>
<p>이는 정답이 정해져있는 것이 아니라 시스템에 따라 지속적으로 모니터링하면서 수치를 정해야 한다는 뜻으로 지금까지의 내용을 JVM Options으로 예를 들면 아래와 같다.</p>
<p><code>JVM Options 예시</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.awt.headless=true -server –Xms2048m -Xmx2048m -XX:NewSize=768m -XX:MaxNewSize=768m -XX:NewRatio=2 -XX:PermSize=128m -XX:MaxPermSize=256m -XX:USeParNewGC</span><br></pre></td></tr></table></figure>
<p>ParallelGC, UseConcMarkSweepGC와 같은 옵션을 볼 수 있는데 구체적으로 각기 다른 GC 알고리즘을 살펴보도록 하겠다.</p>
<h4 id="The-Serial-GC"><a href="#The-Serial-GC" class="headerlink" title="The Serial GC"></a>The Serial GC</h4><p>Serial GC는 가장 단순한 GC이지만 사용하지 않는 것을 추천한다. 싱글 쓰레드 환경을 위해 설계 되었고 아주 작은 Heap영역을 가진다. Full GC가 일어나는 동안 애플리케이션 전체가 대기해야하는 현상이 발생하기 때문에 서버 애플리케이션에 적당하지 않다.</p>
<h4 id="The-Parallel-GC-Threads"><a href="#The-Parallel-GC-Threads" class="headerlink" title="The Parallel GC Threads"></a>The Parallel GC Threads</h4><p>Java 8의 디폴트 GC인 Parallel GC는 문자 그대로 병렬로 GC한다. 메모리가 충분하고 CPU의 성능과 코어 개수가 많아 순간적으로 트래픽이 몰려도 일시 중단을 견딜 수 있고 GC에 의해 야기된 CPU 오버 헤드에 대해 최적화할 수 있는 애플리케이션에 가장 적합합니다.</p>
<ul>
<li><code>-XX:+UseParallelGC</code> 옵션을 사용하여 Minor GC 에서 활성화 할 수 있다.</li>
<li><code>-XX:+UseParallelOldGC</code> 옵션을 사용하여 Major GC에서 활성화 할 수 있다.</li>
</ul>
<h4 id="The-Concurrent-Mark-amp-Sweep-GC"><a href="#The-Concurrent-Mark-amp-Sweep-GC" class="headerlink" title="The Concurrent Mark &amp; Sweep GC"></a>The Concurrent Mark &amp; Sweep GC</h4><p>간단히 CMS GC라고도 하는데, Class Loader로 부터 최초의 객체 참조가 발생하는 Root를 시작으로 객체의 참조 상태를 관리한다.</p>
<p><img src="http://d2.naver.com/content/images/2015/06/helloworld-1329-5.png"></p>
<blockquote>
<p><a href="http://d2.naver.com/helloworld/1329" target="_blank" rel="external">http://d2.naver.com/helloworld/1329</a></p>
</blockquote>
<p>초기 Initial Mark 단계에서는 Class Loader에서 가장 가까운 객체 중 살아 있는 객체만 찾는 것으로 끝낸다. 따라서, 멈추는 시간은 매우 짧다. 그리고 Concurrent Mark 단계에서는 방금 살아있다고 확인한 객체에서 참조하고 있는 객체들을 따라가면서 확인한다. 이 단계의 특징은 다른 스레드가 실행 중인 상태에서 동시에 진행된다는 것이다.</p>
<p><img src="https://plumbr.eu/wp-content/uploads/2015/06/g1-06.png"></p>
<p>위의 화살표가 없는 객체와 같이 더이상 Root와 연관된 객체로 부터 참조되지 않는 객체를 Unreachable 객체라고 하며 GC의 대상으로 삼는다. CMS의 단점은 같은 성능을 위해 Parallel GC에 비해 더욱 많은 CPU 자원을 사용한다는 것인데 이와 같이 많은 CPU 리소스를 할당하려는 경우 메모리의 크기가 4GB 미만인 것으로 가정할 때 사용할 수 있는 GC 알고리즘이다.</p>
<p>만약 운영체제에서 JVM 인스턴스에 할당할 수 있는 메모리의 크기가 4GB보다 큰 경우에는 G1 GC 알고리즘을 사용할 수 있다. CMS는 애플리케이션의 Thread 정지 시간을 최소화 하여 응답시간 지연을 줄이고자 하는 웹 애플리케이션에 적당하다.</p>
<ul>
<li>Major GC 실행시 Application Thread와 GC Thread가 동시에 수행된다.</li>
<li><code>-XX:+UseConcMarkSweepGC</code> 옵션을 사용하여 활성화 할 수 있다.</li>
<li>Minor GC에서 Parallel Collector를 활성화하기 위해서는 <code>-XX:+UseParNewGC</code> 옵션을 사용해야 하며 <code>-XX:+UseParallelGC</code>와 같이 사용해서는 안된다!</li>
</ul>
<h2 id="The-G1-Garbage-First-GC"><a href="#The-G1-Garbage-First-GC" class="headerlink" title="The G1(Garbage First) GC"></a>The G1(Garbage First) GC</h2><p>G1 GC는 <code>JDK 7u4</code> 부터 도입되었으며 4GB이상의 더욱 큰 자원을 제공하고 장기적으로 CMS를 대체하기 위해 설계되었다. G1 GC를 이해하려면 지금까지의 Young 영역과 Old 영역에 대해서는 잊는 것이 좋다.</p>
<p>GC GC는 Generational 한 알고리즘과는 다르게 백그라운드의 멀티 쓰레드를 활용해 1MB에서 32MB까지의 수 많은 리젼으로 Heap을 분할한다.</p>
<p><img src="http://d2.naver.com/content/images/2015/06/helloworld-1329-6.png" width="400"></p>
<blockquote>
<p><a href="http://d2.naver.com/helloworld/1329" target="_blank" rel="external">http://d2.naver.com/helloworld/1329</a></p>
</blockquote>
<p>G1 GC는 위와 같이 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다. 그러다가, 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행한다. 즉, 지금까지 설명한 Young의 세가지 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 GC 방식이라고 이해하면 된다. </p>
<p>G1 GC의 가장 큰 장점은 성능이다. G1은 지연 시간을 줄이기 위해서 지금까지 설명한 어떤 GC 방식보다도 빠르다.</p>
<p>하지만 이와 같이 4GB 이상의 큰 Heap을 가지는 것은 요즘과 같이 마이크로 서비스 아키텍쳐에서는 논쟁 거리가 될만하다. 지난 몇 년동안 많은 개발자들이 거대한 시스템을 작은 마이크로 단위로 옮기는 노력을 해왔기 때문이다.</p>
<p>이는 다양한 애플리케이션을 서로 격리하고 효율적인 배포 프로세스를 통해 거대한 애플리케이션 클래스를 메모리에 로드하는데 소요되는 비용을 절감하는 등 많은 요인을 포함하고 있다. 이는 애플리케이션을 동일한 물리적 머신에 배포할 수 있도록 하는 Docker와 같은 컨테이너 기술에 의해 가속화 되어 왔다.</p>
<p><code>Class Unloading에 대한 이슈</code></p>
<ul>
<li><a href="http://openjdk.java.net/jeps/156" target="_blank" rel="external">http://openjdk.java.net/jeps/156</a></li>
</ul>
<p>Hot Deploy(Hot Swapping)를 많이 할 경우 Java 7의 G1 GC에서는 Perm Generation 영역에 문제가 발생할 수 있다.</p>
<ul>
<li>JDK 7의 G1 GC는 Class Unloading을 Full GC가 발생했을 시에만 수행하게 된다.</li>
<li>이 문제는 JDK 8u40 버전에서 Perm Generation을 없애고 Metaspace 방식으로 바꾼 후에 해결되었다.</li>
</ul>
<p><code>-XX:+UseLargePagesInMetaspace</code></p>
<p>JDK 8에서는 Perm 영역이 아니라 Metaspace에 클래스 정보가 올라가는데 이때 그 영역이 크면 GC 시간이 오래 걸릴 수 있는데 이럴 때는 Metaspace에 Large Page를 사용하여 접근하도록 JVM 옵션을 주면 대부분 문제가 해결될 수 있다는 것</p>
<p><code>JVM Options 예시</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms2048m -Xmx2048m -XX:MaxMetaspaceSize=512m -XX:+UseG1GC -XX:+DisableExplicitGC -XX:+UseStringDeduplication</span><br></pre></td></tr></table></figure>
<h2 id="Java-9의-디폴트-GC는-G1이다"><a href="#Java-9의-디폴트-GC는-G1이다" class="headerlink" title="Java 9의 디폴트 GC는 G1이다"></a>Java 9의 디폴트 GC는 G1이다</h2><p>최근에 Java 9 출시 소식이 있었다. JDK 9에 포함된 다양한 Features 중 32-bit, 64bit 서버 환경에서 G1을 디폴트 Garbage Collector로 변경한 내용이 있다. 더불어 CMS GC는 JDK 9에서 Deprecated 되었다.</p>
<p><code>Make G1 the Default Garbage Collector</code></p>
<ul>
<li><a href="http://openjdk.java.net/jeps/248" target="_blank" rel="external">JEP248</a></li>
</ul>
<p>많은 성능 개선 사항이 JDK 8의 G1과 업데이트 릴리스에 따라 이루어졌으며, 추가 개선 사항이 JDK 9에 추가되었다. 예를 들면 <a href="http://openjdk.java.net/jeps/156" target="_blank" rel="external">JEP156</a> 이슈는 G1을 완전한 품질의 Garbage Collector로 만들 수 있게 해줬다.</p>
<p>이러한 Garbage Collector에 대한 변화는 Parallel GC와 같이 처리량을 극대화하는 것보다 GC의 지연 시간을 제한하는 것이 더 중요하다는 가정 하에 이루어졌다. 만약 이 가정이 잘못되었다면 이 변화는 재고해야 할 필요가 있을 수 있다.</p>
<p><code>G1은 튜닝하기 쉽게 설계되었다</code></p>
<p>Stop The World로 인한 지연 시간을 기본으로 하는 튜닝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx32G -XX:MaxGCPauseMillis=100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-XX:MaxGCPauseMillis의 디폴트 값은 250ms 이다.</p>
</blockquote>
<h2 id="어떤-GC-알고리즘을-선택해야-할까"><a href="#어떤-GC-알고리즘을-선택해야-할까" class="headerlink" title="어떤 GC 알고리즘을 선택해야 할까?"></a>어떤 GC 알고리즘을 선택해야 할까?</h2><p><img src="https://blogs.thomsonreuters.com/answerson/wp-content/uploads/sites/3/2015/09/519915153-getty-competition-pursuit-push-performance-800x450.jpg"></p>
<p>우리는 다양한 GC 알고리즘을 살펴보았지만 중요한 것은 모든 서비스에 완벽하게 맞아 떨어지는 GC 알고리즘은 없다는 것이다. 각 애플리케이션의 특정 동작에 따라 처리량을 극대화하거나 지연 시간을 줄이는 옵션을 따져 적합한 GC를 사용하도록 하자.</p>
<p>Java 9에서도 여전히 ParallelGC를 사용할 수 있기 때문이다.</p>
<h2 id="JVM-튜닝-꼭-해야할까"><a href="#JVM-튜닝-꼭-해야할까" class="headerlink" title="JVM 튜닝 꼭 해야할까?"></a>JVM 튜닝 꼭 해야할까?</h2><p>JVM 튜닝은 가장 마지막에 고려하는 것이 좋다. </p>
<h4 id="quot-JVM-튜닝을-하기전에-스스로에게-3번정도-꼭-다시-물어보자-quot"><a href="#quot-JVM-튜닝을-하기전에-스스로에게-3번정도-꼭-다시-물어보자-quot" class="headerlink" title="&quot;JVM 튜닝을 하기전에 스스로에게 3번정도 꼭 다시 물어보자.&quot;"></a><code>&quot;JVM 튜닝을 하기전에 스스로에게 3번정도 꼭 다시 물어보자.&quot;</code></h4><p>그 이유는 대게의 문제는 JVM 튜닝이 필요한 것이 아니라 애플리케이션 내부에 이슈가 있는 경우가 많기 때문이다. 애플리케이션을 구동하는 운영체제에 메모리가 해제되지 않는 등의 이상 징후가 생긴다면, 먼저 애플리케이션에서 과도하게 많은 메모리를 차지하는 객체를 추적할 필요가 있다. </p>
<p>특히 웹 애플리케이션과 같은 멀티 쓰레드 환경에서는 한 자원에 여러 쓰레드가 동시에 접근하면서 메모리 참조에 이상이 생기는 경우가 있다.</p>
<p>이 의미는 Garbage 객체가 누수되어 시스템에 좋지 않은 영향을 미친다는 것이다. 가장 많이 하는 실수는 메모리를 이용하는 클래스를 구현하면서 클래스 내부의 <code>HashMap</code>을 잘못 사용하는 경우이다. <code>HashMap</code>의 put(), get()를 사용할 때에는 동기화 기법을 통해 Thread Safe하게 코드를 작성하거나 <code>ConcurrentHashMap</code> 를 사용하는 것을 추천한다.</p>
<p>이어서 메모리 참조에 이상이 생긴 객체들을 효과적으로 찾는 다양한 기법을 알아보도록 하자.</p>
<h2 id="GC-모니터링"><a href="#GC-모니터링" class="headerlink" title="GC 모니터링"></a>GC 모니터링</h2><h4 id="GC-로그를-위한-JVM-Options"><a href="#GC-로그를-위한-JVM-Options" class="headerlink" title="GC 로그를 위한 JVM Options"></a>GC 로그를 위한 JVM Options</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XX:-PrintGC -XX:-PrintGCDetails -XX:-PrintGCTimeStamps -XX:-TraceClassUnloading -XX:-TraceClassLoading</span><br></pre></td></tr></table></figure>
<h4 id="스레드-덤프-획득"><a href="#스레드-덤프-획득" class="headerlink" title="스레드 덤프 획득"></a>스레드 덤프 획득</h4><p>스레드 덤프를 획득하는 방범은 여러 가지가 있지만 기본적으로 JVM의 옵션을 통해 Out Of Memory 에러 발생시 아래와 같이 쓰레드 덤프를 획득할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</span><br></pre></td></tr></table></figure>
<p>애플리케이션의 현재 프로세스를 확인하고 실시간으로 쓰레드 덤프를 얻기 위해서는 획득할 당시의 스레드 상태만 알 수 있기 때문에 스레드의 상태 변화를 확인하려면 5초 정도의 간격으로 5 ~ 10회 정도 획득하는 것이 좋다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jps -v</span><br><span class="line">8352 GradleMain -Dorg.gradle.appname=gradle</span><br><span class="line">8372 GradleDaemon -XX:MaxPermSize=256m -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m -Dfile.encoding=UTF-8 -Duser.country=US -Duser.language=en -Duser.variant</span><br><span class="line">8409 Jps -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home -Xms8m</span><br><span class="line">...</span><br><span class="line">$ jstack :PID</span><br><span class="line">...</span><br><span class="line">$ kill -3 :PID</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="jstat-명령을-통한-GC-모니터링"><a href="#jstat-명령을-통한-GC-모니터링" class="headerlink" title="jstat 명령을 통한 GC 모니터링"></a>jstat 명령을 통한 GC 모니터링</h4><p>현재 JVM의 메모리 상태를 확인할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$JAVA_HOME/bin/jstat</span><br></pre></td></tr></table></figure>
<h4 id="Memory-Analyzer-MAT"><a href="#Memory-Analyzer-MAT" class="headerlink" title="Memory Analyzer(MAT)"></a>Memory Analyzer(MAT)</h4><p>이클립스를 사용한다면 MAT 플러그인도 도움이 된다. MAT은 hprof 파일을 분석해서 메모리 분석, 통계를 내는 기능을 제공한다.</p>
<ul>
<li><a href="http://eclipse.org/mat" target="_blank" rel="external">http://eclipse.org/mat</a></li>
</ul>
<h2 id="정리하며"><a href="#정리하며" class="headerlink" title="정리하며"></a>정리하며</h2><p>지금까지 Java 시스템 운영 중 알아두면 쓸데있는 지식들을 살펴보았습니다. 대용량의 웹 애플리케이션을 운영 하다보면 다양한 문제에 노출되기 쉬운데 여러 각도에서 자신의 시스템을 바라볼 수 있다면 더욱 견고한 시스템을 만들 수 있을 것이라고 생각합니다. 아래는 이 글을 작성하면서 참고한 문서들인데 도움이 되었으면 합니다 :)</p>
<h2 id="이-문서는-아래의-글을-참고하였습니다"><a href="#이-문서는-아래의-글을-참고하였습니다" class="headerlink" title="이 문서는 아래의 글을 참고하였습니다"></a>이 문서는 아래의 글을 참고하였습니다</h2><ul>
<li><a href="https://httpd.apache.org/docs/2.4/ko/misc/perf-tuning.html" target="_blank" rel="external">https://httpd.apache.org/docs/2.4/ko/misc/perf-tuning.html</a></li>
<li><a href="http://presentations2015.s3.amazonaws.com/40_presentation.pdf" target="_blank" rel="external">http://presentations2015.s3.amazonaws.com/40_presentation.pdf</a></li>
<li><a href="http://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection" target="_blank" rel="external">http://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection</a></li>
<li><a href="https://www.optaplanner.org/blog/2015/07/31/WhatIsTheFastestGarbageCollectorInJava8.html" target="_blank" rel="external">https://www.optaplanner.org/blog/2015/07/31/WhatIsTheFastestGarbageCollectorInJava8.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></li>
<li><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="external">http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#available_collectors.selecting" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#available_collectors.selecting</a></li>
<li><a href="https://docs.oracle.com/cd/E40518_01/integrator.311/integrator_install/src/cli_ldi_server_config.html" target="_blank" rel="external">https://docs.oracle.com/cd/E40518_01/integrator.311/integrator_install/src/cli_ldi_server_config.html</a></li>
<li><a href="https://databricks.com/blog/2015/05/28/tuning-java-garbage-collection-for-spark-applications.html" target="_blank" rel="external">https://databricks.com/blog/2015/05/28/tuning-java-garbage-collection-for-spark-applications.html</a></li>
<li><a href="http://d2.naver.com/helloworld/1329" target="_blank" rel="external">http://d2.naver.com/helloworld/1329</a></li>
<li><a href="http://d2.naver.com/helloworld/37111" target="_blank" rel="external">http://d2.naver.com/helloworld/37111</a></li>
<li><a href="http://d2.naver.com/helloworld/132178" target="_blank" rel="external">http://d2.naver.com/helloworld/132178</a></li>
<li><a href="http://d2.naver.com/helloworld/184615" target="_blank" rel="external">http://d2.naver.com/helloworld/184615</a></li>
<li><a href="http://d2.naver.com/helloworld/6043" target="_blank" rel="external">http://d2.naver.com/helloworld/6043</a></li>
<li><a href="http://d2.naver.com/helloworld/329631" target="_blank" rel="external">http://d2.naver.com/helloworld/329631</a></li>
<li><a href="http://d2.naver.com/helloworld/1326256" target="_blank" rel="external">http://d2.naver.com/helloworld/1326256</a></li>
<li><a href="http://d2.naver.com/helloworld/1134732" target="_blank" rel="external">http://d2.naver.com/helloworld/1134732</a></li>
<li><a href="https://gist.github.com/hardyoyo/8664b2171d26adcf7b7e" target="_blank" rel="external">https://gist.github.com/hardyoyo/8664b2171d26adcf7b7e</a></li>
<li><a href="https://gist.github.com/patmandenver/cadb5f3eb567a439ec01" target="_blank" rel="external">https://gist.github.com/patmandenver/cadb5f3eb567a439ec01</a></li>
<li><a href="https://stackoverflow.com/questions/35824572/g1gc-how-to-use-all-free-memory" target="_blank" rel="external">https://stackoverflow.com/questions/35824572/g1gc-how-to-use-all-free-memory</a></li>
<li><a href="http://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection" target="_blank" rel="external">http://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection</a></li>
<li><a href="http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/" target="_blank" rel="external">http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/</a></li>
<li><a href="http://blog.takipi.com/7-things-you-thought-you-knew-about-garbage-collection-and-are-totally-wrong/" target="_blank" rel="external">http://blog.takipi.com/7-things-you-thought-you-knew-about-garbage-collection-and-are-totally-wrong/</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2017/08/16/java-history/"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="next" href="/2017/10/16/devops-aws-codestar/"><i class="fa fa-arrow-right" aria-hidden="true"></i></a></div><ins class="adsbygoogle adsense-bottom" style="display:block;" data-ad-client="ca-pub-6188640546219653" data-ad-slot="6129396565" data-ad-format="auto"></ins><div class="fb-comments-area"><div class="fb-comments" data-href="https://www.holaxprogramming.com/2017/10/09/java-jvm-performance/" data-width="700" data-numposts="5"></div></div><div class="copyright"><p>© 2012 - 2022 <a href="https://github.com/stunstunstun" target="_blank">Minhyeok Jung</a>. Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/stunstunstun/hexo-theme-chiangmai" target="_blank">hexo-theme-chiangmai</a>.</p></div></footer></div><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({});</script><script>window.fbAsyncInit=function(){FB.init({appId:"1258629384258634",cookie:!0,xfbml:!0,version:"v2.8"}),FB.AppEvents.logPageView()},function(e,n,t){var o,c=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="//connect.facebook.net/en_US/sdk.js",c.parentNode.insertBefore(o,c))}(document,"script","facebook-jssdk");</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create','UA-97419941-1','auto');ga('send','pageview');</script></body></html>