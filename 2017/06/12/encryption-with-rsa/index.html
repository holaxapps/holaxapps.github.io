<!DOCTYPE html><html lang="ko" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>RSA를 이용한 암호화와 서명 · 안녕 프로그래밍</title><meta name="description" content="Java 프로그래밍을 활용하는 서명과 암호화 기법"><meta name="og:title" content="RSA를 이용한 암호화와 서명"><meta name="og:type" content="website"><meta name="og:url" content="https://www.holaxprogramming.com/2017/06/12/encryption-with-rsa/"><meta name="og:image" content="https://www.amatisnetworks.com/wp-content/uploads/2016/06/Public-Key-Encryption-shutterstock_224144242.jpg"><meta name="og:image:secure_url" content="https://www.amatisnetworks.com/wp-content/uploads/2016/06/Public-Key-Encryption-shutterstock_224144242.jpg"><meta name="og:description" content="Java 프로그래밍을 활용하는 서명과 암호화 기법"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/chiangmai.css"><meta name="steem:author" content="@stunstunstun"><meta name="fb:app_id" content="1258629384258634"><link rel="search" type="application/opensearchdescription+xml" href="https://www.holaxprogramming.com/atom.xml" title="안녕 프로그래밍"></head><body class="post"><div id="fb-root"></div><div class="wrap"><header><nav class="navi-post"><a class="navi-post-back" href="javascript:history.back()"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="navi-post-home" href="/"><i class="fa fa-home" aria-hidden="true"></i></a></nav></header><main class="post"><div class="post"><article class="post-block"><h1 class="post-title">RSA를 이용한 암호화와 서명</h1><div class="post-info"><div class="post-info-profile"><a href="https://github.com/stunstunstun" target="_blank"><img src="/image/profile.jpg"></a></div><div class="post-info-details"><div class="post-categories"><a href="/categories/fundamental" target="_self"><span>FUNDAMENTAL</span></a></div><div class="post-date">2017년 6월 12일</div></div></div><div class="post-share"><div class="fb-like" data-href="https://www.holaxprogramming.com/2017/06/12/encryption-with-rsa/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false">                 </div><div class="fb-share-button" data-href="https://www.holaxprogramming.com/2017/06/12/encryption-with-rsa/" data-layout="button" data-size="small" data-mobile-iframe="true"></div><div class="fb-follow" data-href="https://www.facebook.com/holaxprogramming/" data-layout="button_count" data-size="small" data-show-faces="true"></div></div><div class="post-content"><p>암호화는 과거부터 현재까지 소중한 정보를 지키는데 중요한 수단으로 활용되어 왔다. 세계 2차 대전에서 독일군의 최초의 자동화된 암호화 기계인 <code>에니그마</code>를 해독해 연합군을 승리로 이끈 튜링의 일화는 그 예를 가장 잘 보여주고 있다.</p>
<a id="more"></a>
<p>그뿐만 아니라 튜링은 암호학뿐만 아니라 인류에게 또 다른 선물을 안긴 천재 수학자이기도 하다. 튜링은 현대 컴퓨터의 이론적 모델인 <code>튜링머신</code>을 고안했다.</p>
<p><img src="http://www.stutteringhelp.org/sites/default/files/pictures/alan-turing.jpg" width="500"></p>
<p>이처럼 암호학은 현대 컴퓨터의 기초가 되었으며, 지금의 인터넷을 기반으로 한 서비스에서도 암호화 기법은 중요하고 다양하게 활용되고 있는데 이 글에서는 공개키를 통한 <a href="https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8" target="_blank" rel="external">RSA 알고리즘</a>의 활용 방법에 대해 설명하고자 한다.</p>
<p>공개키를 이용한 RSA는 암호화뿐만 아니라 전자 서명이 가능한 알고리즘이다. RSA를 이용한 서명과 암호화 기법을 설명하기 이전에 <code>대칭키</code> 암호화 방식에 대한 지식이 없다면 앞으로의 내용이 추상적으로 들릴 수 있기 때문에 대칭키 암호화 방식을 먼저 살펴보도록 하겠다.</p>
<h2 id="대칭키를-이용한-암호화"><a href="#대칭키를-이용한-암호화" class="headerlink" title="대칭키를 이용한 암호화"></a>대칭키를 이용한 암호화</h2><p>암호화를 위해서는 기본적으로 암호화의 대상이 되는 <code>평서문(Plain Text)</code>과 암호화를 위한 일종의 비밀번호인 <code>암호키(Cryptography Key)</code> 그리고 마지막으로 암호화 <code>알고리즘(Algorithm)</code>이 필요한데, 대칭키 암호화 방식은 문자 그대로 암호화와 복호화를 동일한 암호키를 이용하는 방식을 말한다.</p>
<p><img src="https://uploads.skyhighnetworks.com/2015/07/15150142/In_Page_Encryption_Decryption_Diagram_700.png" width="500"></p>
<blockquote>
<p>사진 - <a href="https://www.skyhighnetworks.com/cloud-security-university/tokenization-vs-encryption/" target="_blank" rel="external">https://www.skyhighnetworks.com/cloud-security-university/tokenization-vs-encryption/</a></p>
</blockquote>
<p> 위의 그림을 통해 살펴보면 동일한 암호키를 통해 <code>암호화(Encryption)</code>, <code>복호화(Decryption)</code>하는 것을 볼 수 있는데, 대칭키를 사용하는 암호화 알고리즘은 <code>AES</code>와 <code>DES</code>가 대표적이다. 본문은 RSA를 이용한 서명과 암호화의 활용 방법을 전달하는 것이 주된 목적이기 때문에 대칭키를 이용한 암호화 알고리즘에 대한 자세한 설명은 생략한다.</p>
<h4 id="openssl을-통해-구체적으로-암호화-복호화되는-과정을-살펴보도록-하자"><a href="#openssl을-통해-구체적으로-암호화-복호화되는-과정을-살펴보도록-하자" class="headerlink" title="openssl을 통해 구체적으로 암호화, 복호화되는 과정을 살펴보도록 하자"></a>openssl을 통해 구체적으로 암호화, 복호화되는 과정을 살펴보도록 하자</h4><p><code>plain.txt</code>라는 파일의 내용을 <code>DES3</code> 알고리즘을 통해 암호화하는 과정이다. 예시로 암호화를 위한 패스워드는 <code>123456</code> 이라고 가정한다. 암호화된 결과는 <code>cipher.bin</code>를 통해 저장한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;안녕 프로그래밍&apos; &gt; plain.txt</span><br><span class="line">$ openssl enc -e -des3 -in plain.txt -out cipher.bin</span><br><span class="line">enter des-ede3-cbc encryption password: 123456</span><br><span class="line">Verifying - enter des-ede3-cbc encryption password: _</span><br></pre></td></tr></table></figure>
<p>암호화된 <code>cipher.bin</code>은 기존의 내용을 식별할 수 없는 상태이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat cipher.bin</span><br><span class="line">Salted__�Bd����������m��LoS�t��ɽҝ��J</span><br></pre></td></tr></table></figure></p>
<p>마지막으로 <code>DES3</code> 알고리즘을 통해 복호화하는 과정이다. 암호화에 사용한 패스워드를 통해 아래와 같이 동일한 평서문을 얻을 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl enc -d -des3 -in cipher.bin -out hola.txt</span><br><span class="line">enter des-ede3-cbc decryption password: 123456</span><br><span class="line">$ cat hola.txt</span><br><span class="line">안녕 프로그래밍</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>OpenSSL(<a href="https://www.openssl.org/)은" target="_blank" rel="external">https://www.openssl.org/)은</a> TLS/SSL 프로토콜을 구현하는 오픈소스 프로젝트이다. OpenSSL에서는 TLS/SSL 프로토콜을 위한 다양한 암호화와 서명 기법을 제공한다.</p>
</blockquote>
<h2 id="RSA를-이용한-암호화"><a href="#RSA를-이용한-암호화" class="headerlink" title="RSA를 이용한 암호화"></a>RSA를 이용한 암호화</h2><p><code>RSA</code>는 공개키를 이용하는 대표적인 암호화 방식이며 전자서명이 가능한 최초의 알고리즘으로 알려져 있다. <code>AES</code>, <code>DES</code>와 같은 대칭키 암호화 방식에서 발생하는 문제점을 해결하였다.</p>
<p>과거의 암호 방식은 암호화를 위한 키뿐만 아니라 알고리즘 역시 노출되지 않기 위해 노력하였으나 현대의 암호에서는 알고리즘을 공개하도록 하고 있다. 그 이유는 키 이외에 암호 시스템의 모든 것이 공개되어도 안전해야 한다고 Kerckhoff은 주장을 했는데 이것을 <code>Kerckhoff의 법칙</code>이라고 한다.</p>
<p>이 때문에 암호화를 위한 비밀번호인 키(Key)는 사용자가 인터넷 서비스를 위해 로그인할 때 필요한 비밀번호와 같이 가장 중요한 요소라고 할 수 있겠다. 하지만 대칭키 암호화 방식은 수신자와 발신자 간에 키를 공유하는 과정이 필요하기 때문에 보안적으로 해결해야 하는 문제가 남아있었다.</p>
<h4 id="공개키와-비밀키를-이용한-암호화-방식"><a href="#공개키와-비밀키를-이용한-암호화-방식" class="headerlink" title="공개키와 비밀키를 이용한 암호화 방식"></a>공개키와 비밀키를 이용한 암호화 방식</h4><p>RSA는 수학적인 기법을 통해 한 쌍의 공개키와 비밀키를 생성하는데, 각각의 키는 이론적으로 아래와 같은 용도로 사용된다.</p>
<p><img src="https://www.amatisnetworks.com/wp-content/uploads/2016/06/Public-Key-Encryption-shutterstock_224144242.jpg" width="500"></p>
<table>
<thead>
<tr>
<th>구분</th>
<th>목적</th>
</tr>
</thead>
<tbody>
<tr>
<td>Public Key</td>
<td>누구에게나 공개될 수 있으며 메세지를 보내는 발신자는 공개키를 통해 정보를 암호화한다</td>
</tr>
<tr>
<td>Private Key</td>
<td>수신자는 비밀키를 암호화된 메세지를 복호화 하는데 사용한다, 외부에 노출되지 않도록 안전하게 보관해야 한다.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>RSA 알고리즘은 반대로 <code>Private Key</code>로 암호화하고 <code>Public Key</code>를 통해 복호화할 수도 있다.</p>
</blockquote>
<p>이와 같이 RSA를 이용한 공개키 암호화 방식은 비밀키(Private Key)를 외부에 노출할 위험이 없어 기존의 대칭키 암호화 방식의 문제를 해결하고 있다.</p>
<p>현대의 암호화에서는 대칭키와 공개키 암호화 방식을 적절히 혼합하여 사용하고 있는데 구체적으로 어떻게 활용되고 있는지 살펴보자.</p>
<h2 id="어디에서-활용되고-있을까"><a href="#어디에서-활용되고-있을까" class="headerlink" title="어디에서 활용되고 있을까?"></a>어디에서 활용되고 있을까?</h2><p>우리에게 익숙한 인터넷 서비스에서는 대칭키와 공개키를 이용한 암호화를 다양하게 활용하고 있는데 대표적으로 <code>TLS(Transport Layer Security)</code>라고 불리는 암호 규약이 대표적이며 쉽게 예를 들면 웹 브라우징 시에 사용되는 보안 계층을 말한다.</p>
<p>TLS는 기존의 <code>SSL(Secure Sockets Layer)</code>가 표준화되면서 바뀐 이름이며 우리가 인터넷에서 익숙하게 접하는 <code>HTTPS</code> 프로토콜에서 이를 활용하고 있다.</p>
<h4 id="웹-페이지에서-우리의-아이디와-비밀번호는-안전하게-전달될까"><a href="#웹-페이지에서-우리의-아이디와-비밀번호는-안전하게-전달될까" class="headerlink" title="웹 페이지에서 우리의 아이디와 비밀번호는 안전하게 전달될까?"></a>웹 페이지에서 우리의 아이디와 비밀번호는 안전하게 전달될까?</h4><p>우리는 검색 포털 또는 소셜 미디어 서비스를 이용할 때 먼저 아이디와 패스워드를 통해 로그인을 하는 과정을 거친다. 이와 같이 사용자의 중요한 정보가 웹 브라우저를 통해 서버에 전달될 때는 HTTPS 프로토콜을 통해 안전하게 전달된다.</p>
<p>HTTPS 프로토콜은 내부적으로 앞서 말한 표준화된 <code>TLS(Transport Layer Security)</code> 암호 규약을 사용하는데, TLS를 통해 메세지를 안전하게 주고받는 원리는 다음과 같다.</p>
<p>먼저 지원 가능한 알고리즘 정보를 교환한다. 이 단계에서 키 교환과 인증에 사용될 암호화 방법이 결정된다.</p>
<p><img src="http://image.toast.com/aaaaahq/RSA_1.png"></p>
<p>키 교환과 인증 알고리즘은 RSA와 같은 공개키 기법을 사용하거나 미리 공유된 키(TLS-PSK)를 사용할 수도 있다.</p>
<p><img src="http://image.toast.com/aaaaahq/RSA_2.png"></p>
<p>교환된 공개키를 통해 앞으로 메세지 암호화에 사용될 대칭키를 암호화하여 교환한다</p>
<p><img src="http://image.toast.com/aaaaahq/RSA_3.png"></p>
<p>마지막으로 대칭키를 통해 메세지를 암호화하여 안전하게 전송한다.</p>
<p><img src="http://image.toast.com/aaaaahq/RSA_4.png"></p>
<h4 id="서명과-검증"><a href="#서명과-검증" class="headerlink" title="서명과 검증"></a>서명과 검증</h4><p>TLS에서는 메세지 원본을 암호화하는 것뿐만 아니라 메세지가 인증된 사용자로부터 전달된 것인지 확인하기 위해서 서명과 검증 절차를 거치는데 내용은 아래와 같다.</p>
<p>즉, 원래의 문서 내용을 <code>Message</code>라고 하면 Hash 함수인 SHA256 같은 함수 하나를 정해 <code>Hash된 Message</code>값을 구하고 이 Hash 값을 Client의 비밀키로 암호화한다. 여기까지의 과정을 <code>서명</code>이라고 하며 서명된 결과를 보통 <code>Signature</code>라고 불린다.</p>
<p>최종적으로 원본의 <code>Message</code>끝에 <code>Signature</code>를 첨부하여 전송하며 메세지를 받는 Server는 전달된 <code>Message</code>를 동일한 Hash 함수를 통해 <code>Hash된 Message</code>를 얻는다. 그리고 사전에 교환한 Client의 공개키를 통해 <code>Signature</code> 역시 복호화하는 과정을 가진다.</p>
<p>최종적으로 얻게 된 두 쌍의 <code>Hash된 Message</code>를 비교하여 동일한 값이면 서명이 올바른 것이고 값이 서로 다르거나 변환하는 과정에서 오류가 있다면 서명이 틀리다고 보는 것이다.</p>
<p>아래의 그림과 같이 정리할 수 있다.</p>
<p><img src="http://image.toast.com/aaaaahq/sign-and-verification.png"></p>
<h4 id="Google-Play는-인앱-결제-정보를-어떻게-검증할까"><a href="#Google-Play는-인앱-결제-정보를-어떻게-검증할까" class="headerlink" title="Google Play는 인앱 결제 정보를 어떻게 검증할까?"></a>Google Play는 인앱 결제 정보를 어떻게 검증할까?</h4><p>이 서명과 검증은 특히 돈이 오고가는 결제 내역에 대한 검증에 많이 사용되며 Google Play에서 제공하는 인앱 결제에서는 상품을 지급하기 전에 아래와 같이 결제 내역을 검증하도록 하고 있다.</p>
<p>Google Play에서 제공하는 IPC 방식으로 결제가 완료되면 결제를 요청한 애플리케이션은 아래와 같은 결과를 전달받게 된다.</p>
<p><code>결제 내역 정보가 담긴 JSON</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;orderId&quot;: &quot;12999763169054705758.1374081541263051&quot;,</span><br><span class="line">   &quot;packageName&quot;: &quot;com.holaxapps.chomdoi&quot;,</span><br><span class="line">   &quot;productId&quot;: &quot;gas&quot;,</span><br><span class="line">   &quot;purchaseTime&quot;: 1396577500292,</span><br><span class="line">   &quot;purchaseState&quot;: 0,</span><br><span class="line">   &quot;purchaseToken&quot;: &quot;aamhleobcgnmmlgnpiepncjh.AO-J1OwabKCNS0fXo9u8ycee9wOhSGtIrI1EXLp_rGIuAjhv6CE6cPUq1sTPkgNhh_ZlXKdi2sP4DcBTyRdCViHPcypYFultoC9qUseC5C9RPwl-4CcFJKU&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>결제 내역에 대한 서명 값(Signature)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gw4rkP6nWnNZVS66r9afyqrJSVp5km9R+O3Ie2YW1rtmabOVyO0LyfZRWiYGbzc5/HmlkZ4zWNiIrNPptWogBS1ovuGLUkkh+9tnURzDWEsIYgzhd91/0RlRgj5NE8PFHZ32RCwyPy3LccsGTCM1dcKErN/7XRdGmV+8HsgF5lShKmrjOl11ZLPotlgBLbYLMphWDogLrjc3Xo5/ib2rXSLvnjjGSf+WPe0zRtMYnQ4YR7cJFnknD38ejYWserFllTfvRkjKA2qOmxYYPfuIJMKKlFGJxu2GsDJXOphJ9sKz30D2fIlanczXGSgPf1JRtWeMsdhapRh4hEwJRTntag==</span><br></pre></td></tr></table></figure>
<p>결제가 완료되면 전달받는 Message와 Signature를 통해서 앞서 말한 서명과 검증 과정을 통해서 생성한 한 쌍의 Hash 값을 비교해 안전하게 결제 내역에 대한 검증을 할 수 있게 되는 것이다. 마지막으로 Java 프로그래밍을 통해 직접 구현해 보도록 하겠다.</p>
<h2 id="Java-프로그래밍을-통해-RSA-구현해보기"><a href="#Java-프로그래밍을-통해-RSA-구현해보기" class="headerlink" title="Java 프로그래밍을 통해 RSA 구현해보기"></a>Java 프로그래밍을 통해 RSA 구현해보기</h2><p>지금까지 우리는 익숙한 HTTPS의 작동 방식과 Google Play의 인앱 결제 시에 서명과 검증 과정을 통해 RSA 알고리즘이 이론적으로 어떻게 작동되는지 살펴보았다. 지금 부터는 우리의 서비스에서 직접 활용해 볼 차례다. 본문에서는 Java 프로그래밍을 통해 구현해 보도록 하겠다.</p>
<h4 id="한-쌍의-공캐키와-비밀키-생성"><a href="#한-쌍의-공캐키와-비밀키-생성" class="headerlink" title="한 쌍의 공캐키와 비밀키 생성"></a>한 쌍의 공캐키와 비밀키 생성</h4><p>먼저 RSA는 한 쌍의 공개 키와 비밀 키를 필요로 하는데 필자는 테스트 코드를 먼저 작성해 아래와 같이 한 쌍의 키를 얻는 것을 기대해 보았다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        KeyPair keyPair = Security.generateKeyPair();</span><br><span class="line">        assertThat(keyPair.getPrivate()).isNotNull();</span><br><span class="line">        assertThat(keyPair.getPublic()).isNotNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>테스트 코드만 있을 뿐 아직은 <code>Security</code> 클래스는 존재하지 않아 아래와 같이 클래스를 만들고 <code>java.security</code> 패키지의 <code>KeyPairGenerator</code> 클래스를 이용해 한 쌍의 키를 획득하는 함수를 작성하였다. RSA 알고리즘을 사용하는 것을 볼 수 있으며 RSA 알고리즘에 필요한 키는 2048 bit의 크기가 가장 안전하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_KEY_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_FACTORY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">generateKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        KeyPairGenerator generator = KeyPairGenerator.getInstance(KEY_FACTORY_ALGORITHM);</span><br><span class="line">        generator.initialize(DEFAULT_KEY_SIZE, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">        KeyPair pair = generator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> pair;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>함수 작성을 완료하고 테스트가 정상적으로 실행된다면 생성한 공개키, 비밀키를 이용해 암호화와 복호화를 해보자.</p>
<h4 id="암호화와-복호화"><a href="#암호화와-복호화" class="headerlink" title="암호화와 복호화"></a>암호화와 복호화</h4><p>우리는 이미 한 쌍의 키를 생성하는 과정을 거쳤으며 이를 이용해 테스트 코드에서는 아래와 같이 암호화, 복호화되는 것을 기대해 보았다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptAndDecrypt</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    String plainText = <span class="string">"&#123;&#125;"</span>;</span><br><span class="line">    KeyPair keyPair = Security.generateKeyPair();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] encodedPublicKey = keyPair.getPublic().getEncoded();</span><br><span class="line">    <span class="keyword">byte</span>[] encodedPrivateKey = keyPair.getPrivate().getEncoded();</span><br><span class="line"></span><br><span class="line">    String cipherText = Security.encrypt(plainText, encodedPublicKey);</span><br><span class="line">    assertThat(plainText).isEqualTo(Security.decrypt(cipherText, encodedPrivateKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>아래의 코드를 통해 암호화는 RSA 알고리즘을 통해 생성된 공개키를 이용하며, 암호화된 메세지는 비밀키를 이용해 복호화하는 것을 알 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_KEY_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_FACTORY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String plainText, <span class="keyword">byte</span>[] encodedPublicKey)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        PublicKey publicKey = Security.generatePublicKey(encodedPublicKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(KEY_FACTORY_ALGORITHM);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = cipher.doFinal(plainText.getBytes(CHARSET));</span><br><span class="line">            <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchPaddingException | InvalidKeyException | UnsupportedEncodingException | IllegalBlockSizeException | BadPaddingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String cipherText, <span class="keyword">byte</span>[] encodedPrivateKey)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        PrivateKey privateKey = Security.generatePrivateKey(encodedPrivateKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(cipherText);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(KEY_FACTORY_ALGORITHM);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(cipher.doFinal(bytes), CHARSET);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchPaddingException | InvalidKeyException | UnsupportedEncodingException | IllegalBlockSizeException | BadPaddingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="서명과-검증하기"><a href="#서명과-검증하기" class="headerlink" title="서명과 검증하기"></a>서명과 검증하기</h4><p>서명은 Signature를 생성하는 과정이다. 아래와 같이 Hash된 원본 메세지를 비밀키를 통해 암호화하는 과정을 기대해 보았다. Signature가 정상적으로 생성되는 것으로 가정하고 원본 메세지는 동일한 함수로 Hash하고 암호화된 메세지는 공개키를 통해 복호화해 두 Hash 값을 비교하는 과정이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signAndVerify</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    String plainText = <span class="string">"&#123;&#125;"</span>;</span><br><span class="line">    KeyPair keyPair = Security.generateKeyPair();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] encodedPrivateKey = keyPair.getPrivate().getEncoded();</span><br><span class="line">    <span class="keyword">byte</span>[] encodedPublicKey = keyPair.getPublic().getEncoded();</span><br><span class="line"></span><br><span class="line">    String signature = Security.sign(plainText, encodedPrivateKey);</span><br><span class="line">    System.out.println(<span class="string">"signature = "</span> + signature);</span><br><span class="line">    assertThat(signature).isNotNull();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = Security.verify(plainText, signature, encodedPublicKey);</span><br><span class="line">    assertThat(result).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.security</code> 패키지의 <code>Signature</code> 클래스를 이용해 앞서 말한 과정을 구현할 수 있으며 생성한 Signature는 REST API에서 자주 활용될 수 있으므로 Base64로 인코딩하는 것을 추천한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(String plainText, <span class="keyword">byte</span>[] encodedPrivateKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Signature privateSignature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        privateSignature.initSign(Security.generatePrivateKey(encodedPrivateKey));</span><br><span class="line">        privateSignature.update(plainText.getBytes(CHARSET));</span><br><span class="line">        <span class="keyword">byte</span>[] signature = privateSignature.sign();</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(signature);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | InvalidKeyException | UnsupportedEncodingException | SignatureException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String plainText, String signature, <span class="keyword">byte</span>[] encodedPublicKey)</span> </span>&#123;</span><br><span class="line">    PublicKey publicKey = Security.generatePublicKey(encodedPublicKey);</span><br><span class="line">    <span class="keyword">return</span> Security.verifySignarue(plainText, signature, publicKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title">generatePrivateKey</span><span class="params">(<span class="keyword">byte</span>[] encodedPrivateKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(encodedPrivateKey));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidKeySpecException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifySignarue</span><span class="params">(String plainText, String signature, PublicKey publicKey)</span> </span>&#123;</span><br><span class="line">    Signature sig;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sig = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        sig.initVerify(publicKey);</span><br><span class="line">        sig.update(plainText.getBytes());</span><br><span class="line">        <span class="keyword">if</span> (!sig.verify(Base64.getDecoder().decode(signature)))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidSignatureException(<span class="string">"It was awesome! Signature hasn't be invalid"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | InvalidKeyException | SignatureException e) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>JDK 8</code>에서는 위와 같이 Base64 Encoding/Decoding을 위해서 표준 API를 제공하고 있으니 더 이상 <code>common-codec</code>과 같은 라이브러리는 사용할 필요가 없다.</p>
</blockquote>
<p><br></p>
<p>지금까지 대칭키와 공개키를 이용한 기본적인 암호화 기법에 대해 설명하고 Java 프로그래밍을 통해 직접 구현해 보기도 하였습니다. RSA를 이용한 암호화와 서명을 추상적으로 이해하는 것이 아니라 그 원리를 제대로 이해하고 서비스에 활용한다면 더욱 안전한 애플리케이션을 개발할 수 있을 것으로 기대합니다. 본문에 사용된 전체 소스코드는 아래의 Gist 링크에서 확인할 수 있습니다.</p>
<blockquote>
<p><a href="https://gist.github.com/stunstunstun/5ea5670b5bfd6459cbebdfbfd4674063" target="_blank" rel="external">https://gist.github.com/stunstunstun/5ea5670b5bfd6459cbebdfbfd4674063</a><br><a href="https://gist.github.com/stunstunstun/8dbc82bd86f38c9232139e0ba9a7d8ad" target="_blank" rel="external">https://gist.github.com/stunstunstun/8dbc82bd86f38c9232139e0ba9a7d8ad</a></p>
</blockquote>
<p><br></p>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" target="_blank" rel="external">https://en.wikipedia.org/wiki/Symmetric-key_algorithm</a><br><a href="https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8" target="_blank" rel="external">https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8</a><br><a href="https://www.openssl.org/" target="_blank" rel="external">https://www.openssl.org/</a><br><a href="https://ko.wikipedia.org/wiki/HTTPS" target="_blank" rel="external">https://ko.wikipedia.org/wiki/HTTPS</a></p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2017/05/15/github-page-and-custom-domain/"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="next" href="/2017/06/15/python-get-started/"><i class="fa fa-arrow-right" aria-hidden="true"></i></a></div><ins class="adsbygoogle adsense-bottom" style="display:block;" data-ad-client="ca-pub-6188640546219653" data-ad-slot="6129396565" data-ad-format="auto"></ins><div class="fb-comments-area"><div class="fb-comments" data-href="https://www.holaxprogramming.com/2017/06/12/encryption-with-rsa/" data-width="700" data-numposts="5"></div></div><div class="copyright"><p>© 2012 - 2022 <a href="https://github.com/stunstunstun" target="_blank">Minhyeok Jung</a>. Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/stunstunstun/hexo-theme-chiangmai" target="_blank">hexo-theme-chiangmai</a>.</p></div></footer></div><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({});</script><script>window.fbAsyncInit=function(){FB.init({appId:"1258629384258634",cookie:!0,xfbml:!0,version:"v2.8"}),FB.AppEvents.logPageView()},function(e,n,t){var o,c=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="//connect.facebook.net/en_US/sdk.js",c.parentNode.insertBefore(o,c))}(document,"script","facebook-jssdk");</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create','UA-97419941-1','auto');ga('send','pageview');</script></body></html>