<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>안녕 프로그래밍</title>
  
  <subtitle>모두가 프로그래밍에서 자유로워지는 그 날까지</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.holaxprogramming.com/"/>
  <updated>2022-06-07T00:26:22.999Z</updated>
  <id>https://www.holaxprogramming.com/</id>
  
  <author>
    <name>Minhyeok Jung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git Flow와 자주 사용되는 Git 명령어들</title>
    <link href="https://www.holaxprogramming.com/2018/11/01/git-commands/"/>
    <id>https://www.holaxprogramming.com/2018/11/01/git-commands/</id>
    <published>2018-11-01T06:14:40.000Z</published>
    <updated>2022-06-07T00:26:22.999Z</updated>
    
    <content type="html"><![CDATA[<p><code>Git Flow</code>는 git을 통해 효율적으로 프로젝트를 관리하고 배포하기 위한 전략이다. 기본적으로 Git은 로컬 저장소와 원격 저장소간의 동기화를 위해 아래와 같은 과정을 거친다.</p><a id="more"></a><p><img src="https://about.gitlab.com/images/git_flow/four_stages.png" height="400"></p><p>하지만 프로젝트의 규모가 커지고 협업하는 동료들이 많아진다면 저장소의 master branch만을 이용하는 것에서 이슈에 따라 다양한 branch를 통해 다양한 인원이 독립적으로 개발이 가능한 전략이 필요하다.</p><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p><img src="https://about.gitlab.com/images/git_flow/gitdashflow.png"></p><p>Git Flow는 다양한 branch를 관리하고 통합하기 위한 전략 중 하나이다. 최근에는 Git Flow의 단점을 해소하기 위해 Github Flow, Gitlab Flow 등 다양한 전략이 있지만 이 문서에서는 가장 기본이 되는 Git Flow를 설명하고 여기에 필요한 기본적인 Git 명령어에 대해 알아보도록 하겠다.</p><h2 id="브랜치-전략"><a href="#브랜치-전략" class="headerlink" title="브랜치 전략"></a>브랜치 전략</h2><p>Git Flow의 주요 브랜치는 <code>master</code>와 <code>develop</code> 이며, 이 두 브랜치를 중심으로 feature, release와 필요에 따라 hotfixes 브랜치를 정의한다.</p><p><img src="https://camo.githubusercontent.com/70f7e458a965f38831d1c50757b3a284c4280328/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f6d61696e2d6272616e636865732e706e67"></p><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>master 브랜치에 merge된 내역은 새로운 버전이 갱신되었다는 것을 의미한다. 즉 master 브랜치에 변경 내역이 생기면 최종 버전인 Tag를 통해 Production에 배포된다. </p><h4 id="develop"><a href="#develop" class="headerlink" title="develop"></a>develop</h4><p>hotfix를 제외한 모든 변경내역이 출발하는 지점이다. develop 브랜치의 코드가 안정화되고 배포할 준비가 되면 <code>master</code>를 통해 배포 버전의 태그를 단다.</p><h4 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h4><p><code>feature</code> 브랜치는 배포하려고 하는 기능을 개발하는 브랜치다. 기능을 개발하기 시작할 때는 언제 배포할 수 있을지 알 수 없다. 기능을 다 완성할 때까지 유지하고 있다가 다 완성되면 <code>develop</code> 브랜치로 병합한다. </p><ul><li>브랜치가 생성되는 대상 : develop</li><li>merge 대상: develop</li></ul><p><img src="https://camo.githubusercontent.com/c9cbf25c64dc0519860230cb98d098c3d069eda3/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f6d657267652d776974686f75742d66662e706e67"></p><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p><code>release</code> 브랜치는 실제 배포할 상태가 된 경우에 생성하는 브랜치다.</p><ul><li>브랜치가 생성되는 대상 : develop</li><li>merge 대상: develop, master</li></ul><h4 id="hotfix"><a href="#hotfix" class="headerlink" title="hotfix"></a>hotfix</h4><p>미리 계획되지 않은 브랜치다. 기본적인 동작방식은 <code>release</code>와 비슷하다. 배포 이후에 생긴 치명적인 버그는 즉시 해결해야하기 때문에 문제가 생기면 <code>master</code> 브랜치에 만들어둔 태그<code>tag</code>로 부터 긴급수정을 위한 브랜치를 생성한다.</p><ul><li>브랜치가 생성되는 대상 : master</li><li>merge 대상 : develop, master</li></ul><p><img src="https://camo.githubusercontent.com/aee561ae78af58c9756814432473c8dab15dada7/687474703a2f2f646f67666565742e6769746875622e696f2f61727469636c65732f323031312f612d7375636365737366756c2d6769742d6272616e6368696e672d6d6f64656c2f686f746669782d6272616e636865732e706e67"></p><h2 id="주요-Commands"><a href="#주요-Commands" class="headerlink" title="주요 Commands"></a>주요 Commands</h2><h4 id="소스코드의-origin-저장소를-초기화하고-remote-서버와-처음으로-연결할-때"><a href="#소스코드의-origin-저장소를-초기화하고-remote-서버와-처음으로-연결할-때" class="headerlink" title="소스코드의 origin 저장소를 초기화하고 remote 서버와 처음으로 연결할 때"></a>소스코드의 origin 저장소를 초기화하고 remote 서버와 처음으로 연결할 때</h4><p>최초의 프로젝트(origin)는 로컬 저장소에서 시작될 것이다. 운영체제에 git을 설치하고 여러분의 프로젝트를 관리할 원격 저장소가 준비되었다고 가정했을때 아래와 같이 <code>git init</code> 명령을 통해 git 프로젝트로 초기화할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"# Hola"</span> &gt; README.md</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><h4 id="git-add-commit"><a href="#git-add-commit" class="headerlink" title="git add, commit"></a>git add, commit</h4><p>git add 명령어는 git flow의 첫 단계에 해당되며 인덱스에 새로운 파일이 생겼다는 것을 알리는 행위이다. 이 상태는 저장소에는 반영이 되지 않은 상태이며 git commit 명령을 통해 비로소 저장소에 변경내역이 반영된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add build.gradle <span class="comment"># 특정 파일에 대한 변경 내역을 알린다.</span></span><br><span class="line">$ git add . <span class="comment"># 모든 변경 내역을 알린다</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"이 버전의 변경 내역에 대한 설명"</span></span><br></pre></td></tr></table></figure><p>git add, commit은 아래와 같이 동시에 실행할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">"이 버전의 변경 내역에 대한 설명"</span></span><br></pre></td></tr></table></figure><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>commit이 완료된 시점은 변경 내용이 로컬 저장소에 HEAD안에 머물고 있음을 의미한다. 우리는 변경 내역을 동료들도 확인할 수 있도록 remote 서버에 반영할 필요가 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">$ git push <span class="comment"># -u 옵션을 이용하면 다음 push때 이전 히스토리를 기억하고 반영한다.</span></span><br></pre></td></tr></table></figure><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>git add, commit, push 하는 일련의 과정은 내 컴퓨터에서 일어난 변경내역을 관리하고, remote 서버에 반영하는 행위라면 <code>git pull</code>은 remote 서버의 가장 최근의 변경 내역을 내 컴퓨터로 가져오는 행위이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><h4 id="새로운-기능을-위해-branch를-생성하는-방법"><a href="#새로운-기능을-위해-branch를-생성하는-방법" class="headerlink" title="새로운 기능을 위해 branch를 생성하는 방법"></a>새로운 기능을 위해 branch를 생성하는 방법</h4><p>git은 강력한 점은 효율적으로 분산된 환경은 제공한다는 것이다. 우리는 master branch가 아닌 더욱 안전하고 격리된 상태에서 새로운 기능을 추가할 수 있다. 새로운 branch를 이용해 개발을 진행하고 개발이 완료가 되면 나중에 master 로 돌아와 merge 하는 프로세스를 의미한다.</p><p>아래의 명령을 통해 <code>master branch</code>에서 <code>develop</code> 이라는 새로운 branch를 만들고 갈아탄다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop</span><br></pre></td></tr></table></figure><p>stage라는 특정 branch로 부터 새로운 branch를 만들고 싶다면,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b develop origin/stage</span><br></pre></td></tr></table></figure><p>아래와 같이 다시 master branch로 돌아올 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  stage</span><br><span class="line">  develop</span><br></pre></td></tr></table></figure><p>당신이 새롭게 만든 branch는 remote 서버에 전송하기 전까지는 동료들이 접근할 수가 없다. branch에 대한 검증이 완료되면 여러분은 Github에서 Pull Request를 전송할 수 있게된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin develop</span><br></pre></td></tr></table></figure><p>만약 branch를 여러명과 협업하고 있는 도중 push시에 remote 서버의 최신 내용을 로컬에 반영하지 않았다면 아래와 같이 remote 서버와 연결 후 <code>git pull</code>을 통해 merge 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/develop develop</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h4 id="원격-저장소의-기존-branch-확인-후-로컬에-가져오기"><a href="#원격-저장소의-기존-branch-확인-후-로컬에-가져오기" class="headerlink" title="원격 저장소의 기존 branch 확인 후 로컬에 가져오기"></a>원격 저장소의 기존 branch 확인 후 로컬에 가져오기</h4><p>원격 저장소의 브랜치 리스트를 조회한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">  origin/develop</span><br><span class="line">  origin/master</span><br><span class="line">  origin/stage</span><br></pre></td></tr></table></figure><p>로컬, 원격 저장소의 브랜치 리스트를 모두 조회한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">  master</span><br><span class="line">  stage</span><br><span class="line">* develop</span><br><span class="line">  remotes/origin/develop</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/stage</span><br></pre></td></tr></table></figure><p>원격 저장소의 <code>develop</code>이라는 branch를 로컬 저장소에 가져오고 싶다면</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -t origin/develop</span><br><span class="line">Branch develop <span class="built_in">set</span> up to track remote branch develop from origin.</span><br><span class="line">Switched to a new branch <span class="string">'develop'</span></span><br><span class="line">$ git branch</span><br><span class="line">* develop</span><br><span class="line">  master</span><br><span class="line">  stage</span><br></pre></td></tr></table></figure><p><code>fatal: Cannot update paths and switch to branch &#39;develop&#39; at the same time.</code>이라는 에러가 발생한다면 아래와 같이 원격 저장소를 최신 상태를 로컬 저장소에 갱신한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote update</span><br></pre></td></tr></table></figure><h4 id="원격-저장소-참고하기"><a href="#원격-저장소-참고하기" class="headerlink" title="원격 저장소 참고하기"></a>원격 저장소 참고하기</h4><p>어떤 경우에는 수정 내역을 원격 저장소에 push 하지는 않지만 해당 branch를 참고하기 위해 로컬에 받아서 테스트 해보고 싶은 경우도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>아무런 옵션없이 원격 저장소의 branch를 checkout 하면 <code>detached HEAD</code> 상태로 소스를 보고 변경 해볼 수도 있지만 변경 사항들은 commit, push 할 수 없으며 다른 branch로 checkout하면 사라진다.</p><h4 id="개발한-내역을-master-branch에-merge하는-과정"><a href="#개발한-내역을-master-branch에-merge하는-과정" class="headerlink" title="개발한 내역을 master branch에 merge하는 과정"></a>개발한 내역을 master branch에 merge하는 과정</h4><p>변경 내역을 master에 merge하는 과정은 아주 중요한 과정이다. 먼저 아래와 같이 remote 서버의 최신 내역을 자신의 로컬 저장소에 갱신하는 습관을 들이는게 좋다. <code>git pull</code>을 통해 remote 서버의 변경 내용이 로컬 저장소에 fetch, merge 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>다른 branch에 있는 변경 내용을 현재의 branch(master)에 병합하려면 아래의 명령을 실행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge some_function</span><br></pre></td></tr></table></figure><p>첫번째 명령이든 두번째 명령이든, git은 자동으로 변경 내용을 merge하려고 한다. 문제는, 항상 성공하는 게 아니라 가끔 충돌(conflicts)이 일어나기도 한다는 점이다. 필요하다면 개발이 완료되어 merge된 branch는 아래와 같이 삭제한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D some_function</span><br></pre></td></tr></table></figure><h4 id="merge-conflict가-발생한다면"><a href="#merge-conflict가-발생한다면" class="headerlink" title="merge conflict가 발생한다면?"></a>merge conflict가 발생한다면?</h4><p>개발이 완료되면 branch를 merge하는 과정에서 충분히 conflic가 발생할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> foo.java Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD <span class="comment">// conflict 가 발생한 범위의 시작</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">=======</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="number">55737474728739293729138123737392371293123737</span>e <span class="comment">// 모든 commit은 유일한 커밋 ID를 가진다</span></span><br></pre></td></tr></table></figure><p>conflict 부분을 직접 수정해서 다시 commit하는 전략을 취한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &apos;Conclude merge&apos;</span><br></pre></td></tr></table></figure><blockquote><p>merge 전에 변경 내용을 확인하는 방법</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status -sb</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff some_function master</span><br></pre></td></tr></table></figure><p>Merge 중에 발생한 충돌을 해결하는 방법은 몇 가지가 있다. 첫 번째는 그저 이 상황을 벗어나는 것이다. 예상하고 있던 일도 아니고 지금 당장 처리할 일도 아니라면 git merge –abort 명령으로 간단히 Merge 하기 전으로 되돌린다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --abort</span><br></pre></td></tr></table></figure><h4 id="로컬-변경-내용을-되돌리기"><a href="#로컬-변경-내용을-되돌리기" class="headerlink" title="로컬 변경 내용을 되돌리기"></a>로컬 변경 내용을 되돌리기</h4><p>로컬에서 발생한 변경내역을 되돌리는 일은 빈번히 발생할 수 있다. <code>git status</code> 명령을 통해 현재 branch의 상태와 이후의 상태 변경을 위한 Commands를 확인할 수 도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   Git/git-commands.md</span><br></pre></td></tr></table></figure><p>위의 상태는 소스 코드를 변경하고 <code>git add</code>를 통해 인덱스에 변경 내역을 알리기전의 상태이다. 아래와 같이 변경 내역을 되돌릴 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p><code>git add</code> 이후에 변경 내역을 되돌리고자 한다면,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><p>이미 commit된 내역을 과거로 되돌리고 싶은 경우가 있을 것이다! 먼저 commit history를 살펴보자</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">8ed5068 (HEAD -&gt; unit-test, origin/unit-test) Update README.md</span><br><span class="line">dfff29e (origin/master, master) Merge pull request <span class="comment">#8 from stunstunstun/unit-test</span></span><br><span class="line">eec3b7a Integration runner is completed</span><br><span class="line">0a087cf <span class="comment">#2 Specification list, create, get, update</span></span><br><span class="line">a603da7 Inialize unit <span class="built_in">test</span> environments</span><br><span class="line">55c3e73 (origin/stage, stage) Update README.md</span><br><span class="line">c354d50 Merge pull request <span class="comment">#7 from stunstunstun/api-test</span></span><br><span class="line">2e6b522 (origin/api-test) <span class="comment">#3 Add eslint to devDendencies</span></span><br><span class="line">5e35c21 <span class="comment">#3 Add eslint to devDendencies</span></span><br><span class="line">f9bbe2a <span class="comment">#3 version fixed</span></span><br></pre></td></tr></table></figure><p><code>a603da7</code> 이후의 모든 내역을 삭제하고 돌아가고 싶다면 <code>--hard</code> 옵션과 함께 <code>reset</code> 명령을 이용하자</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard a603da7</span><br></pre></td></tr></table></figure><p>특정 commit의 변경 내역을 취소하는 새로운 commit을 발행해야하는 경우도 있다. 이미 commit, push 한 경우 드물게 사용하는 것을 권장한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit_id&gt;</span><br></pre></td></tr></table></figure><h4 id="최종-버전-릴리즈하기"><a href="#최종-버전-릴리즈하기" class="headerlink" title="최종 버전 릴리즈하기"></a>최종 버전 릴리즈하기</h4><p>애플리케이션의 빌드 및 테스트가 완료되어 새 버전을 릴리즈한다면 읽기 전용 상태의 tag 버전를 생성하는 것이 좋다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag 1.0.0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>생성한 tag 버전은 아래와 같이 remote 서버에 최종적으로 반영한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin 0.1.0</span><br></pre></td></tr></table></figure><h4 id="gh-pages-브랜치를-통해-정적-페이지-관리하기"><a href="#gh-pages-브랜치를-통해-정적-페이지-관리하기" class="headerlink" title="gh-pages 브랜치를 통해 정적 페이지 관리하기"></a><code>gh-pages</code> 브랜치를 통해 정적 페이지 관리하기</h4><p>GitHub Repository를 운영하다 보면 비어 있는 브랜치를 생성해야할 때가 있다. REST API를 제공하는 프로젝트에서 자동으로 생성되는 API Documentation를 정적 페이지를 통해 제공하는 경우가 좋은 예이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/repo-name</span><br><span class="line">$ git symbolic-ref HEAD refs/heads/gh-pages</span><br><span class="line">$ rm .git/index</span><br><span class="line">$ git clean -fdx</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"My GitHub Page"</span> &gt; index.html</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -a -m <span class="string">"First pages commit"</span></span><br><span class="line">$ git push origin gh-pages</span><br></pre></td></tr></table></figure><p><code>git checkout -b gh-pages</code>를 통해 브랜치를 생성할 수도 있겠지만 이는 master 브랜치의 과거내역을 가지고 있음을 의미한다. 위와 같은 방법을 참고하면 <code>root branch</code>로 부터 과거 내역이 깔끔히 빈 새로운 브랜치를 생성할 수 있다.</p><p><code>gh-pages</code> 브랜치가 생성되면 아래의 경로를 통해서 정적 페이지에 접속할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;username&gt;.github.io/&lt;projectname&gt;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://gist.github.com/ramnathv/2227408" target="_blank" rel="external">https://gist.github.com/ramnathv/2227408</a></p></blockquote><h2 id="remote-branch-참조와-업데이트"><a href="#remote-branch-참조와-업데이트" class="headerlink" title="remote branch 참조와 업데이트"></a>remote branch 참조와 업데이트</h2><h4 id="remote-서버를-변경해야-할-때"><a href="#remote-서버를-변경해야-할-때" class="headerlink" title="remote 서버를 변경해야 할 때"></a>remote 서버를 변경해야 할 때</h4><p>git 저장소의 주소가 변경되는 등의 이슈로 인해 remote 서버를 변경해야 한다면 아래의 명령을 참고한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://wjdsupj@github.com/wjdsupj/awesome-wiki (fetch)</span><br><span class="line">origin  https://wjdsupj@github.com/wjdsupj/awesome-wiki (push)</span><br><span class="line">$ git remote <span class="built_in">set</span>-url origin https://stunstunstun@github.com/stunstunstun/awesome-wiki</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://stunstunstun@github.com/stunstunstun/awesome-wiki (fetch)</span><br><span class="line">origin  https://stunstunstun@github.com/stunstunstun/awesome-wiki (push)</span><br></pre></td></tr></table></figure><h4 id="remote-branch-상태-보기"><a href="#remote-branch-상태-보기" class="headerlink" title="remote branch 상태 보기"></a>remote branch 상태 보기</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure><h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p>로컬 저장소를 리모트 저장소와 동기화하고, 자동적으로 더이상 유효하지 않은 branch 참조를 제거한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin --prune</span><br></pre></td></tr></table></figure><h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote update --prune  <span class="comment"># Only prune, don't fetch</span></span><br></pre></td></tr></table></figure><h2 id="GitHub의-오픈소스에-기여하기"><a href="#GitHub의-오픈소스에-기여하기" class="headerlink" title="GitHub의 오픈소스에 기여하기"></a>GitHub의 오픈소스에 기여하기</h2><p>GitHub에는 다양한 오픈소스들이 존재하고 경우에 따라서는 직접 참여해 관심있는 오픈소스에 기여할 수도 있다. 이를 위해서는 먼저 오픈소스의 Repository를 아래의 Fork 버튼을 통해 자신의 계정에 추가해야 한다.</p><p><img src="https://help.github.com/assets/images/help/repository/fork_button.jpg"></p><h4 id="Fork한-Repository-clone-하기"><a href="#Fork한-Repository-clone-하기" class="headerlink" title="Fork한 Repository clone 하기"></a>Fork한 Repository clone 하기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/YOUR-USERNAME/jest</span><br></pre></td></tr></table></figure><h4 id="Fork를-위한-remote-설정하기"><a href="#Fork를-위한-remote-설정하기" class="headerlink" title="Fork를 위한 remote 설정하기"></a>Fork를 위한 remote 설정하기</h4><p>Fork한 Repository를 앞으로 자신의 Repository와 동기화하기 위해서는 아래와 같이 <code>upstream</code> remote를 추가한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/stunstunstun/jest (fetch)</span><br><span class="line">originhttps://github.com/stunstunstun/jest (push)</span><br><span class="line">$ git remote add upstream https://github.com/facebook/jest</span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/stunstunstun/jest (fetch)</span><br><span class="line">originhttps://github.com/stunstunstun/jest (push)</span><br><span class="line">upstreamhttps://github.com/facebook/jest (fetch)</span><br><span class="line">upstreamhttps://github.com/facebook/jest (push)</span><br></pre></td></tr></table></figure><h4 id="Fork와-동기화하기"><a href="#Fork와-동기화하기" class="headerlink" title="Fork와 동기화하기"></a>Fork와 동기화하기</h4><p>아래와 같은 명령순으로 원본 Repository에서 merge할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch upstream</span><br><span class="line">remote: Counting objects: 63, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 63 (delta 46), reused 51 (delta 45), pack-reused 6</span><br><span class="line">Unpacking objects: 100% (63/63), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/facebook/jest</span><br><span class="line"> * [new branch]        ericnakagawa-add-romanian -&gt; upstream/ericnakagawa-add-romanian</span><br><span class="line"> * [new branch]        gh-pages                  -&gt; upstream/gh-pages</span><br><span class="line"> * [new branch]        master                    -&gt; upstream/master</span><br><span class="line">$ git checkout master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">$ git merge upstream/master</span><br><span class="line">Updating 5a378915..4f685d88</span><br><span class="line">Fast-forward</span><br><span class="line"> CHANGELOG.md                                                   |   34 ++-</span><br><span class="line"> docs/GlobalAPI.md                                              |   14 +-</span><br><span class="line"> examples/react-native/package.json                             |    2 +-</span><br><span class="line"> integration_tests/__tests__/__snapshots__/globals.test.js.snap |   17 ++</span><br><span class="line"> integration_tests/__tests__/globals.test.js                    |   18 ++</span><br><span class="line"> integration_tests/__tests__/jasmine_async.test.js              |    6 +</span><br><span class="line"> integration_tests/jasmine_async/__tests__/generator.test.js    |   25 ++</span><br><span class="line"> package.json                                                   |   10 +-</span><br><span class="line"> packages/jest-jasmine2/package.json                            |    2 +</span><br><span class="line"> packages/jest-jasmine2/src/jasmine/Suite.js                    |   29 +-</span><br><span class="line"> packages/jest-jasmine2/src/jasmine_async.js                    |    9 +-</span><br><span class="line"> scripts/browserBuild.js                                        |    4 +-</span><br><span class="line"> types/Circus.js                                                |    2 +-</span><br><span class="line"> yarn.lock                                                      | 1126 ++++++++++++++++++++++++++++++++++++++++++++++++++---------------------</span><br><span class="line"> 14 files changed, 954 insertions(+), 344 deletions(-)</span><br><span class="line"> create mode 100644 integration_tests/jasmine_async/__tests__/generator.test.js</span><br></pre></td></tr></table></figure><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>이 명령을 통해서는 로컬에서 참고하는 다양한 옵션을 설정한다. 예를 들면 Git Repository에서 참조하는 계정을 아래와 같이 설정할 수 있다.</p><p><code>global</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;stunstunstun&quot;</span><br><span class="line">$ git config --global user.email &quot;wjdsupj@gmail.com&quot;</span><br></pre></td></tr></table></figure><p><code>local</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --local user.name &quot;stunstunstun&quot;</span><br><span class="line">$ git config --local user.email &quot;wjdsupj@gmail.com&quot;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://git-scm.com/docs/git-config" target="_blank" rel="external">https://git-scm.com/docs/git-config</a></p></blockquote><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 Git Flow를 통해 기본적인 명령들을 살펴보았다. Git에 대해 더 알고 싶다면 아래의 자료를 참고하면 많은 도움이 될 것이다!</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://git-scm.com/docs/" target="_blank" rel="external">Git Docs</a></li><li><a href="https://github.com/k88hudson/git-flight-rules" target="_blank" rel="external">Git Flight Rules</a></li><li><a href="https://www.youtube.com/watch?v=MJUJ4wbFm_A" target="_blank" rel="external">An Introduction Git and GitHub</a></li><li><a href="https://try.github.io" target="_blank" rel="external">Git Basic Tutorials</a></li><li><a href="http://guides.github.com" target="_blank" rel="external">Git Guides</a></li><li><a href="https://github.com/mingrammer/git-tips" target="_blank" rel="external">Git Tips</a></li><li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="external">Pro Git Book 2nd</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Git Flow&lt;/code&gt;는 git을 통해 효율적으로 프로젝트를 관리하고 배포하기 위한 전략이다. 기본적으로 Git은 로컬 저장소와 원격 저장소간의 동기화를 위해 아래와 같은 과정을 거친다.&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://www.holaxprogramming.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>React 최적화 - 가상 DOM에 대하여</title>
    <link href="https://www.holaxprogramming.com/2018/04/15/react-optimizing-virtual-dom-explained/"/>
    <id>https://www.holaxprogramming.com/2018/04/15/react-optimizing-virtual-dom-explained/</id>
    <published>2018-04-15T04:42:00.000Z</published>
    <updated>2022-06-07T00:26:23.019Z</updated>
    
    <content type="html"><![CDATA[<ul><li>원문: <a href="https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained" target="_blank" rel="external">https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained</a></li></ul><p>이 글을 통해 React 가상 DOM에 대해 알아본 후 배운 것을 활용해 여러분 앱 속도를 높여보세요. React 프레임워크 내부를 철저하게 초보 친화적인 시각에서 소개하는 이 글을 통해 JSX를 명확하게 정의내려 보고, React가 어떻게 렌더링을 결정내리는지 살펴보며, 병목지점을 찾아내는 방법에 대해 설명드리고 흔히 발생하는 실수를 피할 수 있는 몇가지 팁을 공유해 보도록 하겠습니다.</p><p>React가 지속적으로 프론트엔드 세상을 쥐락펴락하면서 인기가 사그라들 기미가 보이지 않는 이유 중 하나는 바로 러닝 커브가 그닥 높지 않다는데 있습니다. <a href="https://reactjs.org/docs/introducing-jsx.html" target="_blank" rel="external">JSX</a>와 바로 그 “<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="external">State</a> vs. <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="external">Props</a>“ 개념으로 여러분 머리를 채우셨다면, 이제 React를 사용하셔도 됩니다.</p><p>그러나 진정으로 React에 정통하려면 <em>React적으로 사고할</em> 필요가 있습니다. 이 글은 여러분이 그렇게 할 수 있도록 도와주고자 쓴 글입니다. <a href="https://ebaymag.com/" target="_blank" rel="external">저희 프로젝트</a>에서 사용할 요량으로 만든 React 테이블을 잠시 봐주세요.</p><p>(React가 어떻게 동작하는지 이미 잘 알고 계시다면 “<a href="https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained#fixing-things-mountingunmounting" target="_blank" rel="external">고치기</a>“ 부분으로 바로 넘어가셔도 됩니다.)</p><p><img src="https://cdn.evilmartians.com/front/posts/optimizing-react-virtual-dom-explained/ebay_table-4023632.png" alt=""></p><p>시시각각 변하면서 필터링 기능이 탑재된 수백줄의 테이블 행이 들어있으므로, 사용자에게 부드러운 경험을 선사하고 싶다면 프레임워크의 내부 구조를 이해하는 것이 매우 중요했습니다.</p><p>그리고 뭔가 일이 잘못되어가고 있다는 것도 자연스레 느끼게 될 수밖에 없습니다. 입력 필드 반응이 느려지고, 체크박스를 눌렀는데 몇 초 후에 체크표시가 나타나면서 모달 창은 나오기까지 매우 힘든 시간을 보내고 있네요.</p><p>이런 종류의 문제를 해결하기 위해서는 여러분에 의해 React 컴포넌트가 정의되고 페이지 상에 렌더링(그리고 업데이트) 되기까지의 그 모든 여정에 대해 먼저 알아봐야 합니다. 안전벨트 매세요!</p><h2 id="JSX의-배후"><a href="#JSX의-배후" class="headerlink" title="JSX의 배후"></a>JSX의 배후</h2><p>컴포넌트를 만들려고 하면 React 개발자들이 여러분에게 HTML과 JavaScript가 뒤섞인 JSX로 코드를 작성하라고 다그칠 겁니다. 그러나 저러나 브라우저는 JSX 문법이 뭔지도 모릅니다. 브라우저는 오직 일반 JavaScript만 이해하기 때문에 JSX는 이에 맞게 형태를 바꿀 필요가 있습니다. (“컴파일레이션(compilation)”이 조금 더 적합한 용어 같기는 한데, 아무튼 프론트엔드 업계에서는 “트랜스파일링”이라는 과정으로 알려져 있습니다.) 다음은 예시 JSX 코드 안의 <code>div</code>는 클래스명도 있고 안에 컨텐츠도 들어갑니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'cn'</span>&gt;</span></span><br><span class="line">  Content!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위와 동일한 내용의 코드를 “정석” Javascript로 작성해보면 그저 인자 몇가지를 받는 함수 호출이 되어버립니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>인자를 조금 더 자세하게 들여다보도록 합시다. 첫번째 인자는 <em>요소의 타입</em>입니다. HTML 태그가 오게 된다면 태그명이 문자열로 들어갑니다. 두번째 인자는 <em>요소의 모든 어트리뷰트</em>가 담긴 객체입니다. 만약 어트리뷰트를 넣을 필요가 없다면 빈 객체가 들어가게 됩니다. 그 다음에 오는 인자는 모두 <em>요소의 자식</em>입니다. 요소 안에 들어가는 텍스트 역시 자식으로 칩니다. 그래서 ‘Content!’ 문자열이 함수 호출될 때 세번째 인자 자리에 들어가는 겁니다.</p><p>자식이 더 있다면 어떤 모양이 될지 벌써 상상가능하네요.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'cn'</span>&gt;</span></span><br><span class="line">  Content 1!</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  Content 2!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content 1!'</span>,              <span class="comment">// 첫째</span></span><br><span class="line">  React.createElement(<span class="string">'br'</span>), <span class="comment">// 둘째</span></span><br><span class="line">  <span class="string">'Content 2!'</span>               <span class="comment">// 셋째</span></span><br></pre></td></tr></table></figure><p>함수 호출 인자로 총 다섯개가 들어가네요. 요소의 타입, 어트리뷰트 객체, 그리고 자식 세명입니다. 자식 중 하나 역시 React와 연관된 HTML 태그이기 때문에 이 역시 함수 호출이라 여겨지게 됩니다.</p><p>여태까지 두가지 타입의 자식을 다뤄보았습니다. 하나는 일반 <code>String</code> 자식이고, 다른 하나는 <code>React.createElement</code> 재호출하는 자식입니다. 하지만 이 두가지 말고도 다른 값의 인자가 올 수도 있습니다.</p><ul><li>원시값 <code>false</code>, <code>null</code>, <code>undefined</code>, `true</li><li>배열</li><li>React 컴포넌트</li></ul><p>배열도 들어갈 수 있는데, 이는 자식들을 그룹으로 묶어서 하나의 인자로 전달하기 위함입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  [<span class="string">'Content 1!'</span>, React.createElement(<span class="string">'br'</span>), <span class="string">'Content 2!'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>그러나 React의 진정한 힘은 HTML 명세에 기재되어 있는 태그로부터 나오는 것이 아니라, 당연히 사용자가 직접 만들어낸 컴포넌트에서 나옵니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Table(&#123; rows &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">      &#123;rows.map(row =&gt; (</span><br><span class="line">        &lt;tr key=&#123;row.id&#125;&gt;</span><br><span class="line">          &lt;td&gt;&#123;row.title&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>컴포넌트 덕분에 템플릿을 재사용 가능한 덩어리로 더 분해시킬 수 있습니다. 위의 “함수형” 컴포넌트 예시에서는 테이블 행 데이터가 담긴 객체로 이루어진 배열을 받은 후, <code>React.createElement</code> 함수 호출 하나를 반환합니다. 이 함수 호출을 통해 행을 자식으로 가지는 <code>&lt;table&gt;</code> 요소를 만들어 냅니다.</p><p>이제 페이지 레이아웃에 다음과 같은 컴포넌트를 놓아둘 때마다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Table rows=&#123;rows&#125; /&gt;</span><br></pre></td></tr></table></figure><p>브라우저가 보기에는 우리는 다음과 같은 코드를 쓴겁니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(Table, &#123; rows: rows &#125;);</span><br></pre></td></tr></table></figure><p>이번에는 첫번째 인자가 HTML 요소를 나타내는 <code>String</code>이 아니라 아까 컴포넌트를 만들 때 <em>정의 내린 함수에 대한 참조</em>임에 유의해 주세요. 컴포넌트 어트리뷰트는 이제 우리의 <code>props</code>가 되었습니다.</p><h2 id="페이지에-컴포넌트-넣기"><a href="#페이지에-컴포넌트-넣기" class="headerlink" title="페이지에 컴포넌트 넣기"></a>페이지에 컴포넌트 넣기</h2><p>자, 이제 순수 자바스크립트로 JSX 컴포넌트를 모두 트랜스파일 해보니 인자가 담긴 함수 호출 한다발이 우리 앞에 떨어졌네요. 이 함수 호출 중 하나는 이제 다른 함수를 또 호출하고, 그 와중에 옆에는 대기 중인 함수 호출들이 있고… 이 모든 함수 호출을 어떻게 웹 페이지를 이루는 DOM 요소로 바꿀 수 있는 걸까요?</p><p>그 목표를 이루기 위해 우리에게는 <code>ReactDOM</code> 라이브러리와 여기에 같이 딸려 오는 <code>render</code> 메소드가 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Table(&#123; rows &#125;) &#123; /* ... */ &#125; // 컴포넌트 정의</span><br><span class="line"></span><br><span class="line">// 컴포넌트 렌더링</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Table, &#123; rows: rows &#125;), // &quot;creating&quot; a component</span><br><span class="line">  document.getElementById(&apos;#root&apos;) // inserting it on a page</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>ReactDOM.render</code>가 호출되면 <code>Rect.createElement</code> 역시 최종적으로 호출이 되고 그 결과 다음과 같은 객체를 반환합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 필드가 더 많기는 한데, 아래가 우리에게 가장 중요한 것들입니다</span><br><span class="line">&#123;</span><br><span class="line">  type: Table,</span><br><span class="line">  props: &#123;</span><br><span class="line">    rows: rows</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>여기서 반환된 객체가 React 세계의 가상 DOM을 구성하는 것들입니다.</strong></p><p>앞으로 렌더링이 일어나게 될 때마다 가상 DOM은 비교를 거쳐 (<em>가상</em>과 대비되는) <em>실제</em> DOM으로 마침내 변환이 됩니다.</p><p>다른 예시를 들어보겠습니다. 이번에는 클래스 어트리뷰트와 자식을 몇명 데리고 있는 <code>div</code> 요소입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125;,</span><br><span class="line">  <span class="string">'Content 1!'</span>,</span><br><span class="line">  <span class="string">'Content 2!'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이는 다음과 같이 변환됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &apos;div&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &apos;cn&apos;,</span><br><span class="line">    children: [</span><br><span class="line">      &apos;Content 1!&apos;,</span><br><span class="line">      &apos;Content 2!&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.createElement</code> 함수에서는 서로 떨어져있던 인자들이 <code>props</code> 안의 <code>children</code> 키 안에 같이 자리를 잡게 된 것에 유의하세요. 그러니까 요소의 자식이 배열 형식으로 들어갔던, 인자를 나열하는 형식으로 들어갔던 <em>상관이 없는</em> 거네요. 어찌되었든 결과로 나온 가상 DOM 객체에는 다같이 묶여 들어가게 되니까요.</p><p>더 신기한 것은 JSX 코드에 직접 props로 자식을 추가할수도 있다는 겁니다. 그래도 결과는 여전히 똑같습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">'cn'</span> <span class="attr">children</span>=<span class="string">&#123;[</span>'<span class="attr">Content</span> <span class="attr">1</span>!', '<span class="attr">Content</span> <span class="attr">2</span>!']&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p>가상 DOM 객체가 만들어지면 <code>ReactDOM.render</code> 메소드가 이 객체를 DOM 노드로 변환하게 됩니다. 브라우저는 DOM 노드를 다음과 같은 규칙을 따라 화면에 표시합니다.</p><ul><li>만약 <code>type</code> 어트리뷰트가 태그명을 <em>문자열</em>로 가지고 있다면, 태그를 만든 후 <code>props</code> 안에 모든 어트리뷰트를 넣습니다.</li><li>만약 <code>type</code> 안에 함수나 클래스가 들어가 있다면, 호출 후에 결과에 따라 재귀적으로 이 과정을 반복합니다.</li><li>만약 <code>props</code> 안에 <code>children</code>이 하나라도 있다면, 이 과정을 각 자식마다 개별적으로 진행하고 그 결과를 부모 DOM 노드 안에 넣습니다.</li></ul><p>그 결과로 다음과 같은 HTML을 얻게 됩니다. (예시로 든 테이블의 경우입니다.)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DOM-재건하기"><a href="#DOM-재건하기" class="headerlink" title="DOM 재건하기"></a>DOM 재건하기</h2><p>제목의 “재” 글자에 주의하세요! React가 진정한 마법을 부리는 시점은 아무것도 바꾸지 않으면서 페이지를 <em>업데이트</em>하고 싶을 때입니다. 이를 위한 방법이 몇가지 있습니다. 가장 간단한 방법부터 살펴보죠. 동일한 노드에 다시 한번 <code>ReactDOM.render</code>를 호출하는 겁니다. (실제로는 <code>render</code>는 거의 루트 요소에서만 한번 호출이 되고 그 이후에 업데이트가 발생하면 <code>state</code>에 적용이 됩니다.)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 두번째 호출</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Table, &#123; <span class="attr">rows</span>: rows &#125;),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'#root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>두번째 호출때는 우리가 이미 본 첫번째와 다르게 동작합니다. 밑바닥에서부터 DOM 노드를 모두 만들어서 페이지에 올려놓기 보다는, React의 <a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="external">reconciliation</a>(또는 “diffing”) 알고리즘에 의해 노드 트리의 어느 부분이 갱신되어야 하는지, 그리고 어떤 부분은 손대지 말아야 하는지 결정이 내려집니다.</p><p>자, 그럼 이 알고리즘은 어떻게 돌아가는 걸까요? 간단한 시나리오가 몇가지 있는데  <em>이를 이해하고 넘어가면</em> 최적화에 매우 많은 도움이 될듯 합니다. 이제부터는 React 가상 DOM에서 노드를 표현하는 역할을 하는 객체를 살펴볼 겁니다.</p><ul><li>시나리오 1: <code>type</code>이 문자열이고, <code>type</code>은 모든 호출에서 동일하게 유지. <code>props</code> 역시 변경없음.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 업데이트 전</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 업데이트 후</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p>가장 간단한 경우네요. DOM은 동일하게 유지됩니다.</p><ul><li>시나리오 2: <code>type</code>은 여전히 문자열이나 <code>props</code>가 달라짐.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 업데이트 전:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cn'</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 업데이트 후:</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'div'</span>, <span class="attr">props</span>: &#123; <span class="attr">className</span>: <span class="string">'cnn'</span> &#125; &#125;</span><br></pre></td></tr></table></figure><p><code>type</code>이 여전히 HTML <em>요소</em>를 가르키고 있으므로, React는 DOM 트리에서 노드 제거 없이 표준 DOM API 호출을 통해 프로퍼티를 바꾸는 방법을 알고 있습니다.</p><ul><li>시나리오 3: <code>type</code>이 다른 <code>String</code>으로 바뀜, 혹은 <code>String</code>에서 컴포넌트로 변경됨.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 업데이트 전:</span><br><span class="line">&#123; type: &apos;div&apos;, props: &#123; className: &apos;cn&apos; &#125; &#125;</span><br><span class="line"></span><br><span class="line">// 업데이트 후:</span><br><span class="line">&#123; type: &apos;span&apos;, props: &#123; className: &apos;cn&apos; &#125; &#125;</span><br></pre></td></tr></table></figure><p>이제 요소 타입이 달라졌다는 것을 React가 알게 되었기 때문에, 노드를 업데이트 하려는 시도조차 하지 않을 겁니다. 예전 요소는 <strong>모든 자식과 함께</strong> 제거(<em>unmounted</em>)가 됩니다. 그렇기 때문에 완전히 다른 요소로 DOM 트리 저 높은 곳의 노드를 갈아 끼우는 일은 치루는 데 비용이 꽤 들어갈 수 있습니다. 다행이게도 실제 업무 중엔 아주 드물게 일어나는 케이스에 속합니다.</p><ul><li>시나리오 4: <code>type</code>이 컴포넌트일 때.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 업데이트 전:</span><br><span class="line">&#123; type: Table, props: &#123; rows: rows &#125; &#125;</span><br><span class="line"></span><br><span class="line">// 업데이트 후:</span><br><span class="line">&#123; type: Table, props: &#123; rows: rows &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>“그런데 바뀐게 없잖아요!”라고 말하실 것 같은데, 틀린 말입니다.</strong></p><p>만약 <code>type</code>에 함수나 클래스의 참조(즉, 여러분이 만든 일반 React 컴포넌트)가 들어가있고, 트리 reconciliation 과정이 시작되었다면, React는 언제나 컴포넌트 <em>내부</em>를 조사해서 <code>render</code>로 반환된 값이 바뀌지 않았나 (일종의 부수 효과 예방 차원에서) 확인하려 들겁니다. 확인이 끝나면 흘려보내고 트리 구조상 하위에 위치한 컴포넌트도 모두 확인합니다. 네, 이 과정에는 복잡한 렌더링도 포함되어 있는데 이 렌더링 자체도 비용이 많이 들어갈 가능성이 있습니다. (컴포넌트의 <code>render</code> 메소드(클래스 컴포넌트에서만 이 메소드가 직접적으로 정의됩니다)는 <code>ReactDOM.render</code> 메소드와 같은 것이 아님을 알아두세요. React 세계에서 “render”라는 단어는 사실 조금 과도하게 사용되고 있습니다.)</p><h2 id="자식-돌보기"><a href="#자식-돌보기" class="headerlink" title="자식 돌보기"></a>자식 돌보기</h2><p>위에서 설명한 네가지 시나리오 말고도, 요소의 자식이 하나 이상일 때 React의 행동은 어떤지도 알아봐야 합니다. 다음과 같은 요소가 있다고 해봅시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">      &#123; type: &apos;div&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;span&apos; &#125;,</span><br><span class="line">      &#123; type: &apos;br&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>그리고 요소에 딸린 자식들을 다음과 같이 섞어보도록 하겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; type: &apos;span&apos; &#125;,</span><br><span class="line">    &#123; type: &apos;div&apos; &#125;,</span><br><span class="line">    &#123; type: &apos;br&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>이제 무슨 일이 일어나게 될까요?</p><p>“diff 비교” 과정이 진행되고 있는 와중에 React가<code>props.children</code>에 배열이 <em>하나라도</em> 들어있는 것을 보게 된다면, 그때부터 React는 배열 안에 들어있는 요소를 전에 본 것과 비교하기 시작합니다. 배열 요소는 순서대로 비교하는데, 인덱스 0에 위치한 요소끼리, 그리고 1에 위치한 것끼리 비교하는 식입니다. 비교되는 각 쌍마다 React에서는 위에서 설명한 규칙을 적용해 봅니다. 우리의 경우 <code>div</code>가 <code>span</code>이 된 것 같으므로 <em>3번 시나리오</em>가 적용이 되겠네요. 아주 효율적이지 못한 케이스입니다. 테이블 행이 1000개 있는데 여기서 첫번째 행을 제거한다고 생각해 보세요. React가 나머지 999개의 자식을 “업데이트”해야 하는 상황이 옵니다. 인덱스가 같은 요소끼리 비교하게 된다면 같은 내용을 가지는 요소가 하나도 없을 것이기 때문입니다.</p><p>다행이게도 이런 문제를 해결하기 위한 해결책이 React 안에 내장되어 있습니다. 만약 요소가 <code>key</code> 프로퍼티를 가지고 있으면 인덱스가 아니라 <code>key</code> 프로퍼티가 같은 것들끼리 비교가 진행됩니다. <code>key</code> 값이 유일한 이상 React는 이 요소들을 DOM 트리에서 제거 후에 다시 올려 놓는 과정 <em>없이</em> 그냥 옮기기만 합니다. (React에서 <em>마운팅/언마운팅</em>이라고 불리는 과정입니다.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [ // 이제 React에서는 key값을 참조하지, 인덱스를 보지는 않습니다</span><br><span class="line">    &#123; type: &apos;div&apos;, key: &apos;div&apos; &#125;,</span><br><span class="line">    &#123; type: &apos;span&apos;, key: &apos;span&apos; &#125;,</span><br><span class="line">    &#123; type: &apos;br&apos;, key: &apos;bt&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h2 id="상태가-바뀐다면"><a href="#상태가-바뀐다면" class="headerlink" title="상태가 바뀐다면"></a>상태가 바뀐다면</h2><p>여태까지는 React 철학 중 살펴본 부분은 <code>props</code> 뿐이고 <code>state</code>는 무시했습니다. 아래는 “상태를 가지는” 컴포넌트의 간단 예시입니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.state.counter + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  render = <span class="function"><span class="params">()</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;'Counter: ' + this.state.counter&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자, 이제 상태 객체 안에 <code>counter</code> 키가 들어가게 되었습니다. 버튼을 클릭하면 값이 증가하고 버튼 안의 글자가 바뀌게 됩니다. 그런데 이때 DOM에는 무슨 일이 일어나는 걸까요? DOM 중에 어떤 곳이 재계산이 된 후에 업데이트 되는 걸까요?</p><p><code>this.setState</code>를 호출하면 렌더링이 다시 진행됩니다. 그러나 페이지 전체는 아니고 <em>컴포넌트 자기 자신과 자식들</em>만 다시 렌더링됩니다. 그 컴포넌트의 부모와 자손뻘 컴포넌트에는 아무런 영향이 없습니다. 트리 규모가 크고 부분적으로만 다시 렌더링하고 싶을 때 유용하게 작용합니다.</p><h2 id="문제를-정확히-밝히기"><a href="#문제를-정확히-밝히기" class="headerlink" title="문제를 정확히 밝히기"></a>문제를 정확히 밝히기</h2><p>문제를 고치기 전에, 현실에서 일어날 수 있는 가장 흔한 실수를 직접 겪어보실 수 있게 저희가 <a href="https://iadramelk.github.io/optimizing-react-demo/dist/before.html" target="_blank" rel="external">작은 데모 앱</a> 하나를 준비해봤습니다. <a href="https://github.com/facebook/react-devtools" target="_blank" rel="external">React 개발자도구</a>도 필요하므로 브라우저에 설치했나 확인해 보세요.</p><p>가장 먼저 살펴볼 것은 바로 가상 DOM 업데이트를 발생시키는 <em>요소가 무엇인지, 또 언제인지</em>입니다. 브라우저 개발자 도구의 React 패널을 열어서 “Highlight Updates” 체크박스를 선택해 주세요.</p><p><img src="https://cdn.evilmartians.com/front/posts/optimizing-react-virtual-dom-explained/react_dev_tools-e78197e.png" alt=""></p><p>자 이제 테이블에 행을 추가해보세요. 보시다시피 페이지의 각 요소에 보더가 나타납니다. 우리가 행을 추가할 때마다 React에서 가상 DOM 트리 전체를 다시 계산해서 비교하기 때문에 보더가 나타나는 것입니다. 이제 행 안의 카운터 버튼을 눌러보세요. <code>state</code>가 변할 때 가상 DOM 업데이트가 어떻게 일어나는지 확인할 수 있습니다. 바뀐 <code>state</code>와 연관된 요소 및 그 요소의 자식들만 영향을 받습니다.</p><p>React 개발자도구는 문제가 어디서 발생하는 것인지 힌트는 제공해 줄 수 있지만 세부적인 사항에 대해서는 아무것도 알려주지 않습니다. 특히나 문제가 되는 업데이트가 “diff 비교”인지, 아니면 마운팅/언마운팅인지 알고 싶어도 별 도움이 안됩니다. 더 자세히 알아보기 위해서는 React에 내장된 <a href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab" target="_blank" rel="external">프로파일러</a>를 사용해야 합니다. (참고로 프로파일러는 프로덕션 모드에서는 작동하지 않습니다.)</p><p>여러분 앱의 URL 끝에 <code>?react_perf</code>를 추가하고 Chrome 개발자도구의 “성능” 패널로 가보세요. 레코딩 버튼을 클릭한 후에 앱 안의 버튼을 눌러 테이블에 변경사항을 줘보세요. 행도 좀 추가해보고, 카운터에도 변경사항을 줘본 후에 “멈춤” 버튼을 누르세요.</p><p><img src="https://cdn.evilmartians.com/front/posts/optimizing-react-virtual-dom-explained/react_perf_tools-ba86f5e.png" alt=""></p><p>결과 화면 중에 관심가질 것은 “User timing” 부분입니다. “React Tree Reconciliation” 그룹과 하위 자식들이 나타날 때까지 타임라인을 확대해 주세요. 이 그룹에 속하는 컴포넌트는 이름 옆에 <em>[update]</em> 혹은 <em>[mount]</em>가 붙어 있습니다.</p><p><strong>대부분의 성능 문제는 이 두가지 중 하나에 속합니다.</strong></p><p>컴포넌트(+ 여기서 파생되는 모든 것들)가 모종의 이유 때문에 업데이트마다 재마운팅이 되는 데 이런 일이 일어나지 않도록 하고 싶은 경우(재마운팅은 속도가 느립니다), 혹은 아무것도 변한 것이 없음에도 볼구하고 큰 브랜치에 비용이 많이 드는 reconciliation을 발생시키고 있는 경우, 이 둘중 하나입니다.</p><h2 id="문제-해결하기-마운팅-언마운팅"><a href="#문제-해결하기-마운팅-언마운팅" class="headerlink" title="문제 해결하기: 마운팅/언마운팅"></a>문제 해결하기: 마운팅/언마운팅</h2><p>React가 가상 DOM을 업데이트 결정 방법에 관한 몇가지 이론도 살펴보았고, 화면 뒤에 벌어지는 일을 감시하는 방법도 알아보았으니, 마침내 문제를 해결할 준비가 다 되었습니다! 제일 먼저, 마운트/언마운트 부터 다뤄보도록 하겠습니다.</p><p>모든 요소/컴포넌트에 자식이 여러개 있다면 내부적으로 이들은 <em>배열</em>로 표현된다는 사실에만 신경을 쓰면 상당히 괄목할 만한 속도 향상을 이뤄낼 수 있습니다.</p><p>다음과 같은 코드가 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Message</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Table</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그리고 가상 DOM안에는 다음과 같이 표현되겠죠.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">type</span>: Message &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Table &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>텍스트가 들어있는 <code>div</code>로 되어있는 간단한 <code>Message</code>가 있고 (흔해 빠진 알림이라 생각하세요) 1000줄 이상의 행이 담겨 있는 거대한 <code>Table</code>이 있습니다. 두 컴포넌트 모두 <code>div</code> 안에 담겨있으므로 부모 노드의 <code>props.children</code> 하위에 위치합니다. 그리고 키값을 일부러 가질 필요는 없는 것들입니다. 심지어 이 경우에는 React도 콘솔을 통해 키값 부여를 하라고 경고해주지 않을 겁니다. 자식이 부모의 <code>React.createElement</code>에 배열이 아닌 인자로 나열되어 들어가기 때문입니다.</p><p>이제 우리의 사용자가 알림을 무시하셔서 <code>Message</code>가 트리에서 제거되었다 해봅시다. 이제 남은 것이라고는 <code>Table</code>과 <code>Footer</code>가 다입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    &#123; type: Table &#125;,</span><br><span class="line">    &#123; type: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>React는 이를 어떻게 해석할까요? 자식 배열의 모양이 달라졌다고 생각할 겁니다. ‘<code>children[0]</code>에는 <code>Message</code>가 들어있었는데, 이제는 <code>Table</code>이 들어있네.’ 서로 비교할 키값이 없으므로 <code>type</code>을 비교하기 시작합니다. 그리고 비교하는 대상이 모두 함수 참조이므로 (그리고 <em>다른</em> 함수를 참조하고 있으므로), <code>Table</code> 컴포넌트 전체를 <em>언마운트</em>한 후에 다시 마운트시킵니다. 따라서 1000줄이 넘는 행으로 된 자식이 모두 렌더링됩니다.</p><p>그래서 이 상황을 개선하려면 유일한 키값을 추가(그러나 여기서는 키값 사용이 최상의 선택이 되지 못합니다)하거나 좀 더 똑똑한 트릭을 사용하거나 둘 중 하나를 택해야 합니다. 자바스크립트를 비롯해 최신 프로그래밍 언어에 많이 들어있는 기능인 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators" target="_blank" rel="external">Short circuit boolean evaluation</a>을 사용하는 겁니다. 자 보세요.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// boolean 트릭을 사용합니다</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;isShown &amp;&amp; &lt;Message /&gt;&#125;</span><br><span class="line">  &lt;Table /&gt;</span><br><span class="line">  &lt;Footer /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>Message</code>가 화면에 보이지 않더라도 부모 <code>div</code>의 <code>props.children</code>에는 여전히 요소가 <em>세 개</em> 들어있게 됩니다. <code>children[0]</code>에는 <code>false</code>(불리언 원시값)값이 들어가게 되는 것이죠. <code>true/false</code>, <code>null</code>, <code>undefined</code> 이 세개 모두 가상 DOM 객체의 <code>type</code> 프로퍼티로 사용할 수 있다는 사실을 기억하고 계시나요? 그러므로 다음과 같은 객체가 나오게 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    false, //  isShown &amp;&amp; &lt;Message /&gt; 결과값이 false로 평가됩니다</span><br><span class="line">    &#123; type: Table &#125;,</span><br><span class="line">    &#123; type: Footer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>그러므로 <code>Message</code>가 있던 없던간에 인덱스는 변하지 않을 것이고 <code>Table</code> 역시 이전 <code>Table</code>하고만 비교가 이루어지게 됩니다. (<code>type</code>에 참조가 들어간 컴포넌트는 reconciliation이 어찌되었든 일어납니다.) <em>하지만 가상 DOM만 비교해도 된다면 DOM 노드를 제거하고 처음부터 다시 만드는 것보다 일이 훨씬 빠르게 진행이 됩니다.</em></p><p>이제 좀 더 진화가 이루어진 것을 봐봅시다. 여러분이 <a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="external">HOC</a>를 좋아하신다는 것 쯤은 알고 있습니다. 고계도 컴포넌트는 컴포넌트를 인자로 받아서 이걸 가지고 뭔가 한 후에 다른 함수를 돌려주는 일을 하는 함수를 말합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function withName(SomeComponent) &#123;</span><br><span class="line">  // 이름을 계산합니다. 비용이 꽤 들어가는 일 같은데요...</span><br><span class="line">  return function(props) &#123;</span><br><span class="line">    return &lt;SomeComponent &#123;...props&#125; name=&#123;name&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>매우 흔한 패턴입니다. 그러나 조심해서 사용해야 합니다. 다음과 같은 상황이 있다 해봅시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class App extends React.Component() &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // 렌더할 때마다 새로운 인스턴스를 생성합니다.</span><br><span class="line">    const ComponentWithName = withName(SomeComponent);</span><br><span class="line">    return &lt;SomeComponentWithName /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>부모의 <code>render</code> 메소드에서 HOC를 생성하는 코드입니다. 트리를 다시 렌더링하게 되면 가상 DOM은 다음과 같을 겁니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 첫번째 렌더:</span><br><span class="line">&#123;</span><br><span class="line">  type: ComponentWithName,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 두번째 렌더:</span><br><span class="line">&#123;</span><br><span class="line">  type: ComponentWithName, // 이름은 같지만 인스턴스가 다릅니다</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 React는 <code>ComponentWithName</code>에 대해서만 diffing 알고리즘을 사용하고 싶어할 것 같은데, 이 경우 참조의 이름만 같으나 <em>인스턴스가 다르기 때문에</em>, 엄격한 비교를 할 경우 실패가 뜨게 되고 reconciliation 대신에 전체 재-마운팅이 일어나게 됩니다. <a href="https://github.com/facebook/react/blob/044015760883d03f060301a15beef17909abbf71/docs/docs/higher-order-components.md#dont-use-hocs-inside-the-render-method" target="_blank" rel="external">이 곳에 명시된 대로</a> 상태 역시 잃어버리게 됩니다. 다행이도 해결이 쉽습니다. 항상 <code>render</code> 밖에서 HOC를 만들면 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 새 인스턴스를 딱 한번만 만듭니다.</span><br><span class="line">const ComponentWithName = withName(Component);</span><br><span class="line"></span><br><span class="line">class App extends React.Component() &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;ComponentWithName /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="문제-해결하기-업데이트"><a href="#문제-해결하기-업데이트" class="headerlink" title="문제 해결하기: 업데이트"></a>문제 해결하기: 업데이트</h2><p>자, 이제 꼭 필요한 경우가 아니면 재-마운팅이 일어나지 않도록 만들어 두었습니다. 그러나 DOM 트리의 뿌리쪽에 가깝게 위치한 컴포넌트에 변경사항이 생긴다면 그 자식들이 모두 diffing과 reconciliation의 대상이 되어버립니다. 복잡한 구조라면 비용이 상당히 많이 들어가게 되므로 종종 회피의 대상이 되곤 합니다.</p><p><strong>React가 특정 브랜치는 보지 못하도록 할 수 있다면 좋을 것 같습니다. 그 브랜치에는 아무런 변경사항이 없을 것이라 확신할 수 있으니까요.</strong></p><p>그런 방법이 존재합니다. <a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" target="_blank" rel="external">컴포넌트 생명주기</a>의 한 부분인 <code>shouldComponentUpdate</code>라는 메소드가 참여하게 됩니다. 이 메소드는 각 컴포넌트의 <code>render</code> 메소드가 호출되기 <em>전에</em> 먼저 호출되며, props와 state의 새 값을 전달받습니다. 그러면 이제 현재 값과 비교를 해서 컴포넌트를 업데이트할지 말지 자유롭게 정할 수 있게 됩니다. (<code>true</code> 혹은 <code>false</code>를 반환하는 메소드입니다.) 만약 <code>false</code>를 반환하면 React는 문제가 되는 컴포넌트를 다시 렌더링하지 않을 것이고 그 컴포넌트의 자식도 들여다 보지 않을 겁니다.</p><p><code>props</code>와 <code>state</code> 세트를 비교할 때 대부분의 경우 간단한 <em>얕은</em> 비교 정보면 충분합니다. 만약 최상위 층의 값이 다르면 업데이트 할 필요가 없다고 판정내립니다. 얕은 비교는 Javascript의 기능이 아니지만 이를 해낼 수 있는 <a href="https://github.com/dashed/shallowequal" target="_blank" rel="external">유틸리티</a>가 많이 있습니다.</p><p>유틸리티의 도움을 받아서 코드를 다음과 같이 작성할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TableRow extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  // 새로운 props/state가 예전 것과 다르면 true를 반환하게 됩니다.</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    const &#123; props, state &#125; = this;</span><br><span class="line">    return !shallowequal(props, nextProps)</span><br><span class="line">           &amp;&amp; !shallowequal(state, nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123; /* ... */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 위 코드를 여러분이 직접 작성할 필요 조차 없습니다. React에는 <code>React.PureComponent</code>라고 불리우는 내장 기능이 있기 때문이죠. <code>React.Component</code>와 비슷한데, 다만 <em>얕은</em> props/state 비교가 필요할 것이라 가정하여 이미 여러분을 위해 <code>shouldComponentUpdate</code>가 구현되어 있습니다.</p><p>따로 생각할 필요가 없어 보이는데, 그냥 클래스 정의 부분의 <code>extends</code> 부분에 들어간 <code>Component</code>를 <code>PureComponent</code>로 바꿔보고 효율이 얼마나 좋나 감상해 보도록 하죠. 그런데 그다지 안 빠르네요! 다음과 같은 코드를 봐봅시다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Table</span><br><span class="line">    // 맵을 사용하면 새로운 배열 인스턴스를 반환하게 되므로 얕은 비교 결과는 실패가 나옵니다</span><br><span class="line">    rows=&#123;rows.map(/* ... */)&#125;</span><br><span class="line">    // 객체 리터럴은 항상 전의 것과 &quot;다릅니다&quot;</span><br><span class="line">    style=&#123; &#123; color: &apos;red&apos; &#125; &#125;</span><br><span class="line">    // 화살표 함수는 스코프 내에 이름 없는 함수를 새로 만드는 것과 같으므로 항상 diff 비교작업이 전부 이뤄지게 됩니다</span><br><span class="line">    onUpdate=&#123;() =&gt; &#123; /* ... */ &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>위 코드 스니펫에 가장 흔한 세가지 안티 패턴이 들어있습니다. 사용하지 않도록 하세요!</p><p><strong>객체, 배열, 함수를 새로 만들 때 <code>render</code> 정의 밖에서 만들고,  호출과 호출 사이에 아무것도 변한게 없다 확신할 수 있다면 여러분은 이제 안전한 겁니다.</strong></p><p><code>PureComponent</code>의 사용 효과는 <a href="https://iadramelk.github.io/optimizing-react-demo/dist/after.html" target="_blank" rel="external">데모 개선버전</a>에서 관찰해 볼 수 있습니다. 테이블의 모든 <code>Row</code>가 정제를 거친 상태입니다. React 개발자도구의 “Highlight Updates”를 키고 새로운 행을 삽입해보면 테이블 그 자체와 새로 넣어진 행만 다시 렌더링되고 다른 모든 행에는 아무 일도 일어나지 않는 것을 관찰해 볼 수 있습니다.</p><p>그러나 pure 컴포넌트로 앱 구석구석까지 대체할 자신이 없다면 여기서 멈추세요. <code>props</code>와 <code>state</code> 두 세트를 비교하는 작업은 공짜로 할 수 있는 것이 아니기도 하고 대부분의 기본적인 컴포넌트에서는 그런 작업을 진행할 필요가 없습니다. Diffing 알고리즘보다 <code>shallowCompare</code> 돌리는 데 시간만 더 걸리게 될 겁니다.</p><p>여기 경험에서 우러난 법칙을 사용해 보세요. Pure 컴포넌트는 복잡한 폼과 테이블에는 좋지만 버튼과 아이콘 같이 상대적으로 간단한 요소에 사용하면 대부분 속도만 느려지게 됩니다.</p><hr><p>읽어주셔서 감사합니다! 이제 여러분은 애플리케이션에 직접 여기서 배운 것들을 적용할 준비를 마치셨어요. 저희가 만든 작은 데모(<code>PureComponent</code> <a href="https://iadramelk.github.io/optimizing-react-demo/dist/after.html" target="_blank" rel="external">있는</a> 버전과 <a href="https://iadramelk.github.io/optimizing-react-demo/dist/before.html" target="_blank" rel="external">없는</a> 버전)가 담긴 이 <a href="https://github.com/iAdramelk/optimizing-react-demo" target="_blank" rel="external">저장소</a>를 여러분 실험의 시작점으로 사용하셔도 됩니다. 그리고 이 시리즈의 다음 글도 기대해주세요. Redux 및 앱의 전반적인 성능 향상을 위해 <em>data</em>를 최적화하는 법에 대해 다룰 예정입니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;원문: &lt;a href=&quot;https://evilmartians.com/chronicles/optimizing-react-virtual-dom-explained&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://evi
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://www.holaxprogramming.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>GraphQL과 RESTful API</title>
    <link href="https://www.holaxprogramming.com/2018/01/20/graphql-vs-restful-api/"/>
    <id>https://www.holaxprogramming.com/2018/01/20/graphql-vs-restful-api/</id>
    <published>2018-01-20T13:00:00.000Z</published>
    <updated>2022-06-07T00:26:23.001Z</updated>
    
    <content type="html"><![CDATA[<p>GraphQL 은 Server API 를 구성하기 위해 Facebook 에서 만든 Query Language 이다.</p><a id="more"></a><p>이 글에서는 Server API 가 무엇인지, 그리고 GraphQL 이 어떤 역할을 하는지에 대해서 알아볼 것이다.</p><hr><div align="center"><img src="http://graphql.org/img/logo.svg" height="300"></div><h2 id="Server-API"><a href="#Server-API" class="headerlink" title="Server API"></a>Server API</h2><p>Server API (혹은 Server-side web API) 는 적절한 요청을 하였을 때,<br>그에 맞는 응답을 되돌려주는 창구 (Endpoint) 를 Web 을 통해 노출한 것을 말한다.</p><p>이런 Server API 는 어떤 정보들(환율, 주식 시세, 뉴스 …)을 요청하고 수정하기 위해서 만들어지는 경우가 많다.<br>Facebook 의 경우에도 글을 쓰면 <a href="https://www.facebook.com/webgraphql/mutation/" target="_blank" rel="external">https://www.facebook.com/webgraphql/mutation/</a> 과 같은 Domain 으로 요청이 가고,<br>그 요청에 의해서 Facebook 에 글이 써지게 된다.</p><p>이 Server API 를 만드는 방법론 중 하나로 REST 라는 것이 있으며,<br>이 방법론은 많은 Server API 들을 구성하기 위해 사용되어왔고, 또 현재도 많이 사용되고 있다.</p><h2 id="REST-와-RESTful"><a href="#REST-와-RESTful" class="headerlink" title="REST 와 RESTful"></a>REST 와 RESTful</h2><p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">REST</a> 는 <a href="https://en.wikipedia.org/wiki/Roy_Fielding" target="_blank" rel="external">Roy Fielding</a> 의<br>“Architectural Styles and the Design of Network-based Software Architectures” 라는 책에서 소개된 방법론으로,<br>REpresentational State Transfer 의 줄임말이다.<br>이 내용이 정확히 무슨 뜻이며, REST 가 무슨 개념을 다 포함하는지 설명하기에는 너무 내용이 길어지게 된다.<br>따라서 간단히만 설명하면,<br>모든 Resource (자료, User, …) 들을 하나의 Endpoint 에 연결해놓고,<br>각 Endpoint 는 그 Resource 와 관련된 내용만 관리하게 하자는 방법론이다.</p><p>예시로 어떤 API 가 Community site 용 API 이며,<br>이 API 를 사용해 사용자들이 글을 작성/수정/삭제 할 수 있고,<br>각 글에 댓글을 작성/수정/삭제할 수 있다고 해보자.</p><p>이때, API 의 Endpoint 를 다음과 같이 구성하면 REST 의 조건을 간략히는 만족하게 된다.</p><ol><li>글 관련 API = /posts<ol><li>글 작성 = POST /posts</li><li>글 수정 = PATCH /posts/[postid]</li><li>글 삭제 = DELETE /posts/[postid]</li></ol></li><li>댓글 관련 API = /posts/[postid]/comments<ol><li>댓글 작성 = POST /posts/[postid]/comments</li><li>댓글 수정 = PATCH /posts/[postid]/comments/[commentid]</li><li>댓글 삭제 = DELETE /posts/[postid]/comments/[commentid]</li></ol></li></ol><p>(물론 실제 API 에는 이보다 더 많은 것들 (글 가져오기, 회원가입하기, 회원인증하기, 회원정보 확인하기, …) 이 필요할 것이다.)</p><p>이런 REST 의 조건을 만족하는 API 를 RESTful API 라고 부르고, 이런 방식으로 API 를 작성하는 것을 RESTful 하다고 한다.</p><h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p>GraphQL 은 Graph Query Language 의 줄임말이다.<br>Query Language 란 무엇인가?<br>Query Language 는 정보를 얻기 위해 보내는 질의문(Query)을 만들기 위해 사용되는 Computer 언어의 일종이다.<br>GraphQL 은 이런 Query Language 중에서도 Server API 를 통해 정보를 주고받기 위해 사용하는 Query Language 이다.</p><p>GraphQL 은 왜 탄생해야했는가?<br>다시말해, REST 방법론이 있는데도 새로운 언어인 GraphQL 이 탄생해야했던 배경은 무엇인가?<br>Facebook 의 <a href="http://graphql.org/blog/graphql-a-query-language/" target="_blank" rel="external">GraphQL blog</a> 에서는 다음과 같이 이유를 밝히고 있다.</p><ul><li>RESTful API 로는 다양한 기종에서 필요한 정보들을 일일히 구현하는 것이 힘들었다.</li><li>예로, iOS 와 Android 에서 필요한 정보들이 조금씩 달랐고, 그 다른 부분마다 API 를 구현하는 것이 힘들었다.</li></ul><p>이 때문에 정보를 사용하는 측에서 원하는 대로 정보를 가져올 수 있고,<br>보다 편하게 정보를 수정할 수 있도록 하는 표준화된 Query language 를 만들게 되었다.<br>이것이 GraphQL 이다.</p><h2 id="GraphQL-과-RESTful-의-차이점"><a href="#GraphQL-과-RESTful-의-차이점" class="headerlink" title="GraphQL 과 RESTful 의 차이점"></a>GraphQL 과 RESTful 의 차이점</h2><p>GraphQL 을 통한 API 는 RESTful API 와는 다른 측면을 보인다.</p><ol><li>GraphQL API 는 주로 하나의 Endpoint 를 사용한다.</li><li>GraphQL API 는 요청할 때 사용한 Query 문에 따라 응답의 구조가 달라진다.</li></ol><p>하나하나 살펴보자.</p><h4 id="API-의-Endpoint"><a href="#API-의-Endpoint" class="headerlink" title="API 의 Endpoint"></a>API 의 Endpoint</h4><p>위에서 말했듯 RESTful API 는 Resource 마다 하나의 Endpoint 를 가지고,<br>그 Endpoint 에서 그 Resource 에 대한 (거의) 모든 것을 담당한다.<br>반면, GraphQL 은 전체 API 를 위해서 단 하나의 Endpoint 만을 사용한다.</p><p>다음의 Github API v3 과 v4 이 좋은 예시가 될 것이다.</p><ul><li><a href="https://developer.github.com/v3" target="_blank" rel="external">Github API v3</a></li><li><a href="https://developer.github.com/v4" target="_blank" rel="external">Github API v4</a></li></ul><p>각각 <a href="https://developer.github.com/v3/#root-endpoint" target="_blank" rel="external">v3 root endpoint</a> 와 <a href="https://developer.github.com/v4/guides/forming-calls/#the-graphql-endpoint" target="_blank" rel="external">v4 root endpoint</a> 로 Endpoint 를 제공하지만,<br>v4 의 경우 Root endpoint 를 제외한 어떤 Endpoint 도 없는 반면,<br>v3 의 경우는 각 Resource 마다 수많은 Endpoint 들을 제공한다.</p><h4 id="API-응답의-구조"><a href="#API-응답의-구조" class="headerlink" title="API 응답의 구조"></a>API 응답의 구조</h4><p>RESTful API 는 하나의 Endpoint 에서 돌려줄 수 있는 응답의 구조가 정해져 있는 경우가 많다.<br>API 를 작성할 때 이미 정해놓은 구조로만 응답이 오게 되는 것이다.<br>반면, GraphQL 은 사용자가 응답의 구조를 자신이 원하는 방식으로 바꿀 수 있다.</p><p>마찬가지로 Github API 를 예시로 보면,<br><a href="https://developer.github.com/v3/repos/#list-your-repositories" target="_blank" rel="external">v3 repository api</a> 는 구조가 예시에 나온 모양으로 고정되어 있는 반면,<br><a href="https://developer.github.com/v4/explorer/" target="_blank" rel="external">v4 api</a> 의 경우는</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query &#123; </span><br><span class="line">  repository(owner: &quot;Ailrun&quot; name: &quot;rxan&quot;) &#123;</span><br><span class="line">    nameWithOwner</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>를 사용하느냐,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query &#123; </span><br><span class="line">  repository(owner: &quot;Ailrun&quot; name: &quot;rxan&quot;) &#123;</span><br><span class="line">    languages(first: 2) &#123;</span><br><span class="line">      nodes &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>를 사용하느냐에 따라서 응답의 구조가 완전히 다르게 된다.</p><h4 id="GraphQL-vs-RESTful"><a href="#GraphQL-vs-RESTful" class="headerlink" title="GraphQL vs RESTful"></a>GraphQL vs RESTful</h4><p>이런 차이로 인해 생기는 장단점은 무엇이 있는가?</p><p>GraphQL 은 다음과 같은 장점을 가진다.</p><ol><li>HTTP 요청의 횟수를 줄일 수 있다.<ul><li>RESTful 은 각 Resource 종류 별로 요청을 해야하고, 따라서 요청 횟수가 필요한 Resource 의 종류에 비례한다.<br>반면 GraphQL 은 원하는 정보를 하나의 Query 에 모두 담아 요청하는 것이 가능하다.</li></ul></li><li>HTTP 응답의 Size 를 줄일 수 있다.<ul><li>RESTful 은 응답의 형태가 정해져있고, 따라서 필요한 정보만 부분적으로 요청하는 것이 힘들다.<br>반면 GraphQL 은 원하는 대로 정보를 요청하는 것이 가능하다.</li></ul></li></ol><p>두 장점을 예시를 통해 알아보자.<br>우리가 글의 목록과 각 글에 쓰인 댓글의 목록을 가져올 수 있는 API 가 있다고 해보자.<br>이 API 가 RESTful 하게 작성되었다면 글과 댓글의 목록을 가져오기 위해서 다음 중 한 가지 방법을 선택해야 할 것이다.</p><ol><li>글의 목록을 가져오는 Endpoint 와 댓글의 목록을 가져오는 Endpoint 에 각각 요청을 여러 번 한다.<br>글이 5 개 있다고 해보자.<br>이 경우에는 글의 목록을 가져오는 Endpoint 에 요청을 하고,<br>각 글마다 댓글의 목록을 가져오는 Endpoint 에 요청을 5 번 해야 글과 댓글의 목록을 모두 가져올 수 있을 것이다. (1. 장점)</li><li>글의 목록을 가져오는 Endpoint 의 응답에 댓글의 목록을 포함한다.<br>글이 5 개 있다고 해보자.<br>이 경우에는 글의 목록을 가져오는 Endpoint 에 요청을 1 번 하면 끝이지만,<br>글의 목록만 가져와야 하는 경우나 몇몇 글의 댓글만 가져와야 하는 경우가 있다면<br>필요한 정보에 비해서 응답의 크기가 쓸데없이 큰 경우가 발생할 것이다. (2. 장점)</li><li>글의 목록을 가져오는 요청에 조건을 달아서 댓글의 목록을 포함할 수도, 포함하지 않을 수도 있게 한다.<br>API 에 Endpoint 가 많을 경우, API 를 만드는 것이 점점 더 복잡해지고,<br>결국 Facebook 에서 GraphQL 을 만든 이유와 비슷한 상황에 처하게 된다.</li></ol><p>반면 같은 API 를 GraphQL 로 작성하였다면</p><ol><li>글의 목록만을 가져와야 할 경우에는 글의 목록만을 가져오는 Query 를 작성하여 서버에 요청을 보낸다.</li><li>글의 목록과 댓글을 모두 가져와야 할 경우에는 글의 목록과 댓글을 모두 가져오는 Query 를 작성하여 서버에 요청을 보낸다.</li></ol><p>등을 할 수 있다.</p><p>그렇다면 GraphQL 은 장점만 가지는가? 물론 단점도 있다.<br>GraphQL 은 다음과 같은 단점을 가진다.</p><ol><li>File 전송 등 Text 만으로 하기 힘든 내용들을 처리하기 복잡하다.</li><li>고정된 요청과 응답만 필요할 경우에는 Query 로 인해 요청의 크기가 RESTful API 의 경우보다 더 커진다.</li><li>재귀적인 Query 가 불가능하다. (결과에 따라 응답의 깊이가 얼마든지 깊어질 수 있는 API 를 만들 수 없다.)</li></ol><p>물론 GraphQL 에서 File 전송을 할 수 없는 것은 아니나,<br>일반적인 GraphQL API 에 비해서 복잡해지거나 외부의 Service 에 의존해야하는 등 문제가 발생한다.</p><h4 id="GraphQL-or-RESTful"><a href="#GraphQL-or-RESTful" class="headerlink" title="GraphQL or RESTful?"></a>GraphQL or RESTful?</h4><p>그렇다면 GraphQL 과 RESTful 중 어떤 것을 선택해서 사용해야하는가?<br>다음과 같은 기준으로 선택하면 될 것이다.</p><ol><li>GraphQL<ul><li>서로 다른 모양의 다양한 요청들에 대해 응답할 수 있어야 할 때</li><li>대부분의 요청이 CRUD(Create-Read-Update-Delete) 에 해당할 때</li></ul></li><li>RESTful<ul><li>HTTP 와 HTTPs 에 의한 Caching 을 잘 사용하고 싶을 때</li><li>File 전송 등 단순한 Text 로 처리되지 않는 요청들이 있을 때</li><li>요청의 구조가 정해져 있을 때</li></ul></li></ol><p>그러나 더 중요한 것은, <strong>둘 중 하나를 선택할 필요는 없다</strong>는 것이다.</p><h4 id="GraphQL-and-RESTful"><a href="#GraphQL-and-RESTful" class="headerlink" title="GraphQL and RESTful!"></a>GraphQL and RESTful!</h4><p>File 전송과 같이 RESTful 이 더 유리한 API 가 있을 수 있고,<br>다양한 정보를 주고받는 것 같이 GraphQL 이 더 유리한 API 가 있을 수 있다.</p><p>이럴 때 둘 중 하나만 선택해야할 필요는 없다.<br>하나의 Endpoint 를 GraphQL 용으로 만들고,<br>다른 RESTful endpoint 들을 만들어 놓는 것은 API 개발자의 자유다.<br>주의해야할 것은 하나의 목표를 위해 두 API structure 를 섞어놓는 것은 API 의 품질을 떨어트릴 수 있다는 점이다.<br>(예: 사용자 정보를 등록하는 것은 RESTful API 로, 사용자 정보를 수정하는 것은 GraphQL API 로 한다면 끔찍할 것이다.)</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>GraphQL 은 여러 장점을 가지고 Server 의 구조를 단순화 시켜줄 수 있는 좋은 Query Language 이다.<br>다만, GraphQL 의 장점이 언제나 의미를 가지는 것은 아니며, 어떤 조건에서 사용하는지, 어떤 목표로 사용하는지에 따라서<br>장점으로 작용하기도, 단점으로 작용하기도 한다.<br>훌륭한 API 개발자가 되기 위해서는<br>이런 장단점을 잘 파악하여 GraphQL 만 쓸 것인지,<br>RESTful structure 또한 사용할 것인지,<br>혹은 RESTful structure 만 사용할 것인지를 결정하는 것이 중요하다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GraphQL 은 Server API 를 구성하기 위해 Facebook 에서 만든 Query Language 이다.&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="https://www.holaxprogramming.com/categories/nodejs/"/>
    
    
  </entry>
  
  <entry>
    <title>Python으로 시작하는 알고리듬</title>
    <link href="https://www.holaxprogramming.com/2017/12/29/algorithms-learning-strategy/"/>
    <id>https://www.holaxprogramming.com/2017/12/29/algorithms-learning-strategy/</id>
    <published>2017-12-29T02:54:07.000Z</published>
    <updated>2022-06-07T00:26:22.982Z</updated>
    
    <content type="html"><![CDATA[<p>이 글은 파이썬을 통해 알고리듬 학습을 시작하는 분들을 위한 내용입니다.</p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><h4 id="Install-Python"><a href="#Install-Python" class="headerlink" title="Install Python"></a>Install Python</h4><p>파이썬은 공식 사이트인 <a href="https://www.python.org/" target="_blank" rel="external">python.org</a>에서 다운로드할 수 있다. 설치가 매우 간단하며 OSX 사용자라면 이미 파이썬이 설치되어 있을 것이다. </p><p>가능하면 가장 최신의 버전의 python3를 설치하는 것을 권장한다. 설치 후 커맨드 라인에서 아래와 같이 입력하면, 파이썬 Interpeter를 통해 프로그래밍할 수 있는 환경이 갖추어진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04)</span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="IDLE과-PyCharm-IDE"><a href="#IDLE과-PyCharm-IDE" class="headerlink" title="IDLE과 PyCharm IDE"></a>IDLE과 PyCharm IDE</h4><p>Interpreter 언어인 파이썬은 위와 같은 Interactive 모드를 통해 별도의 도구 없이 한 줄 한 줄 프로그래밍 하도록 도와준다. </p><p>이 REPL은 매우 유용하지만 앞으로 파이썬 코드를 파일에 작성하고자 한다면 JetBrain의 <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm IDE</a>를 사용하는 것을 추천한다.</p><blockquote><p>파이썬에는 파일에 작성하기 위한 기본 도구인 IDLE를 포함하고 있다.</p></blockquote><p>자 뻔한 과정은 생략하고 아래와 같이 Hello World를 출력하는 첫 파이썬 프로그램을 작성해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;print(&apos;Hello World!&apos;)&quot; &gt; hello_world.py</span><br></pre></td></tr></table></figure><p>파일에 작성된 코드 역시 파이썬 Interpreter에 의해서 실행되며 방법은 아래와 같다. 정상적으로 출력이 된다면 우리는 파이썬 프로그래밍을 위한 모든 준비를 마쳤다!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 hello_world.py</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="TDD로-Python-시작하기"><a href="#TDD로-Python-시작하기" class="headerlink" title="TDD로 Python 시작하기"></a>TDD로 Python 시작하기</h2><p>만약 파이썬이 처음이라면 TDD를 통해 프로젝트를 구성하고 파이썬을 더욱 멋지게 활용할 수 있는 아래의 글을 참고하도록 하자. 프로젝트의 소스코드는 GitHub링크를 아래에 첨부하였다. 도움이 될 듯하다면 ★ Star를 누르는 센스도 잊지 말자!</p><ul><li><a href="https://www.holaxprogramming.com/2017/06/15/python-get-started/">시작하기</a></li><li><a href="https://www.holaxprogramming.com/2017/06/17/python-with-test/">unittest와 함께하는 파이썬 테스트</a></li><li><a href="https://www.holaxprogramming.com/2017/06/28/python-project-structures/">파이썬 프로젝트의 구조</a></li><li><a href="https://www.holaxprogramming.com/2017/07/15/python-virtual-environments/">파이썬 실행 환경을 지탱하는 도구들</a></li></ul><blockquote><p>GitHub Repo - <a href="https://github.com/stunstunstun/awesome-algorithms" target="_blank" rel="external">https://github.com/stunstunstun/awesome-algorithms</a></p></blockquote><h2 id="다양한-알고리듬-문제를-제공하는-사이트들"><a href="#다양한-알고리듬-문제를-제공하는-사이트들" class="headerlink" title="다양한 알고리듬 문제를 제공하는 사이트들"></a>다양한 알고리듬 문제를 제공하는 사이트들</h2><ul><li><a href="https://www.hackerrank.com/dashboard" target="_blank" rel="external">Hacker Rank</a></li><li><a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a></li><li><a href="https://codility.com/programmers/" target="_blank" rel="external">Codility</a></li><li><a href="https://www.kaggle.com/" target="_blank" rel="external">Kaggle</a></li><li><a href="https://visualgo.net/en" target="_blank" rel="external">Visualgo</a></li><li><a href="http://algo-visualizer.jasonpark.me/#path=backtracking/knight&#39;s_tour/basic" target="_blank" rel="external">Algorithm Visualizer</a></li></ul><h2 id="Google과-Facebook은-어떻게-알고리듬-인터뷰를-진행할까"><a href="#Google과-Facebook은-어떻게-알고리듬-인터뷰를-진행할까" class="headerlink" title="Google과 Facebook은 어떻게 알고리듬 인터뷰를 진행할까?"></a>Google과 Facebook은 어떻게 알고리듬 인터뷰를 진행할까?</h2><ul><li><a href="https://careers.google.com/how-we-hire/interview/" target="_blank" rel="external">Google</a></li><li><a href="https://www.facebook.com/notes/facebook-engineering/get-that-job-at-facebook/10150964382448920/" target="_blank" rel="external">Facebook</a></li></ul><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><h4 id="Time-Complexity와-Space-Complexity"><a href="#Time-Complexity와-Space-Complexity" class="headerlink" title="Time Complexity와 Space Complexity"></a>Time Complexity와 Space Complexity</h4><p>알고리듬을 테스트하면서 가장 고려할 요소는 Time Complexity와 Space complexity이다.</p><h4 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h4><p><img src="https://i1.wp.com/texblog.org/Wordpress/wp-content/uploads/2014/06/big-o-example-latex.png" width="400"></p><p>Time Complexity(시간 복잡도)는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 표현한다. 얼마나 많은 데이터를 입력 받았는지 그에 따라 CPU는 얼마나 사용하는지 수행 시간은 얼마나 걸리는지를 표현할 수 있다.</p><p>가장 많이 쓰이는 표현법으로는 알고리듬의 실행 시간의 상한을 나타내는 <code>Big-O</code> 표기법이 있다.</p><h4 id="Big-O-Notations"><a href="#Big-O-Notations" class="headerlink" title="Big-O Notations"></a>Big-O Notations</h4><p><img src="https://camo.githubusercontent.com/874181d7b840a494fe94a11cc13c1fad5d372217/68747470733a2f2f6170656c6261756d2e66696c65732e776f726470726573732e636f6d2f323031312f31302f796161636f766170656c6261756d6269676f706c6f742e6a7067" width="400"></p><table><thead><tr><th>Big-O</th><th>Operations for 10 things</th><th>Operations for 100 things</th></tr></thead><tbody><tr><td>O(1)</td><td>1</td><td>1</td></tr><tr><td>O(log n)</td><td>3</td><td>7</td></tr><tr><td>O(n log n)</td><td>30</td><td>700</td><td></td></tr><tr><td>0(n^2)</td><td>100</td><td>10000</td><td></td></tr></tbody></table><blockquote><p>Solutions - <a href="https://www.martinkysel.com/codility-solutions/" target="_blank" rel="external">https://www.martinkysel.com/codility-solutions/</a></p></blockquote><p><code>O(1) - Constant Time</code></p><p>입력되는 데이터양과 상관없이 일정한 실행 시간을 가진다.</p><p><code>O(log n) - Logarithmic Time</code></p><ul><li>입력 데이터 양이 많아져도 수행 시간이 조금씩 늘어난다.</li><li>시간에 비례하여, 탐색 가능한 데이터양이 2의 n승이 된다.</li></ul><blockquote><p>Binary Search</p></blockquote><p><code>O(n) - Linear Time</code></p><ul><li>입력 데이터 양에 따라 수행 시간이 정비례한다.</li></ul><blockquote><p>선형 탐색, for 문을 통한 탐색을 생각하면 되겠다.</p></blockquote><p><code>O(n log n) - Linearithmic time</code></p><ul><li>입력 데이터 양이 n배 많이 진다면, 수행 시간은 n배 보다 조금 더 많아 진다.</li><li>정비례하지 않는다.</li></ul><blockquote><p>예를 들면, 이진 트리 정렬은 n 크기의 배열 각 요소를 하나하나 삽입하여 이진 트리를 만든다. 자가 균형 이진 탐색 트리의 삽입 연산은 O(log n)시간이 걸리기 때문에, 전체 알고리듬은 Linearithmic time이 걸린다.</p></blockquote><p><code>O(n^2) - Quadratic Time</code></p><ul><li>입력 데이터의 양에 따라 수행 시간은 제곱에 비례한다.</li></ul><blockquote><p>Bubble Sort</p></blockquote><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지금까지 파이썬을 통해 알고리듬을 학습하기 위한 첫 걸음을 띄어보았습니다. 기본적인 알고리듬의 구현, 테스트 코드는 아래의 GitHub링크를 참고하세요. 시작이 반이니 화이팅하세요 :) </p><blockquote><p><a href="https://github.com/stunstunstun/awesome-algorithms" target="_blank" rel="external">https://github.com/stunstunstun/awesome-algorithms</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이 글은 파이썬을 통해 알고리듬 학습을 시작하는 분들을 위한 내용입니다.&lt;/p&gt;
&lt;h2 id=&quot;Get-Started&quot;&gt;&lt;a href=&quot;#Get-Started&quot; class=&quot;headerlink&quot; title=&quot;Get Started&quot;&gt;&lt;/a&gt;Get S
      
    
    </summary>
    
      <category term="algorithm" scheme="https://www.holaxprogramming.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Yarn 톺아보기</title>
    <link href="https://www.holaxprogramming.com/2017/12/21/node-yarn-tutorials/"/>
    <id>https://www.holaxprogramming.com/2017/12/21/node-yarn-tutorials/</id>
    <published>2017-12-21T00:00:00.000Z</published>
    <updated>2022-06-07T00:26:23.016Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://designmodo.com/wp-content/uploads/2016/10/Yarn-1.jpg" width="400"></p><blockquote><p>톺아보다 [동사] 샅샅이 톺아 나가면서 살피다.</p></blockquote><p>Yarn은 프로젝트의 의존성을 관리하는 JavaScript의 패키지 매니저입니다. Java의 gradle이나 Python의 pip과 같이 말이죠. 물론 우리에겐 npm이 있지만 Yarn은 보다 더 빠르고 거기다 더욱 안전합니다. npm과 같이 JavaScript 패키지의 저장소를 제공할 뿐만 아니라 시스템에서 의존 패키지를 설치하거나 업데이트하는 등의 다양한 명령을 제공합니다.</p><p>Yarn은 npm과 마찬가지로 <code>package.json</code>을 통해 의존 패키지를 구분하고 프로젝트에서 어떠한 일들을 해야할지 결정합니다.</p><h2 id="Facebook은-Yarn을-왜-만들었을까"><a href="#Facebook은-Yarn을-왜-만들었을까" class="headerlink" title="Facebook은 Yarn을 왜 만들었을까?"></a>Facebook은 Yarn을 왜 만들었을까?</h2><p>Facebook은 점차 거대해지는 프로젝트에서 npm을 사용하면서 일관적, 보안, 특히 성능에 대한 문제를 겪에 되었고 npm을 대체할 새로운 패키지 매니저를 개발하게 됩니다.</p><h4 id="npm의-한계"><a href="#npm의-한계" class="headerlink" title="npm의 한계"></a>npm의 한계</h4><p>npm 저장소의 취약한 보안 이슈를 시작으로, 의존 패키지의 버저닝 이슈, 무엇보다 패키지가 많아짐에 따라 빌드 성능이 좋지 않다는 점이 가장 큰 문제입니다.</p><p>버저닝 이슈는 예를 들면 로컬에서 특정 패키지의 버전이 1.0.0인데 배포를 위한 빌드 서버에서는 시점에 따라 1.0.3으로 업데이트 될 수도 있음을 말합니다.</p><blockquote><p>최근의 보안 이슈 - <a href="http://blog.npmjs.org/post/163723642530/crossenv-malware-on-the-npm-registry" target="_blank" rel="external">http://blog.npmjs.org/post/163723642530/crossenv-malware-on-the-npm-registry</a></p></blockquote><h4 id="Yarn은-npm에-비해-얼마나-빠른가"><a href="#Yarn은-npm에-비해-얼마나-빠른가" class="headerlink" title="Yarn은 npm에 비해 얼마나 빠른가?"></a>Yarn은 npm에 비해 얼마나 빠른가?</h4><p>간단한 React 애플리케이션을 통해 node_modules을 설치하는 속도는 npm과 크게 차이가 나지 않습니다. 하지만 두 번째 명령을 통해 아래와 같이 성능 차이가 나는 것을 볼 수 있습니다.</p><p><code>React app</code></p><table><thead><tr><th>Action</th><th>First time</th><th>Second Time(Cached)</th></tr></thead><tbody><tr><td>npm install</td><td>24.3s</td><td>5.4s</td></tr><tr><td>yarn install</td><td>22.9s</td><td>976ms</td></tr></tbody></table><blockquote><p>성능 테스트 참고 - <a href="https://yarnpkg.com/en/compare" target="_blank" rel="external">https://yarnpkg.com/en/compare</a></p></blockquote><h4 id="Yarn은-모든-패키지를-유저-디렉토리에-저장해-캐싱합니다"><a href="#Yarn은-모든-패키지를-유저-디렉토리에-저장해-캐싱합니다" class="headerlink" title="Yarn은 모든 패키지를 유저 디렉토리에 저장해 캐싱합니다."></a>Yarn은 모든 패키지를 유저 디렉토리에 저장해 캐싱합니다.</h4><p>캐싱하기 위한 디렉토리 경로는 아래와 같습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn cache dir</span><br><span class="line"><span class="variable">$HOME</span>/Library/Caches/Yarn/v1</span><br></pre></td></tr></table></figure><h2 id="시작하기"><a href="#시작하기" class="headerlink" title="시작하기"></a>시작하기</h2><p>지금까지 Yarn이 출현하게 된 배경을 살펴보았고 이제 시스템에 Yarn을 설치해보도록 하겠습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- -L https://yarnpkg.com/install.sh | bash</span><br></pre></td></tr></table></figure><p>또는 nvm을 통해 node 버전을 관리하고 있다면 npm을 통해 설치하는 것을 추천합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g yarn</span><br></pre></td></tr></table></figure><p>어디에 설치되어 있을까요?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> yarn</span><br><span class="line"><span class="variable">$HOME</span>/.nvm/versions/node/v8.9.0/bin/yarn</span><br></pre></td></tr></table></figure><h4 id="yarn-global"><a href="#yarn-global" class="headerlink" title="yarn global"></a>yarn global</h4><p>이 명령은 패키지를 시스템 전역에서 설치, 업데이트, 삭제하는 것을 의미합니다. 패지키가 설치되는 경로를 지정할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn config <span class="built_in">set</span> prefix ~/.yarn</span><br><span class="line">$ yarn global add pm2 npm-check create-react-app</span><br></pre></td></tr></table></figure><p>아래의 명령을 통해 현재 전역에 설치된 패키지 리스트와 실행 파일의 위치를 확인할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global list</span><br><span class="line">yarn global v1.3.2</span><br><span class="line">info <span class="string">"create-react-app@1.4.3"</span> has binaries:</span><br><span class="line">   - create-react-app</span><br><span class="line">info <span class="string">"npm-check@5.5.2"</span> has binaries:</span><br><span class="line">   - npm-check</span><br><span class="line">info <span class="string">"pm2@2.8.0"</span> has binaries:</span><br><span class="line">   - pm2</span><br><span class="line">...</span><br><span class="line">✨ Done <span class="keyword">in</span> 1.51s.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global bin</span><br><span class="line"><span class="variable">$HOME</span>/.yarn/bin</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls <span class="variable">$HOME</span>/.yarn/bin</span><br><span class="line">create-react-apppm2-devyarnyarnpkg</span><br><span class="line">npm-checkpm2-dockerpm2pm2-runtime</span><br></pre></td></tr></table></figure><h4 id="yarn-init"><a href="#yarn-init" class="headerlink" title="yarn init"></a>yarn init</h4><p>이 문서에서는 간단하게 <code>pet-kitten</code>이라는 이름의 프로젝트를 <code>yarn init</code> 명령을 통해 생성합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir pet-kitten</span><br><span class="line">$ <span class="built_in">cd</span> pet-kitten</span><br><span class="line">$ yarn init</span><br><span class="line">yarn init v1.3.2</span><br><span class="line">question name (pet-kitten):</span><br><span class="line">question version (1.0.0):</span><br><span class="line">question description:</span><br><span class="line">question entry point (index.js):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>위와 같이 프로젝트에 필요한 기본적인 정보를 입력하면 <code>package.json</code> 파일이 생성됩니다.</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>이 파일에는 최소한 패지키의 이름과 버전을 포함해야하며 프로젝트에 필요한 의존 프로젝트는 추가로 <code>dependencies</code>라는 키에 정의하게 됩니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"pet-kitten"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"stunstunstun"</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dependencies-패키지의-버전의-범위"><a href="#dependencies-패키지의-버전의-범위" class="headerlink" title="dependencies 패키지의 버전의 범위"></a>dependencies 패키지의 버전의 범위</h2><p>프로젝트에서 HTTP 요청을 위한 의존 패키지를 <code>request</code>를 사용한다면 아래와 같이 정의하면 됩니다.</p><ul><li>npm 패키지의 이름</li><li>npm 패키지의 버전을 표기합니다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"pet-kitten"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"requests"</span>: <span class="string">"^2.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"stunstunstun"</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm 패키지의 버전 표기 방식이 낮설어 보일수도 있는데, 프로젝트의 의존 패키지의 버전을 정의하기 위해 가장 많이 사용되는 방식은 틸드(~), 캐럿(^)입니다. 이 두 방식이 패키지 버전의 범위를 어떻게 표현하는지 이해할 필요가 있습니다.</p><h4 id="틸드"><a href="#틸드" class="headerlink" title="틸드(~)"></a>틸드(~)</h4><p>틸드는 간단히 말하면 현재 지정한 버전의 마지막 자리의 범위에서만 자동으로 업데이트합니다.</p><table><thead><tr><th>예시</th><th>범위</th></tr></thead><tbody><tr><td>~0.0.1</td><td><code>&gt;=0.0.1 and &lt;0.1.0</code></td></tr><tr><td>~0.1.1</td><td><code>&gt;=0.1.1 and &lt;0.2.0</code></td></tr></tbody></table><h4 id="캐럿"><a href="#캐럿" class="headerlink" title="캐럿(^)"></a>캐럿(^)</h4><p>캐럿(^)은 Node.js 모듈이 이 <a href="http://semver.org/" target="_blank" rel="external">Semantic Versioning</a>의 규약을 따른다는 것을 신뢰한다는 가정하에서 동작하는데, Minor나 Patch버전은 하위 호환성이 보장되어야 하므로 최신 버전이 존재한다면 업그레이드 진행할 수 있습니다.</p><table><thead><tr><th>예시</th><th>범위</th></tr></thead><tbody><tr><td>^1.0.2</td><td><code>&gt;=1.0.2 and &lt;2.0</code></td></tr><tr><td>^1.0</td><td><code>&gt;=1.0.0 and &lt;2.0</code></td></tr><tr><td>^1</td><td><code>&gt;=1.0.0 and &lt;2.0</code></td></tr></tbody></table><p>하지만 아직 npm 저장소 생태계의 몇몇 패키지는 Minor, Patch 버전이 업데이트 되었음에도 하위 호환성을 보장하지 않고 우리가 원하는 방식으로 동작하지 않는 경우가 있습니다. 이점은 대규모 프로젝트의 환경에서는 치명적이기 때문에 프로젝트에서 의존 패키지를 효율적으로 관리하기 위해 Yarn이 어떻게 동작하는지 정확히 이해할 필요가 있습니다.</p><h2 id="yarn-lock"><a href="#yarn-lock" class="headerlink" title="yarn.lock"></a>yarn.lock</h2><p>위와 같이 Yarn은 <code>package.json</code>에 정의된 버전의 범위에 따라 패키지를 관리합니다. 하지만 이는 시스템마다 <code>yarn install</code>이 되는 시점에 따라 패키지의 버전이 다를 수도 있다는 것을 의미합니다.</p><p>Yarn은 이 문제를 해결하고 시스템간에 일관적으로 패키지 버전을 제공하기 위해 <code>yarn.lock</code> 파일을 프로젝트의 루트에 자동으로 생성합니다. 사용자는 이 파일을 직접 수정해서는 안되며 Yarn CLI을 통해 패키지를 관리하면 자동으로 업데이트됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.</span><br><span class="line"># yarn lockfile v1</span><br><span class="line">...</span><br><span class="line">mongoose@^4.9.8:</span><br><span class="line">  version &quot;4.9.8&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/mongoose/-/mongoose-4.9.8.tgz#ef64304231dc2455ab15a0c0cb6c149ce8c787bb&quot;</span><br><span class="line">  dependencies:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>package.json</code>과 <code>yarn.lock</code>은 Version control 시스템과 긴밀하게 연결되어야 합니다. 많은 사람들과 애플리케이션을 안정적으로 운영하고자 한다면 이 파일들을 Git Repository에 함께 저장하는 것을 추천합니다.</p><h4 id="하위-호환성을-보장하지-않는-사례"><a href="#하위-호환성을-보장하지-않는-사례" class="headerlink" title="하위 호환성을 보장하지 않는 사례"></a>하위 호환성을 보장하지 않는 사례</h4><p>현재 <code>yarn.lock</code>의 mongoose 버전은 4.9.8로 resloved 되어 있고, 만약 테스트 환경을 구축하기 위해 <code>devDependencies</code>에 mocha, chai, nyc와 같은 패키지를 추가하거나 버전만을 업데이트했다고 가정합니다.</p><p><code>packages.json</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">"chai"</span>: <span class="string">"^4.1.2"</span>,</span><br><span class="line"><span class="string">"mocha"</span>: <span class="string">"^4.0.1"</span>,</span><br><span class="line"><span class="string">"nyc"</span>: <span class="string">"^11.3.0"</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>아래와 같은 명령은 프로젝트의 모든 패키지를 지정된 범위 내에서 업데이트하고 <code>yarn.lock</code>을 <code>recreated</code>하게 됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn upgrade</span><br></pre></td></tr></table></figure><p><code>devDependencies</code> 뿐만 아니라 런타임에도 영향을 미치는 mongoose와 같은 패키지도 현재의 기준으로 최신 버전으로 resolved 됩니다.</p><p><code>yarn.lock</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongoose@^4.9.8:</span><br><span class="line">  version &quot;4.13.6&quot;</span><br><span class="line">  resolved &quot;https://registry.yarnpkg.com/mongoose/-/mongoose-4.13.6.tgz#48102f0b0d797a9bd273e581eef16d0505ef3d79&quot;</span><br><span class="line">  dependencies:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>최신 버전인 4.13.6으로 resloved 된 mongoose 패키지</p></blockquote><p>Major Fixed가 아님에도 이 업데이트는 하위 호환성을 보장하지 않고 MongError를 발생하는 현상이 있었습니다. 이 경우에는 테스트 케이스를 통해 업데이트 버전에 맞게 코드를 수정해야 합니다.</p><h2 id="Yarn-commands"><a href="#Yarn-commands" class="headerlink" title="Yarn commands"></a>Yarn commands</h2><p>지금까지는 Yarn의 출현 배경을 알아봤다면 지금부터는 Yarn이 제공하는 CLI를 통해 효율적으로 패키지를 관리할 필요가 있습니다.</p><h4 id="yarn-install"><a href="#yarn-install" class="headerlink" title="yarn install"></a>yarn install</h4><p>로컬의 <code>node_modules</code> 폴더에 의존 패키지를 설치하거나 업데이트합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install</span><br></pre></td></tr></table></figure><p>install은 생략할 수 도 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn</span><br></pre></td></tr></table></figure><p>yarn을 통해 패키지를 설치할 때 주의해야할 사항으로는 빌드, 테스트등을 위한 패키지는 런타임에 영향을 미치지 않아야 합니다. 아래와 같이 <code>NODE_ENV</code> 환경 변수나 <code>--production</code> flag를 통해 production 환경에서 devDependencies에 정의된 패키지의 설치를 생략할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install --production</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ NODE_ENV=production yarn install</span><br></pre></td></tr></table></figure><p>반대로 NODE_ENV가 production임에도 강제로 devDependencies의 설치가 필요하다면 <code>--production</code>을 false로 지정합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install --production=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>강제로 모든 패키지를 다시 다운로드해야하는 경우도 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install --force</span><br></pre></td></tr></table></figure><p>CI 서버와 같이 재생 가능한 의존 패키지가 필요한 경우 <code>--fronzen-lockfile</code> 플래그는 유용합니다. <code>yarn.lock</code>과 <code>package.json</code>이 동기화 되지 않은 상태에서 업데이트가 필요한 경우에는 설치를 실패하고 <code>yarn.lock</code>을 생성하지 않습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install --frozen-lockfile</span><br><span class="line">yarn install v1.3.2</span><br><span class="line">[1/4] 🔍  Resolving packages...</span><br><span class="line">error Your lockfile needs to be updated, but yarn was run with `--frozen-lockfile`.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/install <span class="keyword">for</span> documentation about this <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/yarnpkg/yarn/issues/4147" target="_blank" rel="external">https://github.com/yarnpkg/yarn/issues/4147</a><br><a href="https://github.com/yarnpkg/yarn/issues/3313" target="_blank" rel="external">https://github.com/yarnpkg/yarn/issues/3313</a></p></blockquote><h4 id="yarn-add"><a href="#yarn-add" class="headerlink" title="yarn add"></a>yarn add</h4><p>프로젝트에서 다른 패키지를 사용하기 위해 <code>package.json</code>에 <code>dependencies</code>를 직접 설정하는 방법과 add 명령이 있습니다. 이 명령은 프로젝트의 <code>package.json</code>과 <code>yarn.lock</code>을 업데이트해 모든 개발자가 일괄적인 패키지를 관리할 수 있도록 합니다.</p><p>npm 저장소의 가장 최신 패키지를 설치합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add request</span><br></pre></td></tr></table></figure><p>패키지의 버전 범위를 지정합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add request@^2.0.0</span><br></pre></td></tr></table></figure><p>devDependencies에 패키지를 추가합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add eslint@^4.0.0 --dev</span><br></pre></td></tr></table></figure><h4 id="yarn-upgrade"><a href="#yarn-upgrade" class="headerlink" title="yarn upgrade"></a>yarn upgrade</h4><p>이 명령은 모든 의존 패키지를 <code>package.json</code>에 정의한 버전의 범위에서 업데이트하거나 삭제합니다.</p><ul><li><code>yarn.lock</code> 파일이 <code>recreated</code> 됩니다.</li><li><code>package.json</code>에는 변화가 없습니다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn upgrade</span><br></pre></td></tr></table></figure><p>위에서 살펴본대로 대규모의 프로젝트에서는 의존된 모든 패키지가 호환성을 보장하기 힘들기 때문에 이 명령을 통해 일괄적으로 패지키를 업데이트하는 것은 좋지 않습니다. 기존 패키지의 업데이트가 필요하다면 아래와 같이 패키지를 지정해 업데이트하는 것을 추천합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn upgrade mocha@^4.0.0</span><br></pre></td></tr></table></figure><h4 id="yarn-remove"><a href="#yarn-remove" class="headerlink" title="yarn remove"></a>yarn remove</h4><p><code>yarn remove foo</code> 명령은 <code>foo</code>라는 패키지를 프로젝트에서 제거하는 것을 의미합니다.</p><ul><li><code>package.json</code>에서 제거됩니다.</li><li><code>yarn.lock</code>에서 제거됩니다.</li></ul><p>dependencies, devDependencies등 모든 타입에서 패키지가 삭제됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn remove foo</span><br></pre></td></tr></table></figure><blockquote><p>yarn remove는 package.json과 yarn.lock을 언제나 업데이트합니다. 이는 같은 프로젝트에서 협업하는 동료들도 동일한 의존 패키지를 사용하는 것을 보장하는 것을 의미합니다.</p></blockquote><h2 id="yarn-config와-yarnrc"><a href="#yarn-config와-yarnrc" class="headerlink" title="yarn config와 .yarnrc"></a>yarn config와 <code>.yarnrc</code></h2><p><code>yarn config</code> 명령을 통해 Yarn에서 참조하는 설정 파일을 지정할 수 있습니다. 아래와 같이 npm 패키지 저장소의 URL을 변경하거나 라이센스를 지정하는 경우를 말합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ yarn config set registry &apos;https://registry.yarnpkg.com&apos;</span><br><span class="line">$ yarn config set init-license MIT</span><br><span class="line">$ yarn config list</span><br><span class="line">...</span><br><span class="line">registry: &apos;https://registry.yarnpkg.com&apos;,</span><br><span class="line">init-license: &apos;MIT&apos;</span><br></pre></td></tr></table></figure><p>프로젝트의 로컬에서는 아래와 같이 <code>.yarnrc</code> 파일을 통해 별도의 명령 없이 config list를 관리할 수 있습니다.</p><p><code>.yarnrc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry: &apos;https://registry.yarnpkg.com&apos;</span><br><span class="line">init-license: &apos;MIT&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yarn config list</span><br><span class="line">...</span><br><span class="line">registry: &apos;https://registry.yarnpkg.com&apos;,</span><br><span class="line">init-license: &apos;MIT&apos;</span><br></pre></td></tr></table></figure><h2 id="프로젝트의-패키지-버전-안정적으로-관리하기"><a href="#프로젝트의-패키지-버전-안정적으로-관리하기" class="headerlink" title="프로젝트의 패키지 버전 안정적으로 관리하기"></a>프로젝트의 패키지 버전 안정적으로 관리하기</h2><p>npm, yarn을 통해서 dependencies 패키지 버전을 지속적으로 체크하는 다양한 옵션이 존재합니다.</p><h4 id="yarn-check"><a href="#yarn-check" class="headerlink" title="yarn check"></a>yarn check</h4><p>패키지 버전에 따른 의존 패키지들이 프로젝트에서 유효한지 체크합니다. 이 기준은 현재의 <code>package.json</code>이 <code>yarn.lock</code>과 일치하는지 확인하는 것을 말합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yarn check</span><br><span class="line">yarn check v1.3.2</span><br><span class="line">warning <span class="string">"chokidar#fsevents#node-pre-gyp@^0.6.39"</span> could be deduped from <span class="string">"0.6.39"</span> to <span class="string">"node-pre-gyp@0.6.39"</span></span><br><span class="line">success Folder <span class="keyword">in</span> sync.</span><br><span class="line">✨  Done <span class="keyword">in</span> 6.65s.</span><br></pre></td></tr></table></figure><p><code>yarn check</code> 명령 후에 위와 같이 warning, error를 만난다면 의존 패키지의 버전을 조정할 필요가 있습니다.</p><h4 id="yarn-outdated"><a href="#yarn-outdated" class="headerlink" title="yarn outdated"></a>yarn outdated</h4><p><code>yarn outdated</code>는 업데이트가 필요한 모듈이 정리되어 출력되기 때문에 의존 패키지의 버전을 조종하는데 유용하게 사용됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ yarn outdated</span><br><span class="line">yarn outdated v1.3.2</span><br><span class="line">info Color legend :</span><br><span class="line"> <span class="string">"&lt;red&gt;"</span>    : Major Update backward-incompatible updates</span><br><span class="line"> <span class="string">"&lt;yellow&gt;"</span> : Minor Update backward-compatible features</span><br><span class="line"> <span class="string">"&lt;green&gt;"</span>  : Patch Update backward-compatible bug fixes</span><br><span class="line">Package           Current Wanted Latest Package Type    URL</span><br><span class="line">@types/jest       21.1.8  21.1.9 21.1.9 devDependencies https://www.github.com/DefinitelyTyped/DefinitelyTyped.git</span><br><span class="line">@types/koa        2.0.39  2.0.39 2.0.43 devDependencies https://www.github.com/DefinitelyTyped/DefinitelyTyped.git</span><br><span class="line">@types/koa-router 7.0.23  7.0.23 7.0.27 devDependencies https://www.github.com/DefinitelyTyped/DefinitelyTyped.git</span><br><span class="line">cross-env         5.0.5   5.0.5  5.1.1  devDependencies https://github.com/kentcdodds/cross-env<span class="comment">#readme</span></span><br><span class="line">jest              21.2.1  21.2.1 22.0.3 devDependencies http://facebook.github.io/jest/</span><br><span class="line">koa               2.3.0   2.3.0  2.4.1  dependencies    https://github.com/koajs/koa<span class="comment">#readme</span></span><br><span class="line">koa-router        7.2.1   7.2.1  7.3.0  dependencies    https://github.com/alexmingoia/koa-router<span class="comment">#readme</span></span><br><span class="line">nodemon           1.12.0  1.12.0 1.14.1 devDependencies http://nodemon.io</span><br><span class="line">ts-jest           21.2.4  21.2.4 22.0.0 devDependencies https://github.com/kulshekhar/ts-jest<span class="comment">#readme</span></span><br><span class="line">ts-node           3.3.0   3.3.0  4.0.2  devDependencies https://github.com/TypeStrong/ts-node</span><br><span class="line">tslint            5.7.0   5.7.0  5.8.0  devDependencies https://github.com/palantir/tslint.git</span><br><span class="line">typescript        2.5.2   2.5.2  2.6.2  devDependencies http://typescriptlang.org/</span><br><span class="line">✨  Done <span class="keyword">in</span> 1.71s.</span><br></pre></td></tr></table></figure><p><code>Current</code>는 프로젝트에 현재 설치된 버전이고 <code>Wanted</code>는 package.json에 지정한 패키지의 버전에서 호환성을 보장하는 버전을 의미합니다. 즉, yarn upgrade를 통해 변경 되는 버전을 말합니다. </p><p><code>Latest</code>는 패키지의 현재의 최신 버전입니다. 위 화면에서는 <code>jest</code>와 같이 Major 업데이트가 필요한 패키지는 붉은색으로 표시됩니다.</p><h4 id="npm-check"><a href="#npm-check" class="headerlink" title="npm-check"></a>npm-check</h4><p><code>yarn outdated</code>를 통해 원하는 모듈을 업데이트해도 되지만 꽤 귀찮은 작업으로 보입니다. <code>npm-check</code>는 Iteractive한 UI를 터미널에서 제공해 조금 더 쉽게 패키지의 버전을 관리할 수 있도록 도와줍니다.</p><ul><li><a href="https://www.npmjs.com/package/npm-check" target="_blank" rel="external">https://www.npmjs.com/package/npm-check</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global install npm-check</span><br></pre></td></tr></table></figure><p>프로젝트의 루트경로에서 아래와 같이 사용할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm-check -u</span><br></pre></td></tr></table></figure><p><img src="https://cloud.githubusercontent.com/assets/51505/9569917/96947fea-4f48-11e5-9783-2d78077256f2.png"></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이미 npm을 통해 효율적으로 프로젝트를 관리하고 계시다면 꼭 Yarn을 사용해야 하는 것은 아닙니다. npm 역시 npm@5 부터 더욱 안정적이고 성능이 좋아졌기 때문입니다. 각자의 용도에 따라 필요한 수준의 도구를 이용하면 됩니다. </p><p>만약 대규모 프로젝트에서 Yarn을 통해 더 나은 경험을 얻고자 하신다면 2017년 12월 현재, 아래의 지침으로 정리할 수 있겠습니다.</p><ul><li><code>yarn.lock</code>은 절대 직접 수정하지 않습니다.</li><li><code>package.json</code>을 직접 수정하는 대신 yarn CLI를 통해 추가, 삭제, 업데이트하는 것을 추천합니다.</li><li>새로운 패키지는 <code>yarn add package@^version</code></li><li>기존 패키지의 업데이트를 위해서는 <code>yarn upgrade package@^version</code></li><li><code>yarn upgrade</code> 명령을 통해 모든 패키지를 업데이트 하는 행위는 호환성이 보장되지 않는 대참사를 불러올 수 있기 때문에 사용을 지양합니다.</li></ul><blockquote><p>오직 add, remove, 그리고 upgrade 명령만이 <code>yarn.lock</code>을 업데이트 합니다.</p><p>단, <code>yarn.lock</code>이 <code>package.json</code>과 일치하지 않는 상태라면 install 명령으로 패키지가 업데이트 되고 <code>package.json</code>을 만족하기 위해 필요한 만큼 수정됩니다.</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></li><li><a href="https://yarnpkg.com/en/docs/configuration" target="_blank" rel="external">https://yarnpkg.com/en/docs/configuration</a></li><li><a href="https://yarnpkg.com/en/docs/cli/install" target="_blank" rel="external">https://yarnpkg.com/en/docs/cli/install</a></li><li><a href="https://yarnpkg.com/en/docs/cli/add" target="_blank" rel="external">https://yarnpkg.com/en/docs/cli/add</a></li><li><a href="https://yarnpkg.com/lang/en/docs/cli/upgrade/" target="_blank" rel="external">https://yarnpkg.com/lang/en/docs/cli/upgrade/</a></li><li><a href="https://yarnpkg.com/en/docs/cli/check" target="_blank" rel="external">https://yarnpkg.com/en/docs/cli/check</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://designmodo.com/wp-content/uploads/2016/10/Yarn-1.jpg&quot; width=&quot;400&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;톺아보다 [동사] 샅샅이 톺아 나가면서 살피다.&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="nodejs" scheme="https://www.holaxprogramming.com/categories/nodejs/"/>
    
    
  </entry>
  
  <entry>
    <title>소소한 GitHub Tips</title>
    <link href="https://www.holaxprogramming.com/2017/12/20/github-tips/"/>
    <id>https://www.holaxprogramming.com/2017/12/20/github-tips/</id>
    <published>2017-12-20T01:00:00.000Z</published>
    <updated>2022-06-07T00:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub에서 다양한 인원이 프로젝트를 진행하면 이슈 트래킹이 중요합니다. 이슈가 등록될 때 프로젝트에서 참고하는 중요한 정보가 있다면 이슈나 PR을 생성할 때 아래와 같이 Templates를 지정하면 유용합니다.</p><h2 id="Issue-PR-템플릿-활용하기"><a href="#Issue-PR-템플릿-활용하기" class="headerlink" title="Issue, PR 템플릿 활용하기"></a>Issue, PR 템플릿 활용하기</h2><ol><li>프로젝트의 Root 디렉토리에 아래와 같이 <code>.github</code> 폴더를 생성합니다.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir .github</span><br><span class="line">$ <span class="built_in">cd</span> .github </span><br><span class="line">$ touch ISSUE_TEMPLATE.md    <span class="comment"># 이슈 등록시 템플릿 파일</span></span><br><span class="line">$ touch PULL_REQUEST_TEMPLATE.md  <span class="comment"># PR 등록시 템플릿 파일</span></span><br></pre></td></tr></table></figure><ol><li>새로운 이슈를 등록합니다.</li></ol><p><img src="https://image.toast.com/aaaaahq/new_issues_button.png" width="100"></p><ol><li>적용된 Template를 확인합니다.</li></ol><p><img width="768" alt="github-templates" src="https://image.toast.com/aaaaahq/0c099be0-d9ec-11e7-962d-df3b88f29401.png"></p><p><br></p><h2 id="키워드를-통해-이슈-닫기"><a href="#키워드를-통해-이슈-닫기" class="headerlink" title="키워드를 통해 이슈 닫기"></a>키워드를 통해 이슈 닫기</h2><p>Commit 메세지 뿐만 아니라 PR 등록시에도 아래의 키워드를 통해 PR이 Merge되면 이슈를 Closed 할 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">close</span><br><span class="line">closes</span><br><span class="line">closed</span><br><span class="line">fix</span><br><span class="line">fixes</span><br><span class="line">fixed</span><br><span class="line">resolve</span><br><span class="line">resolves</span><br><span class="line">resolved</span><br></pre></td></tr></table></figure></p><p><img width="711" alt="github-templates2" src="https://image.toast.com/aaaaahq/d70a1c7a-d9ec-11e7-8910-9686d333d378.png"></p><blockquote><p>참고 - <a href="https://help.github.com/articles/closing-issues-using-keywords/" target="_blank" rel="external">https://help.github.com/articles/closing-issues-using-keywords/</a></p></blockquote><p><br></p><h2 id="의존-패키지-조회하기"><a href="#의존-패키지-조회하기" class="headerlink" title="의존 패키지 조회하기"></a>의존 패키지 조회하기</h2><p>프로젝트의 <code>Insight &gt; Dependency graph</code> 메뉴에서 모든 의존 패키지를 쉽게 확인할 수 있습니다.</p><ul><li><a href="https://github.com/request/request/network/dependencies" target="_blank" rel="external">https://github.com/request/request/network/dependencies</a></li></ul><blockquote><p>현재 이 기능은 GitHub Enterprise에서는 제공되지 않고 있습니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GitHub에서 다양한 인원이 프로젝트를 진행하면 이슈 트래킹이 중요합니다. 이슈가 등록될 때 프로젝트에서 참고하는 중요한 정보가 있다면 이슈나 PR을 생성할 때 아래와 같이 Templates를 지정하면 유용합니다.&lt;/p&gt;
&lt;h2 id=&quot;Issu
      
    
    </summary>
    
      <category term="git" scheme="https://www.holaxprogramming.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Scala에서의 값 명명과 표현식 평가</title>
    <link href="https://www.holaxprogramming.com/2017/11/18/scala-value-naming/"/>
    <id>https://www.holaxprogramming.com/2017/11/18/scala-value-naming/</id>
    <published>2017-11-18T06:30:00.000Z</published>
    <updated>2022-06-07T00:26:23.020Z</updated>
    
    <content type="html"><![CDATA[<p>모든 Programming 언어는 값 (Value) 을 명명 (Naming) 할 수 있다. 값에 이름을 붙이는 것은 복잡한 계산의 결과가 무엇을 뜻하는지 이해하기 쉽게 해준다. 뿐만 아니라 값에 이름을 붙이는 것은 동일한 계산을 Computer 가 여러 번 할 필요 없이, 효율적으로 한 번만 해도 되게 만들어준다. 따라서 값을 명명하고 값을 어떻게 계산하느냐는 Programming 언어에 있어서 매우 중요한 일 중 하나이다. Scala 에서는 이런 값의 명명과 계산을 어떻게 할 수 있는지, 또 그렇게 명명된 값을 어떻게 쓸 수 있는지 알아보자.</p><h4 id="Scala-를-사용하는-방법"><a href="#Scala-를-사용하는-방법" class="headerlink" title="Scala 를 사용하는 방법"></a>Scala 를 사용하는 방법</h4><p>이전 글(<a href="https://github.com/stunstunstun/awesome-wiki/tree/master/Scala/scala-hello-world.md" target="_blank" rel="external">Github</a>, <a href="https://www.holaxprogramming.com/2017/11/14/scala-hello-world/">안녕 프로그래밍 사이트</a>)을 참고하자.</p><p>이 글에서 역시 <a href="https://scastie.scala-lang.org/" target="_blank" rel="external">Scastie</a> 를 사용할 것이기 때문에 Scala 를 Computer 에 설치할 필요는 없으며, Scastie 에서 Worksheet 기능을 꺼주기만 하면 된다.</p><h4 id="표현식과-값"><a href="#표현식과-값" class="headerlink" title="표현식과 값"></a>표현식과 값</h4><p>사실, 명명법에 대해서 말하기 이전에, 우선 <strong>표현식</strong> (Expression) 이라는 것이 프로그래밍 언어에서 무엇인지를 알아야한다.</p><p>표현식이란, <strong>평가 (Evaluation) 를 통해서 값으로 바뀌는 식</strong>, 혹은 <strong>결과값이 있는 식</strong>을 뜻한다.</p><p>다음 Code 를 보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Expression</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="number">5</span> + <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>5 + 4</code> 이 <code>9</code> 로 계산되어 출력될 것이다. 이때 <code>9</code> 를 <code>5 + 4</code> 의 평가 결과, 혹은 표현식의 값이라고 하고, <code>5 + 4</code> 를 <strong>표현식</strong>이라고 한다.</p><p>Scala 에서의 표현식은 위와 같이 한 줄로 쓰여질 수도 있지만, 좀 더 복잡하게 쓰여질 수도 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Expression</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(&#123;</span><br><span class="line">    <span class="number">5</span> * <span class="number">7</span></span><br><span class="line">    <span class="number">4</span> + <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 Code 에서</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="number">5</span> * <span class="number">7</span></span><br><span class="line"><span class="number">4</span> + <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>에 해당하는 부분이 표현식이다. 이 표현식은 여러 줄로 쓸 수 있고, 여러 줄 중 하나에서 <code>println()</code> 과 같은 함수를  실행할 수도 있다. 이 표현식의 평가 결과는 언제나 <code>{}</code> 로 둘러싸인 제일 마지막 표현식의 평가 결과와 같다. 즉, 위 Code 의 경우는 <code>4 + 3</code> 의 값인 <code>7</code> 이 <code>{}</code> 로 둘러싸인 전체 표현식의 값이다.</p><p>실제로 앞의 Code 를 실행해보면 다음과 같은 출력을 볼 수 있을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>표현식과 평가에 대해서 기본적인 이해를 하였을 것이라 믿는다. 이제 Scala 에서 값을 명명하는 방법들에 대해서 알아보자.</p><h4 id="Scala-에서-쓸-수-있는-값의-명명-방법들"><a href="#Scala-에서-쓸-수-있는-값의-명명-방법들" class="headerlink" title="Scala 에서 쓸 수 있는 값의 명명 방법들"></a>Scala 에서 쓸 수 있는 값의 명명 방법들</h4><p>Scala 에는 기본적으로 다음과 같은 네 종류의 값의 명명이 가능하다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> oneAddOne = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> twoMultTwo = <span class="number">2</span> * <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> threeDivThree = <span class="number">3</span> / <span class="number">3</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fourMinusFour</span> </span>= <span class="number">4</span> - <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각각이 무엇을 의미하는지 살펴보도록 하자.</p><h4 id="val-을-사용한-명명"><a href="#val-을-사용한-명명" class="headerlink" title="val 을 사용한 명명"></a>val 을 사용한 명명</h4><p>아래 Code 를 실행시켜보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> first = <span class="number">1</span></span><br><span class="line">  println(first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 Code 의 실행 결과는 아래 Code 의 실행 결과와 똑같을 것이다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉 우리는 값 <code>1</code> 에 <code>first</code> 라는 이름을 붙이고 그 이름을 대신 사용할 수 있는 것이다.<br>이 경우에는 명명이 별로 쓸모가 없어보일 수도 있으니, 약간의 계산을 포함하는 다음 경우를 보도록 하자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cooktimeInMin = <span class="number">4</span></span><br><span class="line">  <span class="keyword">val</span> secPerMin = <span class="number">60</span></span><br><span class="line">  <span class="keyword">val</span> cooktimeInSec = cooktimeInMin * secPerMin</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"In other words, it takes "</span> + cooktimeInSec + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리는 우선 <code>cooktimeInMin</code> 이라는 이름으로 컵라면을 끓이는데 걸리는 시간을 <strong>(분)</strong> 단위로 정의했다. 그리고 <code>secPerMin</code> 이라는 이름으로 <strong>1 분 안에 몇 초가 있는지</strong>를 정의했다. 마지막으로, 컵라면을 끓이는데 걸리는 시간을 <strong>(초)</strong> 단위로 계산한 뒤 이 표현식의 값을 <code>cooktimeInSec</code> 이라는 이름으로 정의했다. 이 내용을 화면에 출력하기 위해서 <code>println</code> 함수와, <code>+</code>, <code>*</code> 를 사용하였다.</p><p>여기서 <code>println</code> 은 (이전 글을 읽었다면) 이미 알고 있을 것이고, <code>+</code> 와 <code>*</code> 에 대해서 알아보자. <code>+</code> 는 둘 이상의 String (<code>&quot;</code> 로 감싸져있는 Text) 혹은 String 으로 표시할 수 있는 것 (대표적으로는 숫자) 을 하나의 String 이 되도록 <strong>합치는</strong> 것이다. 또한, <code>*</code> 는 숫자 두 개를 곱하는 것이다. :) 실행해보면 이 말이 무슨 뜻인지 알 수 있을 것이다.</p><p>(힌트1: “Cup noodle takes “ 와 숫자 4 과 “ min.” 을 순서대로 쓰면?)<br>(힌트2: 4 * 60 은?)</p><h4 id="lazy-val-def-를-사용한-명명"><a href="#lazy-val-def-를-사용한-명명" class="headerlink" title="lazy val, def 를 사용한 명명"></a>lazy val, def 를 사용한 명명</h4><p><code>lazy val</code>, <code>def</code> 를 사용한 Code 를 보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cooktimeInMin = <span class="number">4</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> secPerMin = <span class="number">60</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cooktimeInSec = cooktimeInMin * secPerMin</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"In other words, it takes "</span> + cooktimeInSec + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Naming</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cooktimeInMin</span> </span>= <span class="number">4</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">secPerMin</span> </span>= <span class="number">60</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cooktimeInSec</span> </span>= cooktimeInMin * secPerMin</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"In other words, it takes "</span> + cooktimeInSec + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아까의 <code>val</code> 예시와 결과가 똑같지 않은가? 대체 차이점이 무엇인가?</p><p><code>val</code>, <code>lazy val</code>, <code>def</code> 의 차이점이 무엇인지 알기 위해서는 표현식의 평가가 어떻게 진행되는지를 알아야 한다.</p><h4 id="표현식의-평가-방법"><a href="#표현식의-평가-방법" class="headerlink" title="표현식의 평가 방법"></a>표현식의 평가 방법</h4><p>표현식의 평가 방법을 알기 위해 좀 더 복잡한 표현식을 사용해보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cooktimeInMin = &#123;</span><br><span class="line">    println(<span class="string">"Hi I'm cup noodle!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"Oh, "</span> + cooktimeInMin + <span class="string">" min is soooo short!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 Code 를 실행시키면 어떤 값이 출력될까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hi I&apos;m cup noodle!</span><br><span class="line">Let&apos;s start cooking!</span><br><span class="line">Cup noodle takes 4 min.</span><br><span class="line">Oh, 4 min is soooo short!</span><br></pre></td></tr></table></figure><p>이번에는 <code>val</code> 을 <code>lazy val</code> 로 바꾼 뒤 실행시켜보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> cooktimeInMin = &#123;</span><br><span class="line">    println(<span class="string">"Hi I'm cup noodle!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Let&apos;s start cooking!</span><br><span class="line">Hi I&apos;m cup noodle!</span><br><span class="line">Cup noodle takes 4 min.</span><br><span class="line">Oh, 4 min is soooo short!</span><br></pre></td></tr></table></figure><p>혹시 차이점을 눈치 챘는가? <code>lazy val</code> 의 경우는 <code>cooktimeInMin</code> 으로 이름 붙인 표현식이 더 늦게 평가된다. 이 ‘더 늦게’가 언제인지 알겠는가? 눈치챘다면, 훌륭하다!</p><p>눈치채지 못한 사람들을 위해 (다른 말론, 거의 모든 사람들을 위해) 정확하게 알려주자면, <code>lazy val</code> 은 <strong>정의된 이름이 처음 사용될 때</strong> 평가된다. 흠? 그렇다면 <code>val</code> 은 언제 평가된단 말인가? <code>val</code> 의 경우에는 <strong>정의되자 마자</strong> 평가된다.</p><p>다음 코드를 실행해보면 이 차이가 왜 중요한 지 알 수 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> noodleCookingTimeInMin = &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">5000</span>)</span><br><span class="line">    println(<span class="string">"Hm... it's hard to calculate!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"To make hamburger, let's start with making patty!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> noodleCookingTimeInMin = &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">5000</span>)</span><br><span class="line">    println(<span class="string">"Hm... it's hard to calculate!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"To make hamburger, let's start with making patty!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하나는 요리를 시작하기도 전에 컵라면 제조법을 읽느라 5 초를 기다려야한다!</p><p>자, 그러면 <code>def</code> 는? 다음 Code 를 실행해보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> cooktimeInMin = &#123;</span><br><span class="line">    println(<span class="string">"Hi I'm cup noodle!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> secPerMin = <span class="number">60</span></span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"Or, it takes "</span> + cooktimeInMin * secPerMin + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Evaluation</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cooktimeInMin</span> </span>= &#123;</span><br><span class="line">    println(<span class="string">"Hi I'm cup noodle!"</span>)</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> secPerMin = <span class="number">60</span></span><br><span class="line">  println(<span class="string">"Let's start cooking!"</span>)</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"Or, it takes "</span> + cooktimeInMin * secPerMin + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>val</code> 과 <code>lazy val</code> 의 차이점을 안 지금이라면 위 둘의 차이점도 알 수 있으리라 믿는다.</p><p>(힌트: <code>def</code> 는 사용될 때마다 …)</p><h4 id="var-을-사용한-정의"><a href="#var-을-사용한-정의" class="headerlink" title="var 을 사용한 정의"></a>var 을 사용한 정의</h4><p>다음 Code 를 실행시켜보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Definition</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cooktimeInMin = <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> secPerMin = <span class="number">60</span></span><br><span class="line">  <span class="keyword">var</span> cooktimeInSec = cooktimeInMin * secPerMin</span><br><span class="line">  println(<span class="string">"Cup noodle takes "</span> + cooktimeInMin + <span class="string">" min."</span>)</span><br><span class="line">  println(<span class="string">"In other words, it takes "</span> + cooktimeInSec + <span class="string">" sec."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>흠? 또 다시 <code>val</code> 의 예시와 같지 않은가? 이번에도 표현식이 평가되는 방식이 다른 것인가? 안타깝게도 <code>var</code> 은 <code>val</code> 과 동일하게 정의하는 즉시 평가된다. 그렇다면 대체 무엇이 다를까? 아래 코드를 각각 실행시키려고 해 보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Definition</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Oh, it's mistake!</span></span><br><span class="line">  <span class="keyword">val</span> cooktimeInMin = <span class="number">2</span></span><br><span class="line">  cooktimeInMin = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Definition</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Oh, it's mistake!</span></span><br><span class="line">  <span class="keyword">var</span> cooktimeInMin = <span class="number">2</span></span><br><span class="line">  cooktimeInMin = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 <code>//</code> 부분은 주석 (Comment) 이라고 부르며, 코드 안에 설명을 써 놓을 때 사용하는 기능이다. 지금은 <code>val</code> 을 사용한 Code 를 돌리려고 시도했을 때는 실행에 실패하고, <code>var</code> 의 경우에는 성공적으로 실행된다는 점에만 주목하면 된다.</p><p>Scala 에서 <code>val</code>, <code>lazy val</code>, <code>def</code> 는 한 번 명명한 뒤로 그 이름을 다른 값을 위해 사용할 수 없다. 처음에 <code>val</code> 에서 설명했듯이, <code>val cooktimeInMin = 2</code> 라고 하였으면, (평가하는 과정을 제외하면) <code>cooktimeInMin</code> 을 사용하는 것은 그 뒤에서 <code>2</code> 를 사용하는 것과 마찬가지이다. <code>2</code> 에 다른 이름을 붙인 것에 지나지 않기 때문이다.</p><p>반면 <code>var</code> 을 사용하는 것은 얘기가 조금 다르다. 눈치 빠른 독자는 이 절의 제목이 <strong>명명</strong>이 아닌 <strong>정의</strong>라는 것을 알아챘을 것이다. <code>var</code> 을 사용하면 그 안의 내용물을 언제든지 바꿀 수 있는 <strong>변수</strong>를 <strong>정의</strong>한 뒤, 그 첫 값을 <code>=</code> 뒤에 있는 값으로 설정한다. 대다수의 많은 개발자들이 사용하는 언어들을 기준으로 말하면, <code>var</code> 은 일반적으로 변수를 정의하는 것이고 <code>val</code> 은 <code>const</code>, <code>final</code> 등의 Keyword 를 붙여서 상수 (혹은 그 비슷한 것) 를 정의하는 것이다.</p><h4 id="명명과-정의"><a href="#명명과-정의" class="headerlink" title="명명과 정의?"></a>명명과 정의?</h4><p>이 쯤에서 의문이 드는 개발자도 있을 것이다.</p><blockquote><p>그러면 왜 변수에 해당하는 것은 하나뿐이고 상수에 해당하는 것은 세 개나 있지? 개발할 때 변수를 더 많이 쓰지 않나?</p></blockquote><p>결론만 말하자면, Scala 에서는 <code>val</code>, <code>lazy val</code>, <code>def</code> 를 사용해서 정의하는 것이 기본이고, 어쩔 수 없이 필요할 경우 (정말 중요한 성능의 문제라거나 …) 에만 한정적으로 <code>var</code> 을 사용한다. 이는 Scala 뿐만이 아니라 많은 Programming 언어에서 Bug 를 피하기 위한 Coding style 중에 하나이다.</p><ul><li><a href="http://www.bfilipek.com/2016/12/please-declare-your-variables-as-const.html" target="_blank" rel="external">C++</a></li><li><a href="https://softwareengineering.stackexchange.com/questions/98691/excessive-use-final-keyword-in-java" target="_blank" rel="external">Java</a></li><li><a href="https://eslint.org/docs/rules/prefer-const" target="_blank" rel="external">JavaScript</a></li><li>기타 등등…</li></ul><h4 id="다음에는…"><a href="#다음에는…" class="headerlink" title="다음에는…"></a>다음에는…</h4><p>지금까지 Scala 에서 표현식을 사용하는 방법과 표현식의 값을 명명하는 방법, 그리고 변수를 정의하는 방법에 대해서 알아보았다. 다음 글에서는 순차적인 Code 를 작성하는 방법과 Code 를 작게 쪼개는 방법에 대해서 알아볼 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;모든 Programming 언어는 값 (Value) 을 명명 (Naming) 할 수 있다. 값에 이름을 붙이는 것은 복잡한 계산의 결과가 무엇을 뜻하는지 이해하기 쉽게 해준다. 뿐만 아니라 값에 이름을 붙이는 것은 동일한 계산을 Computer 
      
    
    </summary>
    
      <category term="scala" scheme="https://www.holaxprogramming.com/categories/scala/"/>
    
    
  </entry>
  
  <entry>
    <title>Scala로 시작하는 Hello World</title>
    <link href="https://www.holaxprogramming.com/2017/11/14/scala-hello-world/"/>
    <id>https://www.holaxprogramming.com/2017/11/14/scala-hello-world/</id>
    <published>2017-11-14T06:20:00.000Z</published>
    <updated>2022-06-07T00:26:23.020Z</updated>
    
    <content type="html"><![CDATA[<p>Scala 는 Java 의 디자인 및 기능을 현대의 PL 연구 결과에 맞게 확장하는 방법에 대해 연구한 결과로 만들어진 언어이다. Java 와 마찬가지로 JVM (Java Virtual Machine) 위에서 작동하는 언어지만, Java 8 이전의 Java 와는 달리, Object Oriented Programming Style 과 Functional Programming Style 을 모두 훌륭하게 지원하고 있는 언어이다.</p><h4 id="Scala-설치하기"><a href="#Scala-설치하기" class="headerlink" title="Scala 설치하기"></a>Scala 설치하기</h4><p>이 과정은 컴퓨터 내에서 Scala 를 쓰기 위한 과정이다. 이 글 안에서는 편의성을 위해 <a href="https://scastie.scala-lang.org/" target="_blank" rel="external">Scastie</a> 를 사용하여 Web compiler 환경에서 작업하는 것을 기준으로 할 것이지만, 이후의 내용을 따라하기 위해 미리 설치해 놓는 것도 나쁘지 않다.</p><ol><li>위에서 말했듯이, Scala 는 JVM 위에서 작동하는 언어이다. 따라서 JVM (혹은 Java) 를 먼저 설치해야 한다. 아래 Link 에 접속해서 JVM 을 설치할 수 있다. 이미 JDK (Java Development Kit) 8 이상이 설치되어 있다면 이 단계는 넘어가도 된다.<ul><li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></li></ul></li><li>또한 Scala 를 편집하고 Compile 할 Environment 가 필요하다. 많이 사용되는 것은 IntelliJ IDE 이다. 아래 Link 에서 IntelliJ community edition 을 받을 수 있다. 이미 IntelliJ 가 설치되어 있다면 이 단계는 넘어가도 된다.<ul><li><a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="external">https://www.jetbrains.com/idea/download/</a></li><li>Community 라고 써져있는 것을 받자. 그쪽이 무료 버전이고, Ultimate 의 경우에는 체험판만을 제공한다.</li><li>IntelliJ 를 쓰지 않고 싶다면 SBT 를 설치하여야 한다. SBT 는 Scala 용 Build tool 중에 하나로, IntelliJ 외의 다른 Editor (Vim, Emacs, …) 들에서 Scala 를 쓰고 싶다면 사용하여야 하는 Tool 이다. SBT 에 대해서는 다른 글에서 설명하도록 할 것이다.</li></ul></li><li>이제 IntelliJ 를 킨다. Scala 는 IntelliJ 에서 Plugin 을 설치하는 것으로 설치된다. 아래 Link 를 따라서 IntelliJ 에 Plugin 을 설치할 수 있다. 설치해야하는 Plugin 은 <a href="https://plugins.jetbrains.com/plugin/1347-scala" target="_blank" rel="external">Scala</a> Plugin 이다.<ul><li><a href="https://www.jetbrains.com/help/idea/installing-updating-and-uninstalling-repository-plugins.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/installing-updating-and-uninstalling-repository-plugins.html</a></li><li>내용을 번역하자면,<blockquote><ol><li>Setting Dialog 를 Ctrl-Alt-S 를 누르거나 Menu 의 Settting Icon 을 눌러 연다.</li><li>왼쪽의 Plugins 라고 써져있는 창을 연다.</li><li>Install JetBrains plugin 혹은 Browse repositories 라고 써져있는 Button 을 누른다.</li><li>원하는 Plugin 에 오른쪽 Click 을 하고 Download and Install 을 누른다.</li><li>확인한다.</li><li>Install JetBrains plugin 혹은 Browse repositories 창을 닫는다.</li><li>OK 를 눌러 Setting Dialog 를 빠져나가고, 설정을 저장한다. IntelliJ 를 다시 켜서 Plugin 이 적용되도록 한다.</li></ol></blockquote></li></ul></li><li>이제 File -&gt; New -&gt; Project 를 눌러 Project 생성 창을 띄우고, 왼쪽에서 Scala, 오른쪽에서 Scala (혹은 SBT) 를 고른 뒤, Project 이름을 정한다. 그리고 오른쪽의 Scala SDK 창에서 Create button 을 눌러 Scala 를 (최신 버전을 골라서) 설치한다. SDK 가 설치된 것을 확인하였으면, Finish 를 눌러 Project 를 생성한다.</li><li>이제 Scala 를 설치하는데 성공하였다!</li></ol><p>잠깐, 아직 설치한 Scala 를 쓸 것은 아니다. 미리 받아놓는 것도 나쁘지는 않지만, 지금 꼭 받아야할 필요는 없으니 여유가 날 때 받아놓도록 하자.</p><h4 id="Scala-를-Web-에서-사용하기"><a href="#Scala-를-Web-에서-사용하기" class="headerlink" title="Scala 를 Web 에서 사용하기"></a>Scala 를 Web 에서 사용하기</h4><p>위와 같은 과정을 거쳐서 Scala 를 설치하는 것은 번잡할 뿐더러 이런저런 Setting 에 의해서 Code 가 정상적으로 작동하지 않을 수도 있다. 따라서 File 을 여러 개 만들 필요가 없는 간단한 경우의 예시는 다음 Link 의 Webpage 에서 Code 를 작성하고 Compile 시킨 뒤, 실행시킬 것이다.</p><ul><li><a href="https://scastie.scala-lang.org/MzWqJ6eEQxuEKYk8F25grg" target="_blank" rel="external">Scastie</a></li></ul><p>위 Link 에 접속해보면 이미 간단한 Code 가 써져있는 것을 볼 수 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><p>이 Code 를 실행시키기 위해서는 Run 이라고 써져있는 Button 을 누르면 된다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>) <span class="comment">// Hello, World!: java.lang.String</span></span><br></pre></td></tr></table></figure><p>실제로는 <code>//</code> 이 없이 바로 결과값이 Code 의 옆에 표시될 것이다. 이제 Hello World 를 출력했으니 끝난 것인가? 아니다. 위 Code 는 Hello World 를 출력하지는 않았다. 다음 절에서 실제로 Hello World 를 출력하는 Code 를 작성해보고, 위 Code 와 비교해보도록 하자.</p><h4 id="Scala-로-시작하는-Hello-World"><a href="#Scala-로-시작하는-Hello-World" class="headerlink" title="Scala 로 시작하는 Hello World"></a>Scala 로 시작하는 Hello World</h4><p>이 세상 모든 Program 은 <strong>시작 지점</strong>이 필요하다. 어디서부터 Code 를 읽어서 실행할 지를 모르면, Program 은 무슨 Code 를 실행해야 할 지 알 수가 없을 것이다. 이 <strong>시작지점</strong>을 영어로는 Entry point 라고 부른다.<br>Scala 의 경우에는 다음과 같은 Entry point 들이 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object 뒤에 나오는 `Basics` 부분에는 아무 Text 나 들어가도 된다.</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Basics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// Codes</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object 뒤에 나오는 `Simple` 부분에는 아무 Text 나 들어가도 된다.</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 두 개의 Entry point 는 <code>args</code> 를 사용하는 방법 빼고 동일하다. 이게 무슨 말인지는 다른 글에서 자세히 보도록 하고, 여기서는 우선 타수가 더 적은 두번째 Entry point 를 사용하도록 하자.</p><p>Scastie 에서 Entry point 를 제대로 사용하기 위해서는 Menu 의 Worksheet 부분에 불이 들어오지 않아야 한다. 만일 불이 들어와 있다면 Worksheet 부분을 Click 해서 불을 끄도록 하자.</p><p>이제, 아래와 같은 Code 를 실행하면 Hello World 를 화면에 찍어볼 수 있다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번에는 출력 결과가 Code 옆에 나타나는게 아니라 화면 밑의 검은 창 (Console) 에 나타날 것이다. <code>println</code> 은 그 뒤에 들어간 String (<code>&quot;Hello World!&quot;</code> 와 같이 <code>&quot;</code> 로 감싸져 있는 Text) 을 Console 에 출력하는 역할을 한다. 이름의 <code>print</code> 는 출력한다는 뜻인 걸 알겠는데, 맨 뒤의 <code>ln</code> 은 무엇일까? 이것은 line 의 줄임말로 한 줄을 넘기는 (Editor 에서 Enter key 를 치는) 효과를 가지고 있다. 정확한 효과가 궁금한 사람들은 아래의 코드를 실행해보라.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">"Hello World!"</span>)</span><br><span class="line">  print(<span class="string">"Hello"</span>)</span><br><span class="line">  print(<span class="string">"World!"</span>)</span><br><span class="line">  println(<span class="string">"THIS IS SCALA!!!!!!!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="출력과-결과값-비교하기"><a href="#출력과-결과값-비교하기" class="headerlink" title="출력과 결과값 비교하기"></a>출력과 결과값 비교하기</h4><p>아까 위에서</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>)</span><br></pre></td></tr></table></figure><p>와 같은 Code 를 보았을 것이다. Worksheet 에 불이 꺼진 채로 이 Code 를 돌리면 Compile Error 가 발생하기 때문에, 아래와 같이 Entry point 안에 넣어서 실행해보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>무슨 일이 벌어지는가? 다음과 같은 코드 또한 실행해보고 두 결과의 차이점이 무엇인지 생각해보자.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>).mkString(<span class="string">""</span>, <span class="string">", "</span>, <span class="string">"!"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>화면에 출력되는 것은 실제로 프로그램을 작동시켰을 때 눈에 보이는 것들이고, Code 의 결과값은 눈에 보이지 않고, Program 내부에서만 알 수 있는 값이다.</p><h4 id="다음에는…"><a href="#다음에는…" class="headerlink" title="다음에는…"></a>다음에는…</h4><p>지금까지 Scala 를 설치하는 방법, Scala 를 웹에서 사용하는 방법, Scala 의 Entry point 에 대해서 알아보았고, Scala 에서 Hello world 를 찍는 코드를 실행해보았다. 다음 글에서는 Scala 에서 값에 이름을 붙이는 방법에 대해서 알아볼 것이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Scala 는 Java 의 디자인 및 기능을 현대의 PL 연구 결과에 맞게 확장하는 방법에 대해 연구한 결과로 만들어진 언어이다. Java 와 마찬가지로 JVM (Java Virtual Machine) 위에서 작동하는 언어지만, Java 8 이전
      
    
    </summary>
    
      <category term="scala" scheme="https://www.holaxprogramming.com/categories/scala/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js의 실행 환경을 지탱하는 도구들</title>
    <link href="https://www.holaxprogramming.com/2017/10/30/node-environments/"/>
    <id>https://www.holaxprogramming.com/2017/10/30/node-environments/</id>
    <published>2017-10-30T01:07:11.000Z</published>
    <updated>2022-06-07T00:26:23.015Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript(JavaScript)가 Ajax, JSON, jQuery가 등장함으로서 널리 사용 되어지고 우리에게 익숙해졌다면 서버의 실행 환경을 위한 Node.js의 등장으로 JavaScript는 황금기를 맞이하게 되었습니다. 이 글에서는 Node.js를 시작하기 전에 시스템에서 필요한 Node.js의 실행환경에 대해 이야기 합니다.</p><p><img src="https://nodejs.org/static/images/logos/nodejs-new-pantone-black.png" width="400"></p><h2 id="Node-js와-npm"><a href="#Node-js와-npm" class="headerlink" title="Node.js와 npm"></a>Node.js와 npm</h2><p>Javascript가 황금기를 맞이하게 되는 결정적인 이유는 Node.js를 통해 Back-end에서도 동작하는 런타임 환경을 제공하게 된 것 뿐만 아니라 Node.js의 패키지 도구인 <code>npm</code>이 거대한 오픈소스 생태계로 발전한 것이 가장 결정적인 역할을 한 것으로 보인다.</p><p>npm은 JavaScript 패키지의 저장소일 뿐만 아니라 시스템에서 패키지 관리할 수 있는 다양한 명령어를 제공한다.</p><blockquote><p>npm은 JVM 진영의 Maven Central, jCenter나 Python 진영의 PYPI와 유사하다.</p></blockquote><p>우리는 npm을 통해서 Back-end, Front-end 구분 없이 JavaScript 기반으로 개발된 다양한 패키지를 사용 할 수 있고, 먼저 npm을 사용하기 위해서는 Node.js를 시스템에 설치해야 한다.</p><p>운영체제에 Node.js가 설치되어 있지 않다면, 아래와 같이 Terminal에서 Node를 설치하도록 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure><p>설치가 완료되면 Node.js와 npm의 버전을 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p>npm의 아래의 옵션을 통해 <code>yarn</code>, <code>gulp</code>를 시스템의 전역에서 사용할 수 있도록 설치할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g yarn gulp</span><br></pre></td></tr></table></figure><h4 id="npm의-주요-명령어들"><a href="#npm의-주요-명령어들" class="headerlink" title="npm의 주요 명령어들"></a>npm의 주요 명령어들</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm update</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save requests</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev babel babel-cli babel-core babel-preset-env babel-register</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall --save requests</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.npmjs.com/cli/npm" target="_blank" rel="external">https://docs.npmjs.com/cli/npm</a></p></blockquote><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>JSON Document로 만들어지는 <code>package.json</code>은 Node.js 프로젝트에서 아주 중요한 역할을 한다. 프로젝트의 기본 정보를 시작으로 의존되는 패키지와 버전을 지정할 수 있다.</p><blockquote><p><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;papago&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Papago translation API with ES6&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;request&quot;: &quot;^2.83.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">    &quot;babel-cli&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,</span><br><span class="line">    &quot;babel-register&quot;: &quot;^6.23.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;compile&quot;: &quot;babel lib -d build --presets env&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;eslint lib/**/*.js test/**/*.js --ignore-path .gitignore&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;npm run compile &amp;&amp; mocha --require babel-register&quot;,</span><br><span class="line">    &quot;coverage&quot;: &quot;istanbul cover mocha -- --require babel-register&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>package.json</code>에 정의된 script는 아래와 같이 <code>npm run</code> 명령으로 실행하며,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run compile</span><br></pre></td></tr></table></figure><p><code>test</code>, <code>start</code> 명령은 <code>run</code>을 생략할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">test</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure><blockquote><p>웹 애플리케이션인 경우 main에 지정된 경로를 통해서 start명령을 통해 서버를 실행할 수 있다.</p></blockquote><h4 id="npm-모듈-배포하기"><a href="#npm-모듈-배포하기" class="headerlink" title="npm 모듈 배포하기"></a>npm 모듈 배포하기</h4><p>npm 저장소에 자신의 모듈을 배포하는 방법은 비교적 쉬운 편이다.</p><p><code>사용자 추가</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm adduser</span><br></pre></td></tr></table></figure><p><code>테스트</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ../install-test</span><br><span class="line">$ <span class="built_in">cd</span> ../install-test</span><br><span class="line">$ npm install ../my-npm-module/</span><br></pre></td></tr></table></figure><p><code>배포</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm publish</span><br></pre></td></tr></table></figure><h2 id="Node-js의-버전관리-도구-nvm"><a href="#Node-js의-버전관리-도구-nvm" class="headerlink" title="Node.js의 버전관리 도구 nvm"></a>Node.js의 버전관리 도구 nvm</h2><p>한 시스템에서 다양한 프로젝트 그리고 프로젝트별로 Node의 버전을 다르게 사용하는 경우가 있다. 이 의미는 A 프로젝트에서 Node의 v4 버전을 사용해 유지 보수하면서 B 프로젝트에서는 v6 버전을 사용하는 것을 말한다. 뿐만 아니라 Node REPL에서도 지정한 버전을 따르게 된다.</p><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash</span><br></pre></td></tr></table></figure><p>위의 스크립트를 통해 nvm이 설치되면 시스템의 <code>.bash_profile</code>에 아래와 같이 환경 변수가 추가된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; . <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> <span class="comment"># This loads nvm</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> -v nvm</span><br></pre></td></tr></table></figure><blockquote><p>만약 설치 후에 nvm 커맨드가 정상적으로 동작하지 않는다면 터미널을 재시작하도록 하자.</p></blockquote><h4 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h4><p><code>ls-remote</code> 명령을 통해 원격으로 설치 가능한 Node.js 버전을 확인할 수 있으며,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls-remote | grep -i v6</span><br></pre></td></tr></table></figure><p>설치를 위한 명령을 아래와 같다. 이 경우 가장 최신의 버전을 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install node</span><br></pre></td></tr></table></figure><p>Node.js의 버전을 지정하여 설치하는 경우는 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install 6</span><br></pre></td></tr></table></figure><p>특정 프로젝트를 위해 Node.js의 버전을 변경하고자 한다면 <code>use</code> 명령을 사용하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm use 6</span><br></pre></td></tr></table></figure><p>자주 사용되는 버전은 아래와 같이 시스템의 Node.js 기본 버전으로 지정하자. 아래는 nvm으로 설치된 버전이 아닌 시스템에서 설치된 Node.js 버전을 가르킨다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm <span class="built_in">alias</span> default system</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> node</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/node</span><br></pre></td></tr></table></figure><p>현재 시스템에 설치된 버전을 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ nvm list</span><br><span class="line">         v4.8.5</span><br><span class="line">         v6.2.2</span><br><span class="line">        v6.11.5</span><br><span class="line">-&gt;       system</span><br><span class="line">default -&gt; system</span><br><span class="line">node -&gt; stable (-&gt; v6.11.5) (default)</span><br><span class="line">stable -&gt; 6.11 (-&gt; v6.11.5) (default)</span><br><span class="line">iojs -&gt; N/A (default)</span><br><span class="line">lts/* -&gt; lts/argon (-&gt; v4.8.5)</span><br><span class="line">lts/argon -&gt; v4.8.5</span><br><span class="line">lts/boron -&gt; v6.11.5</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">https://github.com/creationix/nvm</a></p></blockquote><h2 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h2><p>Yarn은 페이스북에서 개발한 향상된 Node.js의 패키지 매니저이다. 자세한 내용은 아래를 참고 하도록 한다.</p><h4 id="Install-1"><a href="#Install-1" class="headerlink" title="Install"></a>Install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm -g list | grep -i yarn</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g yarn</span><br></pre></td></tr></table></figure><h4 id="Commands-1"><a href="#Commands-1" class="headerlink" title="Commands"></a>Commands</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn init</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add --dev</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn list</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://yarnpkg.com/en/docs" target="_blank" rel="external">https://yarnpkg.com/en/docs</a></p></blockquote><h4 id="yarn을-통해-리액트-개발을-한다면-create-react-app-패키지를-사용해보자"><a href="#yarn을-통해-리액트-개발을-한다면-create-react-app-패키지를-사용해보자" class="headerlink" title="yarn을 통해 리액트 개발을 한다면 create-react-app 패키지를 사용해보자."></a>yarn을 통해 리액트 개발을 한다면 create-react-app 패키지를 사용해보자.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add create-react-app --prefix /usr/<span class="built_in">local</span></span><br><span class="line"><span class="comment"># the `create-react-app` command is now available globally:</span></span><br><span class="line">$ <span class="built_in">which</span> create-react-app</span><br><span class="line">$ /usr/<span class="built_in">local</span>/bin/create-react-app</span><br><span class="line">$ create-react-app</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ECMAScript(JavaScript)가 Ajax, JSON, jQuery가 등장함으로서 널리 사용 되어지고 우리에게 익숙해졌다면 서버의 실행 환경을 위한 Node.js의 등장으로 JavaScript는 황금기를 맞이하게 되었습니다. 이 글에서는
      
    
    </summary>
    
      <category term="nodejs" scheme="https://www.holaxprogramming.com/categories/nodejs/"/>
    
    
  </entry>
  
  <entry>
    <title>AWS CodeStar로 1인 DevOps 코스프레하기</title>
    <link href="https://www.holaxprogramming.com/2017/10/16/devops-aws-codestar/"/>
    <id>https://www.holaxprogramming.com/2017/10/16/devops-aws-codestar/</id>
    <published>2017-10-16T02:49:55.000Z</published>
    <updated>2022-06-07T00:26:22.995Z</updated>
    
    <content type="html"><![CDATA[<p>오랜전 일이지만 IDE에서 빌드한 jar, war 패키지를 직접 수동으로 배포하는 일은 개발에만 집중하고 싶은 이들에게는 괴로운 일이였죠.</p><a id="more"></a><p>여전히 IDE에서 빌드한 결과물을 수동으로 배포하는 조직도 존재하지만 반면 더욱 빠른 배포를 위해서 개발과 운영을 함께 진행하는 <code>DevOps</code> 문화를 정착시키기 위한 노력을 하는 조직도 동시에 존재합니다. 이와 같이 프로젝트를 빌드, 테스트하고 배포하는 과정을 자동화하기 위한 노력은 끊임없이 계속되 왔습니다.</p><p>지속적으로 일하는 방식을 개선하는 노력은 조직의 역량에 매우 긍정적이 영향을 미친다고 생각하는데, 이 글은 AWS CodeStar를 통해 적은 노력으로 이러한 문제를 해결 할 수 있기를 바라면서 시작합니다.</p><h2 id="남들보다-빠르게-누구보다-빠르게"><a href="#남들보다-빠르게-누구보다-빠르게" class="headerlink" title="남들보다 빠르게 누구보다 빠르게"></a>남들보다 빠르게 누구보다 빠르게</h2><p>빌드, 배포하는 과정을 자동화하는 것만으로도 우리는 퇴사하고 싶은 유혹에서 많이 벗어 날 수 있었습니다. 하지만 빌드, 배포를 자동화 만으로는 모든 것을 해결할 수는 없었죠.</p><p><img src="http://dev2ops.org/wp-content/uploads/2010/02/WallOfConfusion.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">개발자 - &quot;아주 긴급한 내역입니다! 무려 Hotfixed 라구요 배포 부탁드립니다&quot;</span><br><span class="line">인프라 운영자 - &quot;배포 요청이 너무 많은데요! 기다려주세요&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">개발자 - &quot;죄송합니다 또 수정 내역입니다! Hotfixed-2 라구요.. 배포 부탁드려요..ㅜㅜ&quot;</span><br><span class="line">인프라 운영자 - &quot;흠 방금 배포했는데..?&quot;</span><br></pre></td></tr></table></figure><p><img src="http://dev2ops.org/wp-content/uploads/2010/02/WallOfConfusion_Release.png"></p><h4 id="quot-무언가-불편하다-quot"><a href="#quot-무언가-불편하다-quot" class="headerlink" title="&quot;무언가 불편하다..&quot;"></a><code>&quot;무언가 불편하다..&quot;</code></h4><p>서비스를 운영하는 방식은 조직마다 차이가 있겠지만 개발자라면 누구나 한번쯤은 겪어 볼만한 일이죠, 하지만 이런 케이스는 아래와 같이 대부분 중요한 이슈일 경우가 많습니다. </p><blockquote><p>변화가 빠른 스타트업 조직에서의 잦은 업데이트<br>배포 후 장애 발생 시에 긴급한 재 배포</p></blockquote><p><img src="http://dev2ops.org/wp-content/uploads/2010/02/WallOfConfusion_TrainWreck.png"></p><blockquote><p>이미지 출처 - <a href="http://dev2ops.org/2010/02/what-is-devops/" target="_blank" rel="external">http://dev2ops.org/2010/02/what-is-devops/</a></p></blockquote><h4 id="quot-장애-상황을-대처하는-과정을-통해-좋은-팀을-구분할-수-있다-quot"><a href="#quot-장애-상황을-대처하는-과정을-통해-좋은-팀을-구분할-수-있다-quot" class="headerlink" title="&quot;장애 상황을 대처하는 과정을 통해 좋은 팀을 구분할 수 있다&quot;"></a><code>&quot;장애 상황을 대처하는 과정을 통해 좋은 팀을 구분할 수 있다&quot;</code></h4><p>개발자나 인프라 담당자나 서비스에 중요한 영향을 미치는 이 시기에 불필요한 행동이 나오면 안되겠죠, 특히나 장애를 대처하기 위해서는 롤백을 통한 빠른 배포가 아주 중요합니다. 최종적으로 배포하기위한 <code>버튼</code>에 대한 권한이 누구에게 있느냐에 따라 상황은 달라질 수 있습니다. </p><p>개인적으로는 인프라 운영자가 배포하는 것보다는 직접 서비스를 개발하는 개발자가 능동적으로 배포 할 수 있는 조직이 장애 대처에 효율적이였던 경험이 많습니다.</p><p>하지만 그럼에도 불구하고 개발자가 변경내역을 Git Repository에 Push 한 뒤에 배포까지 필요한 과정은 그리 간단하지는 않아보이네요.</p><h2 id="우리에게-필요한건-대략"><a href="#우리에게-필요한건-대략" class="headerlink" title="우리에게 필요한건 대략.."></a>우리에게 필요한건 대략..</h2><p><img src="https://d0.awsstatic.com/feature-illustrations/Feature_CodeStar_Develop-in-minutes.png"></p><ul><li>우리는 소중한 소스코드의 관리를 위해 Git Repository를 준비해야 합니다</li><li>Jenkins 서버를 따로 두어서 Git master 브랜치에 변경내역이 생기면 쿨하게 자동으로 테스트와 빌드를 진행 합니다</li><li>배포 준비가 완료되면 서비스를 담당하는 팀원, 인프라 운영자, 서비스 운영자에게 배포시기, 배포내용을 Notification 하는 것도 중요합니다</li><li>변경 내역을 공지하고 배포를 시작합니다! 하지만 운영환경에서는 떨리시죠? 빌드 과정에서 발생하는 로그도 자세히 살펴볼 필요가 있겠네요</li><li>성공적으로 빌드된 결과물은 항상 백업해두고 원격 서버에 전송해야 합니다</li><li>서버 애플리케이션이라면 여러 대의 서버를 동시에 운영하는 경우가 많겠죠</li><li>클라이언트 애플리케이션이라면 요구사항에 따라 패키징도 해야 합니다 </li><li>최종적으로 변경 내역이 정상적으로 작동하는지 모니터링도 필수!</li></ul><p>굴직한 부분만 나열해 보았지만 사이 사이 필요한 요소들이 더 있을 거예요. Git, Jenkins, 운영 서버등 물리적으로 관리해야 하는 공간들이 많아지고 거기다 한 곳에서 모니터링 할 수 있는 구조도 아니죠. </p><h4 id="quot-적은-인원의-개발자-혹은-개인이-개발과-운영을-동시에-하는-일은-쉽지-않아-보입니다-quot"><a href="#quot-적은-인원의-개발자-혹은-개인이-개발과-운영을-동시에-하는-일은-쉽지-않아-보입니다-quot" class="headerlink" title="&quot;적은 인원의 개발자 혹은 개인이 개발과 운영을 동시에 하는 일은 쉽지 않아 보입니다&quot;"></a><code>&quot;적은 인원의 개발자 혹은 개인이 개발과 운영을 동시에 하는 일은 쉽지 않아 보입니다&quot;</code></h4><p>하지만 다행인 사실은 현대의 운영 환경은 더이상 IDC실에 달려가 직접 인프라 환경을 구성할 필요가 없다는 것입니다. Microsoft, AWS, IBM, Google과 같은 글로벌 기업에서는 클라우드 환경을 통해 인프라를 서비스 형태로 제공하고 뿐만 아니라 인프라 구성을 자동화할 수 있도록 다양한 소프트웨어와 API를 제공하고 있습니다. </p><h4 id="quot-우리가-이렇게-축복받은-세상에-살고-있습니다-quot"><a href="#quot-우리가-이렇게-축복받은-세상에-살고-있습니다-quot" class="headerlink" title="&quot;우리가 이렇게 축복받은 세상에 살고 있습니다&quot;"></a><code>&quot;우리가 이렇게 축복받은 세상에 살고 있습니다&quot;</code></h4><p>이 글에서는 지금까지 구구절절(..) 설명한 인프라 운영에 대한 문제를 AWS의 CodeStar라는 서비스를 중심으로 설명합니다.</p><h2 id="AWS-CodeStar"><a href="#AWS-CodeStar" class="headerlink" title="AWS CodeStar"></a>AWS CodeStar</h2><p>개발 초기부터 <code>서버 구성, 빌드, 배포</code>하는 과정에서 반복적으로 발생하는 스트레스에서 벗어나고 싶었습니다. 배포 환경은 AWS의 EC2, 빌드 서버는 Jenkins가 중심인 전통적인 프로세스를 준비하다가 위와 같이 배보다 배꼽이 커지는 상황에 고민에 빠지게 되었는데, 때마침 최근에 AWS에서 CodeStar라는 프로젝트의 서버 구성, 빌드, 배포, 모니터링을 위한 통합 서비스를 발표해서 개이득!을 외치며 살펴 볼 수 있었습니다.</p><p>CodeStar는 서비스 운영에 필요한 컨테이너 생성부터 소스코드 관리, 빌드, 배포, 모니터링을 위한 다양한 서비스를 한 곳에서 쉽게 관리 할 수 있는 서비스라고 보면 됩니다. 우리가 위에서 고민했던 많은 문제들을 해결 할 수 있겠네요.</p><p><img src="http://image.toast.com/aaaaahq/aws-code-star.png"></p><h4 id="이런-분들이-사용하면-좋다고-하네요"><a href="#이런-분들이-사용하면-좋다고-하네요" class="headerlink" title="이런 분들이 사용하면 좋다고 하네요"></a>이런 분들이 사용하면 좋다고 하네요</h4><ul><li>배포 환경의 서버 인프라 구성을 자동화하고자 하는 분</li><li>아직도 IDE에서 빌드한 Jar 파일을 이용하시는 분</li><li>빌드 결과물을 생성하기 위해 Jenkins 서버를 따로 운영하는게 번거로우신 분</li><li>빌드를 위한 운영 비용을 획기적으로 줄이고 싶으신 분들</li><li>Travis CI와 같은 호스트 CI서버로 이동하고 싶은데 조직의 승인이 까다로운 분</li><li>조직에서 외부 서비스를 통해 빌드 프로세스를 진행 하는 것을 꺼린다면, AWS 안에서 빌드하는 것은 어떠세요?</li></ul><h4 id="이슈-관리도-가능"><a href="#이슈-관리도-가능" class="headerlink" title="이슈 관리도 가능"></a>이슈 관리도 가능</h4><p>뿐만 아니라 CodeStar에서는 프로젝트에 관련된 팀원을 관리하고 이슈 트래킹을 위해 JIRA와 연동하는 기능까지 제공함으로써 개발 프로세스 전반에 영향을 미치고 싶어하는 모습을 강력히 나타내고 있는데요, 아래의 그림을 보시면 쉽게 이해가 가능합니다. 그럼 CodeStar를 통해서 프로젝트를 생성하고 배포하는 과정까지 필요한 요소들을 살펴 볼까요?</p><p><img src="https://media.amazonwebservices.com/blog/2017/codestar_adh_proj_workflow_1.png"></p><h2 id="프로젝트를-생성"><a href="#프로젝트를-생성" class="headerlink" title="프로젝트를 생성"></a>프로젝트를 생성</h2><p>AWS CodeStar는 효율적으로 DevOps를 실현하기 위해 다양한 AWS의 서비스를 묶어 이들의 대시보드를 제공하는 형태입니다. CodeStar에서 프로젝트를 생성하는 의미는 CodeStar의 하위 서비스를 통해 프로젝트에 필요한 Git Repository와 서버 인프라를 만드는 것과 같습니다.</p><h4 id="EC2-or-Elastic-Beanstalk"><a href="#EC2-or-Elastic-Beanstalk" class="headerlink" title="EC2 or Elastic Beanstalk"></a>EC2 or Elastic Beanstalk</h4><p>CodeStar에서는 EC2 뿐만 아니라 Elastic Beanstalk를 통해 <code>Java, .NET, PHP, Node.js, Python, Ruby, Go, Docker</code>를 사용하여 Apache, Nginx, Passenger, IIS와 같은 친숙한 서버에서 개발된 웹 애플리케이션 및 서비스를 간편하게 배포하고 확장할 수 있는 서비스를 제공합니다.</p><p>코드를 업로드하기만 하면 Elastic Beanstalk가 용량 프로비저닝, 로드 밸런싱, 자동 크기 조정부터 시작하여 애플리케이션 상태 모니터링에 이르기까지 배포를 자동으로 처리합니다. 이뿐만 아니라 애플리케이션을 실행하는 데 필요한 AWS 리소스를 완벽하게 제어할 수 있으며 언제든지 기본 리소스에 액세스할 수 있습니다.</p><h4 id="CodeCommit"><a href="#CodeCommit" class="headerlink" title="CodeCommit"></a>CodeCommit</h4><p>AWS CodeCommit은 안전하고 확장성이 뛰어난 프라이빗 Git 리포지토리를 쉽게 호스팅할 수 있도록 지원하는 완전 관리형 소스 제어 서비스입니다. CodeCommit를 사용하면 자체 소스 제어 시스템을 운영하거나 인프라 조정을 염려할 필요가 없습니다. CodeCommit을 사용하면 소스 코드에서 바이너리까지 모든 것을 안전하게 저장할 수 있고 기존 Git 도구와 원활하게 연동됩니다.</p><h2 id="빌드"><a href="#빌드" class="headerlink" title="빌드"></a>빌드</h2><h4 id="CodeBuild"><a href="#CodeBuild" class="headerlink" title="CodeBuild"></a>CodeBuild</h4><p>CodeBuild는 소스 코드를 컴파일하는 단계부터 테스트 실행 후 소프트웨어 패키지를 개발하여 배포하는 단계까지 마칠 수 있는 완전관리형 빌드 서비스입니다. CodeBuild를 사용하면 자체 빌드 서버를 프로비저닝, 관리 및 확장할 필요가 없습니다. CodeBuild는 지속적으로 확장되며 여러 빌드를 동시에 처리하기 때문에 빌드가 대기열에서 대기하지 않습니다. 사전 패키징된 빌드 환경을 사용하면 신속하게 시작할 수 있으며 혹은 자체 빌드 도구를 사용하는 사용자 지정 빌드 환경을 만들 수 있습니다. CodeBuild에서는 컴퓨팅 리소스를 사용하는 시간(분) 단위로 비용이 청구됩니다.</p><p><img src="https://s3.amazonaws.com/apnblog/2016+Blog+Images/Stelligent+Guest+Post/Updates/rsz_figure_3_.png" width="500"></p><h2 id="배포"><a href="#배포" class="headerlink" title="배포"></a>배포</h2><p>코드 변경이 있을 때마다 사용자가 정의한 릴리스 프로세스 모델에 따라 코드를 빌드, 테스트 및 배포하는 서비스인 AWS CodePipeline을 사용합니다.</p><h4 id="CodePipeline"><a href="#CodePipeline" class="headerlink" title="CodePipeline"></a>CodePipeline</h4><p>Source 저장소에 변경내역을 감지하는 것을 시작으로 배포하기 까지의 일련의 흐름을 CodePipeline을 통해 관리합니다.</p><p>CodePipeline은 애플리케이션를 짧은 주기로 지속적으로 통합하고 전달할 수 있도록 도와줍니다. CodePipeline은 사용자가 정의하는 출시 프로세스 모델에 따라 코드 변경이 있을 때마다 코드를 구축, 테스트 및 배포합니다. 따라서 기능과 업데이트를 신속하고 안정적으로 제공할 수 있습니다.</p><p><img src="https://s3.amazonaws.com/apnblog/2016+Blog+Images/Stelligent+Guest+Post/Updates/figure_1"></p><h4 id="지속적-전달-Continuous-Delivery"><a href="#지속적-전달-Continuous-Delivery" class="headerlink" title="지속적 전달(Continuous Delivery)"></a>지속적 전달(Continuous Delivery)</h4><p><img src="https://d0.awsstatic.com/Projects/CICD%20Pipeline/setup-cicd-pipeline2.png"></p><p><code>지속적 전달</code>은 프로덕션에 릴리스할 수 있도록 코드 변경이 자동으로 빌드, 테스트 및 준비되는 데브옵스 소프트웨어 개발 방식입니다. 빌드 단계 이후의 모든 코드 변경을 테스트 환경 및/또는 프로덕션 환경에 배포함으로써 지속적 통합을 확장합니다. 지속적 전달이 적절하게 구현되면, 개발자는 언제나 즉시 배포할 수 있고 표준화된 테스트 프로세스를 통과한 빌드 아티팩트를 보유하게 됩니다. </p><p>지속적 전달에서는 모든 코드 변경이 빌드 및 테스트된 후, 비프로덕션 테스트 또는 스테이징 환경으로 푸시됩니다. 프로덕션 배포 전에 여러 개의 병렬 테스트 단계가 있을 수 있습니다. 마지막 단계에서 준비가 완료되면 개발자가 프로덕션으로의 업데이트를 승인합니다. 이 부분이 프로덕션으로의 푸시가 명시적인 승인 없이 자동으로 수행되는 지속적 배포와 다른 점입니다.</p><p>지속적 전달에서는 개발자가 단순한 유닛 테스트 외에도 다양한 테스트를 자동화할 수 있으므로, 고객에게 배포하기 전에 여러 차원에서 애플리케이션 업데이트를 확인할 수 있습니다. 이러한 테스트에는 UI 테스트, 로드 테스트, 통합 테스트, API 안정성 테스트 등이 포함될 수 있습니다. 이를 통해 개발자는 업데이트를 좀 더 철저히 검증하고 문제를 사전에 발견할 수 있습니다. 온프레미스에서는 힘들었지만, 클라우드에서는 테스트용으로 여러 개의 환경을 생성하고 복제하는 작업을 비용 효율적으로 손쉽게 자동화할 수 있습니다.</p><h2 id="모니터링"><a href="#모니터링" class="headerlink" title="모니터링"></a>모니터링</h2><p>CodeStar의 콘솔에서는 모니터링을 위한 UI를 제공합니다. </p><p><img src="https://d0.awsstatic.com/Projects/V445874/arch-diagram_nodejs-app.png"></p><h4 id="CloudWatch"><a href="#CloudWatch" class="headerlink" title="CloudWatch"></a>CloudWatch</h4><p>CloudWatch를 사용하여 지표를 수집 및 추적하고, 로그 파일을 수집 및 모니터링하며, 경보를 설정하고, AWS 리소스 변경에 자동으로 대응할 수 있습니다. Amazon <code>EC2 Instance</code>, <code>Amazon DynamoDB</code> 테이블, Amazon RDS DB 인스턴스 같은 AWS 리소스뿐만 아니라 애플리케이션과 서비스에서 생성된 사용자 정의 지표 및 애플리케이션에서 생성된 모든 로그 파일을 모니터링할 수 있습니다. Amazon CloudWatch를 사용하여 시스템 전반의 리소스 사용률, 애플리케이션 성능, 운영 상태를 파악할 수 있습니다. 이러한 통찰력을 사용하여 문제에 적절히 대응하고 애플리케이션 실행을 원활하게 유지할 수 있습니다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>조직의 규모를 떠나서 애플리케이션의 변경 내역을 빠르고 안정적으로 배포하는 것은 점점 중요해지고 있습니다. 하지만 이를 위해 시스템을 준비하고 지속적으로 개선하는 것은 쉬운일이 아닙니다. </p><p>AWS의 CodeStar는 기존의 효율적인 시스템을 묶어 소스코드 관리부터 배포, 모니터링까지의 파이프라인을 손쉽게 구축하도록 제공하고 있습니다. 1인 개발자나 작은 조직에서 DevOps에 투자하는 비용이 부담이 된다면 이 글을 통해 조금이라도 도움이 되기를 바랍니다.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://aws.amazon.com/ko/blogs/apn/an-introduction-to-aws-codebuild/" target="_blank" rel="external">https://aws.amazon.com/ko/blogs/apn/an-introduction-to-aws-codebuild/</a></li><li><a href="https://aws.amazon.com/ko/codestar/" target="_blank" rel="external">https://aws.amazon.com/ko/codestar/</a></li><li><a href="https://aws.amazon.com/ko/devops/continuous-delivery/" target="_blank" rel="external">https://aws.amazon.com/ko/devops/continuous-delivery/</a></li><li><a href="https://aws.amazon.com/ko/blogs/aws/new-aws-codestar/" target="_blank" rel="external">https://aws.amazon.com/ko/blogs/aws/new-aws-codestar/</a></li><li><a href="https://www.slideshare.net/awskr/ansible-cloudformation" target="_blank" rel="external">https://www.slideshare.net/awskr/ansible-cloudformation</a></li><li><a href="https://www.slideshare.net/awskorea/aws-code-star-devops" target="_blank" rel="external">https://www.slideshare.net/awskorea/aws-code-star-devops</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;오랜전 일이지만 IDE에서 빌드한 jar, war 패키지를 직접 수동으로 배포하는 일은 개발에만 집중하고 싶은 이들에게는 괴로운 일이였죠.&lt;/p&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.holaxprogramming.com/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 시스템 운영 중 알아두면 쓸모 있는 지식들</title>
    <link href="https://www.holaxprogramming.com/2017/10/09/java-jvm-performance/"/>
    <id>https://www.holaxprogramming.com/2017/10/09/java-jvm-performance/</id>
    <published>2017-10-08T15:49:31.000Z</published>
    <updated>2022-06-07T00:26:23.012Z</updated>
    
    <content type="html"><![CDATA[<p>Java 기반의 서버 애플리케이션은 운영 중에 아래와 같은 메세지와 함께 장애로 이어지는 결과가 일어나곤 합니다.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java.lang.OutOfMemoryError: Permgen space</span><br></pre></td></tr></table></figure><p>Java 기반의 애플리케이션의 메모리는 운영체제의 JVM에서 관리하기 때문에 최악의 효율이 발생한다면 Full GC로 인해 애플리케이션이 멈추는 Stop The World 현상에서 자유로울 수 없습니다.</p><p>이렇게 우리가 운영하고 있는 서비스는 하루에도 몇 번씩 GC가 발생하고 있고, 이런 상황에서 시스템 이슈로 인한 장애 알람을 받지 않아도 우리의 생각과는 다르게 사용자에게 <code>503(Service Unavailable)</code> 오류가 반환되고 있을지도 모르는 일입니다.</p><p>이 글에서는 Java 시스템을 운영 중 문제가 발생할 때 기본적으로 알아두어야할 내용을 다룹니다.</p><h2 id="프로세스와-쓰레드"><a href="#프로세스와-쓰레드" class="headerlink" title="프로세스와 쓰레드"></a>프로세스와 쓰레드</h2><p>웹 애플리케이션은 일반적인 경우에는 처리량을 극대화하는 것보다는 많은 사용자에게 지연 시간을 최대한 줄이면서 안정적인 서비스를 제공하는 것이 중요하다.</p><p>좋은 시스템은 이와 같이 어떻게 서비스의 특징에 맞게 컴퓨터의 자원을 효율적으로 사용하는지에 대한 고민으로 시작된다.</p><p>우리가 알다시피 운영체제는 컴퓨터의 자원을 여러 프로세스가 효율적으로 사용할 수 있도록 도와준다. 예를 들면 웹 애플리케이션을 효율적으로 운영하기 위해 Apache, Tomcat를 사용한다고 가정해보자. Apache, Tomcat 역시 운영체제로부터 프로세스를 할당받아 컴퓨터의 자원을 사용하고 애플리케이션 내부에서는 프로세스의 자원을 활용해 쓰레드를 생성한다.</p><p>이것은 운영체제에서 서버 애플리케이션을 효율적으로 운영하기위해서는 먼저 Apache, Tomcat의 특성을 파악해야하는 것을 의미한다.</p><h4 id="Apache는-정적-리소스를-효율적으로-제공한다"><a href="#Apache는-정적-리소스를-효율적으로-제공한다" class="headerlink" title="Apache는 정적 리소스를 효율적으로 제공한다"></a>Apache는 정적 리소스를 효율적으로 제공한다</h4><p>웹 애플리케이션을 구성하면서 이미지나 HTML 페이지와 같은 <code>정적(static)</code> 리소스를 Tomcat과 같은 WAS에서 모두 제공할 수도 있지만 정적 리소스는 Apache를 통해 관리하는 것이 유리하다.</p><ul><li>Tomcat은 정적 페이지에 대해 Apache만큼 빠르지 못하다.</li><li>Tomcat은 Apache 만큼 Reverse Proxy 서버를 구성하기 위한 다양한 설정을 제공하지 않는다.</li></ul><p>그럼 Apache를 통해 얻을 수 있는 유리한 점들을 더 살펴보도록 하자.</p><h4 id="Apache와-프로세스"><a href="#Apache와-프로세스" class="headerlink" title="Apache와 프로세스"></a>Apache와 프로세스</h4><p>웹서버 성능에 가장 큰 영향을 주는 것은 메모리다. 스왑은 요청당 지연시간을 늘리기 때문에 웹서버는 스왑을 하면 안된다. 지연시간이 늘어나면 사용자는 정지하고 다시 접속하면 접차 부하가 계속 증가한다. Apache에서는 MaxClients 지시어를 조절하여 웹서버가 스왑을 할 정도로 많은 자식을 만들지않도록 해야 한다.</p><p>MaxClients의 이상적인 값을 찾는 방법은 간단하다, 리눅스의 top과 같은 도구에서 프로세스 목록을 보고 아파치 프로세스의 평균 메모리 사용량을 알아낸 후 전체 사용가능한 메모리에서 다른 프로세스들이 사용할 공간을 뺀 값에서 나눈다.</p><blockquote><p>모든 설정값은 이와 같이 이론적으로 판단할 수 있지만 정답이라는 것은 없다. 최적화를 위해서는 꼭 성능테스트를 동반하여야 한다.</p></blockquote><p>나머지는 평범하다. 충분히 빠른 CPU, 충분히 빠른 네트워크 카드, 충분히 빠른 디스크, 여기서 <code>충분히 빠른</code>이란 의미는 실험을 통해 결정해야 한다. 운영체제는 보통 각자 알아서 선택할 일이지만 일반적으로 유용하다고 판명된 몇가지 지침은 아래와 같다.</p><ul><li>선택한 운영체제의 최신 안정 버전과 패치를 실행한다. 많은 운영체제 제작사는 최근 TCP 스택과 쓰레드 라이브러리에 많은 속도향상을 했다.</li><li>클라이언트와 서버에 쓰이는 CPU와 메모리 모두 성능이 과거와는 비교할 수 없을 정도로 매우 좋아졌다.</li></ul><p><code>Keep-Alive</code>를 사용한다면 자식들은 이미 열린 연결에서 추가 요청을 기다리며 아무것도 하지않기 때문에 계속 바쁘다. KeepAliveTimeout의 기본값 15초는 이런 현상을 최소화한다. 네트워크 대역폭과 서버 자원 간의 균형이 맞게 설정한다. 연결유지의 대부분의 이점이 사라지기때문에 어떤 경우에도 이 값을 60 초 이상으로 올리지 마라.</p><h4 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h4><p>앞서 말한 <code>Keep-Alive</code>를 활용하는 예를 설명하자면 HTTPS를 들 수 있다.</p><p><code>HTTPS의 암호화 비용</code></p><p>웹 애플리케이션에서 클라이언트 서버간에 주고 받는 메세지를 보호하기 위해서는 암호화 과정이 필요하다. HTTP는 외부의 공격이나 스니핑에 매우 취약한 프로토콜이기 때문이다. 암호화는 위해서는 HTTP에 TLS 레이어를 입힌 HTTPS 프로토콜을 일반적으로 사용한다.</p><p>하지만 암호화를 위해서는 클라이언트와 서버간에 암호화 알고리즘과 키를 교환하는 <code>handshake</code> 과정이 필요하다. 거기다 HTTPS 인증서를 검증하는 Online Certificate Status Protocol를 통해 인증서 및 인증 기관이 유효한지도 판단한다.</p><p><img src="https://i.stack.imgur.com/Rcq1a.png"></p><blockquote><p><a href="https://tech.ssut.me/2017/05/07/https-is-faster-than-http/" target="_blank" rel="external">https://tech.ssut.me/2017/05/07/https-is-faster-than-http/</a></p></blockquote><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/450px-HTTP_persistent_connection.svg.png"></p><p>매 요청마다 이런 handshake를 진행하고 비용이 큰 RSA 알고리즘을 통해 통신을 한다면 서버와 클라이언트 모두 큰 부하가 발생할 수 밖에 없다. 다행인 점은 위 과정이 모두 마친 후의 실제 데이터 통신은 대칭키로 암호화하여 진행된다는 점이다, 여기에 Keep-Alive를 이용하면 세션이 유지될테니 암호화 비용은 줄어 들게 된다.</p><p><code>예) httpd.conf 에서의 Keep-Alive 설정</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># KeepAlive: Whether or not to allow persistent connections (more than</span><br><span class="line"># one request per connection). Set to &quot;Off&quot; to deactivate.</span><br><span class="line">KeepAlive On</span><br><span class="line"></span><br><span class="line"># MaxKeepAliveRequests: The maximum number of requests to allow</span><br><span class="line"># during a persistent connection. Set to 0 to allow an unlimited amount.</span><br><span class="line"># We recommend you leave this number high, for maximum performance.</span><br><span class="line">MaxKeepAliveRequests 100</span><br><span class="line"></span><br><span class="line"># KeepAliveTimeout: Number of seconds to wait for the next request from the</span><br><span class="line"># same client on the same connection.</span><br><span class="line">KeepAliveTimeout 15</span><br></pre></td></tr></table></figure><h4 id="CPU와-메모리-모두-성능이-과거와는-비교할-수-없을-정도로-매우-좋아졌다"><a href="#CPU와-메모리-모두-성능이-과거와는-비교할-수-없을-정도로-매우-좋아졌다" class="headerlink" title="CPU와 메모리 모두 성능이 과거와는 비교할 수 없을 정도로 매우 좋아졌다"></a>CPU와 메모리 모두 성능이 과거와는 비교할 수 없을 정도로 매우 좋아졌다</h4><p>HTTPS 암호화에 쓰이는 TLS는 크게 변한 것이 없는데 반해, 클라이언트와 서버에 쓰이는 CPU와 메모리 모두 성능이 과거와는 비교할 수 없을 정도로 매우 좋아졌다. HTTPS가 HTTP보다 느리다는 논쟁은 앞으로 무의미할 것으로 보인다.</p><h2 id="Tomcat-인스턴스의-구성"><a href="#Tomcat-인스턴스의-구성" class="headerlink" title="Tomcat 인스턴스의 구성"></a>Tomcat 인스턴스의 구성</h2><p>웹 애플리케이션은 스케일-업보다는 <code>스케일-아웃</code>하기 적합한 구조적인 특성을 가지고 있어 장비의 성능에 따라 한 대의 물리적인 장비에 한 개의 Apache 서버와 여러 개의 Tomcat 인스턴스를 구성하는 것이 일반적이였다.</p><p><img src="http://static.richardnichols.net/wp-content/uploads/2010/08/Tomcat-cluster-diagram.png"></p><p>주로 읽기 전용인 환경에 있어서 처리 능력 향상과 가용성의 증대라는 이점도 있다. 이는 하나의 서버가 장애를 일으켜도 다른 서버로 즉시 처리를 할 수 있는 로드 밸런싱을 의미한다.</p><blockquote><p>스케일 아웃은 개개의 처리는 비교적 단순하지만 다수의 처리를 동시 병행적으로 실시하지 않으면 안 되는 경우에 적합한데 갱신 데이터의 정합성 유지에 대한 요건이 별로 어렵지 않은 경우에 적절하다</p></blockquote><h4 id="Tomcat-인스턴스-설정하기"><a href="#Tomcat-인스턴스-설정하기" class="headerlink" title="Tomcat 인스턴스 설정하기"></a>Tomcat 인스턴스 설정하기</h4><p><code>인스턴스별 배포경로 및 로그파일 저장경로</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p /home/jungminhyuck/deploy/application</span><br><span class="line">$ mkdir -p /home/jungminhyuck/logs/application</span><br></pre></td></tr></table></figure></p><p><code>/scripts/application-tomcat-configurations.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class="line">&lt;Server port=&quot;8119&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;off&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JasperListener&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Service name=&quot;application&quot;&gt;</span><br><span class="line">    &lt;Connector port=&quot;8219&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8419&quot; enableLookups=&quot;false&quot; connectionTimeout=&quot;5000&quot; maxThreads=&quot;5&quot; /&gt;</span><br><span class="line">    &lt;Connector port=&quot;8019&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8319&quot; URIEncoding=&quot;UTF-8&quot; enableLookups=&quot;false&quot; connectionTimeout=&quot;5000&quot; maxThreads=&quot;2048&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</span><br><span class="line">      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt;</span><br><span class="line">            &lt;Context docBase=&quot;/home1/jungminhyuck/deploy/application/&quot; path=&quot;&quot; reloadable=&quot;false&quot; /&gt;</span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure><p><code>/scripts/start-up-tomcat.sh</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">XML=<span class="string">"/home1/jungminhyuck/scripts/application-tomcat-configurations.xml"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LC_ALL=<span class="string">"en_US.utf8"</span></span><br><span class="line"><span class="built_in">export</span> LANG=<span class="string">"en_US.utf8"</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">"/home1/jungminhyuck/apps/jdk"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_HOME=<span class="string">"/home1/jungminhyuck/apps/tomcat"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_BASE=<span class="string">"/home1/jungminhyuck/apps/tomcat"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_TMPDIR=<span class="string">"/home1/jungminhyuck/apps/tomcat/temp"</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="string">"/home1/jungminhyuck/apps/tomcat/bin/bootstrap.jar"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_LOG=<span class="string">"/home1/jungminhyuck/logs/application/catalina.log"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OUT=<span class="string">"/home1/jungminhyuck/logs/application/catalina.log"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;CATALINA_BASE&#125;</span>/bin/startup.sh -config <span class="variable">$&#123;XML&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>CATALINA_BASE/bin/setenv.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -Djava.awt.headless=true -server"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -Xmx2048m –Xms2048m"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -XX:NewSize=768m -XX:MaxNewSize=768m"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -XX:PermSize=128m -XX:MaxPermSize=256m"</span></span><br><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -XX:+DisableExplicitGC -XX:ParallelGCThreads=2 -XX:-UseConcMarkSweepGC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for application specific parameters at startup</span></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$CATALINA_BASE</span>/bin/appenv.sh"</span> ]; <span class="keyword">then</span></span><br><span class="line">  . <span class="string">"<span class="variable">$CATALINA_BASE</span>/bin/appenv.sh"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>CATALINA_BASE/bin/appenv.sh</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CATALINA_OPTS=<span class="string">"<span class="variable">$CATALINA_OPTS</span> -Dspring.profiles.active=dev"</span></span><br></pre></td></tr></table></figure></p><h4 id="Tomcat의-애플리케이션의-maxThread는-어떤-기준으로-정의해야-하나"><a href="#Tomcat의-애플리케이션의-maxThread는-어떤-기준으로-정의해야-하나" class="headerlink" title="Tomcat의 애플리케이션의 maxThread는 어떤 기준으로 정의해야 하나?"></a>Tomcat의 애플리케이션의 maxThread는 어떤 기준으로 정의해야 하나?</h4><p><code>maxThread</code>는 Tomcat이 요청을 처리하기 위해 만들어내는 최대 Thread 개수를 의미한다. Tomcat과 같은 WAS는 설정해야 하는 값이 굉장히 많지만 그 중 가장 성능에 많은 영향을 주는 부분은 maxThread와 같이 Thread Pool에 직접적으로 연관된 설정일 것이다.</p><p>Thread Pool에 대한 설정은 메모리를 얼마나 할당할 것인가와 관련이 있기 때문에 Thread를 수를 많이 사용할 수록 메모리를 많이 점유하게 된다. 그렇다고 반대로 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기하는 상황이 생길수 있다.</p><h4 id="웹-애플리케이션은-외부의-어떤-시스템과-연관되어-있나"><a href="#웹-애플리케이션은-외부의-어떤-시스템과-연관되어-있나" class="headerlink" title="웹 애플리케이션은 외부의 어떤 시스템과 연관되어 있나?"></a>웹 애플리케이션은 외부의 어떤 시스템과 연관되어 있나?</h4><p>Tomcat의 maxThread 개수를 위해 고려할 점은 웹 애플리케이션과 연관되는 시스템도 고려할 필요가 있다. 예를 들면 실제 운영 중인 서비스에서 DB 커넥션값이 200에 가까운 수치가 설정되어 있어 문제가 발생된 경우를 보았다. 무엇보다 WAS의 maxThread의 개수는 DB 커넥션 풀의 개수에 비해 적게 설정 되어 있었는데 이는 효율적이지 못하다.</p><p>그 이유는 애플리케이션에 대한 모든 요청이 DB에 접근하는 것은 아니기 때문이다. WAS의 maxThread는 DB 커넥션 수보다 여유있게 설정하는 것이 좋다.</p><h4 id="전환하기"><a href="#전환하기" class="headerlink" title="전환하기"></a>전환하기</h4><p>지금까지의 과정을 통해 우리는 다수의 Tomcat 인스턴스를 운영하기 위한 준비를 마쳤다. 하지만 앞으로 생각해보아야 할 문제가 더욱 중요하다.</p><p><img src="http://bpimediagroup.com/blog/wp-content/uploads/2017/01/Why-.jpg" width="500"></p><h2 id="정말로-한-Box에서-다수의-Tomcat-인스턴스를-구성하는-것이-효율적일까"><a href="#정말로-한-Box에서-다수의-Tomcat-인스턴스를-구성하는-것이-효율적일까" class="headerlink" title="정말로 한 Box에서 다수의 Tomcat 인스턴스를 구성하는 것이 효율적일까?"></a>정말로 한 Box에서 다수의 Tomcat 인스턴스를 구성하는 것이 효율적일까?</h2><p>우리는 지금까지 다수의 Tomcat 인스턴스를 통해 컴퓨터의 자원을 효율적으로 사용하고 가용성의 측면에서 이득을 본다고 했지만 안정적인 시스템을 위한 설계는 컴퓨터의 자원과 운영체제에 따라 언제든지 달라질 수 있다.</p><p>이보다는 다수의 장비를 운용하면서 한 Box에서 하나의 인스턴스를 운영하는 것이 대게 성능이 좋은 경우가 많은데 이는 운영체제에서 CPU의 자원을 각 프로세스에 Scheduling 정책에 따라서 할당하기 때문이다. </p><p>거기다 Tomcat의 인스턴스를 다수를 운영할 때에는 한 장비에서 수용할 수 있는 <code>maxThread</code> 설정을 분산해야하는 등 고려해야할 일이 많아지는 것도 단점이다.</p><p>덧붙히면 이 이슈는 마이크로 서비스 아키텍쳐에서는 논쟁 거리가 될만하다. 지난 몇 년동안 많은 개발자들이 거대한 시스템을 작은 마이크로 단위로 옮기는 노력을 해왔기 때문이다. </p><p>거기다 JVM과 컴퓨터의 성능은 점점 향상되고 있다는 것이다. G1 GC가 안정적으로 작동하는 지금은 한 장비에서 4GB 이하로 자원을 나누어 다수의 Tomcat 인스턴스를 운영하는 것은 재고할만 하다.</p><blockquote><p><a href="http://openjdk.java.net/jeps/156" target="_blank" rel="external">http://openjdk.java.net/jeps/156</a></p></blockquote><p>물론 정답이라는 것은 없으며 최적화를 위해서는 꼭 성능테스트를 동반하여야 한다.</p><h2 id="컴퓨터-자원과-운영체제에-따라-달라지는-GC-성능"><a href="#컴퓨터-자원과-운영체제에-따라-달라지는-GC-성능" class="headerlink" title="컴퓨터 자원과 운영체제에 따라 달라지는 GC 성능"></a>컴퓨터 자원과 운영체제에 따라 달라지는 GC 성능</h2><p>Tomcat의 인스턴스 개수를 정하여 효율적으로 컴퓨터의 자원을 활용하기 위해서는 CPU의 코어의 개수, 운영체제가 32bit인지 64bit인지, JVM에서는 어떤 Garbage Collector를 사용하는지에 따라 달라질 수 있기 때문에 단순하게 접근하기는 힘들다고 볼 수 있다.</p><p><code>CPU 코어의 수</code></p><p>보통 하나의 인스턴스를 운용하는데 1개 정도의 CPU를 사용하는게 최적화된 환경이다. 예를 들면 2CPU 머신의 경우 2개의 Tomcat 인스턴스가 적정하다. CPU 수보다 많은 인스턴스를 사용할 경우에는 각각의 인스턴스에 CPU가 배정 되는 시간이 느려지기 때문에 성능 저하로 이어질 가능성이 높다.</p><p><code>메모리의 크기, 운영체제의 비트 체계</code></p><p>64bit JVM은 32bit보다 30~40%의 Heap을 더 사용한다. 따라서 더 많은 메모리 할당이 필요하고, GC할 때 더 많은 시간이 걸린다. 하지만 32bit의 JVM은 아래와 같은 제약사항을 가진다.</p><table><thead><tr><th>운영체제</th><th>제약사항</th></tr></thead><tbody><tr><td>리눅스</td><td>최대 2GB Heap, hugemem 커널의 경우 3GB</td></tr><tr><td>윈도우</td><td>최대 1.5GB Heap</td></tr><tr><td>Mac OS X</td><td>3.8GB</td></tr></tbody></table><p>G1 GC를 제외한 GC에서는 JVM Heap을 무한정 늘리면 Full GC 시간 증가로 인해 오히려 성능 병목이 될 수 있다. 32bit JVM을 사용하고 2-4GB 이하의 Heap 설정을 사용하는게 나을 수 있다. JVM의 Heap을 증가시키기 보다는 JVM의 인스턴스를 늘려 클러스터링이나 로드밸런서로 가용성을 확보하는 방법을 권장한다.</p><p><code>32bit의 운영체제에서 2GB의 메모리를 활용하는 JVM의 권장 Option</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.awt.headless=true -server -Xmx1024m –Xms1024m -XX:NewSize=384m -XX:MaxNewSize=384m -XX:MaxPermSize=128m</span><br></pre></td></tr></table></figure><p><code>JVM의 Garbage Collector</code></p><p>JVM에서 어떤 GC를 사용할 것인지, 즉 GC 알고리즘에 따라 성능이 결정되기도 한다.</p><h4 id="quot-그렇다면-어떤-컴퓨팅-환경과-JVM의-Garbage-Collector에-따라서-전략이-달라질까-quot"><a href="#quot-그렇다면-어떤-컴퓨팅-환경과-JVM의-Garbage-Collector에-따라서-전략이-달라질까-quot" class="headerlink" title="&quot;그렇다면 어떤 컴퓨팅 환경과 JVM의 Garbage Collector에 따라서 전략이 달라질까?&quot;"></a><code>&quot;그렇다면 어떤 컴퓨팅 환경과 JVM의 Garbage Collector에 따라서 전략이 달라질까?&quot;</code></h4><p>우리가 GC에 대해 이야기할 때, 우리 대부분은 그 개념을 알고 있으며 우리의 일상적인 프로그래밍에 그것을 사용하고 있다. 그럼에도 불구하고, 우리가 이해할 수 없는 일이 발생한다. JVM에 대한 가장 큰 오해 중 하나는 하나의 GC를 보유하고 있다는 점인데 그렇지 않다.</p><p>아래에서는 각각 고유한 장점과 단점이 있는 네개의 서로 다른 Garbage Collector를 살펴보도록 하겠다.</p><h2 id="JVM의-다양한-Garbage-Collector"><a href="#JVM의-다양한-Garbage-Collector" class="headerlink" title="JVM의 다양한 Garbage Collector"></a>JVM의 다양한 Garbage Collector</h2><p><img src="http://384uqqh5pka2ma24ild282mv.wpengine.netdna-cdn.com/wp-content/uploads/2014/09/Blog_Trash-1.jpg"></p><blockquote><p><a href="http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/" target="_blank" rel="external">http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/</a></p></blockquote><p>JDK 7부터 본격적으로 사용할 수 있는 G1 GC를 제외한, Oracle JVM에서 제공하는 모든 GC는 Generational GC이다. 즉 객체는 처음 생성되면 Eden(Young) 영역으로 들어간다. <code>Minor GC</code>가 일어나면 Eden, From 있는 객체 중 살아있는 객체를 To 영역으로 복사하고 나머지는 해제한다. 이러한 과정을 반복적으로 수행하다가 From, To 영역에서 오래된 객체들은 Old 영역으로 옮겨진다. 이러한 GC 알고리즘을 Copy &amp; Scavenge 라고 하며 속도가 빠르다.</p><p>Old 영역에서 일어나는 ‘Major GC’는 Full GC 라고도 하는데, JVM에서 Full GC가 일어나면 모든 Thread가 멈추는 Stop the world 현상이 벌어진다. Full GC는 전체 객체들의 참조를 확인하면서 사용되지 않는 객체를 표시하여 삭제한다. 메모리 영역에 대한 compact가 필요하여 속도가 매우 느리다. 이렇게 활용되는 GC 알고리즘은 Mark &amp; Compact 이라고 한다.</p><p>JVM을 튜닝한다는 의미는 Old 영역으로 넘어가는 객체의 수를 최소화하는 것과 Full GC의 실행 시간을 줄이는 노력이다.</p><p><code>Old 영역으로 넘어가는 객체의 수 최소화하기</code></p><p> 즉, Eden 영역에서 객체가 처음 만들어지고, Survivor 영역을 오가다가, 끝까지 남아 있는 객체는 Old 영역으로 이동한다. 간혹 Eden 영역에서 만들어지다가 크기가 커져서 Old 영역으로 바로 넘어가는 객체도 있긴 하다. Old 영역의 GC는 New 영역의 GC에 비하여 상대적으로 시간이 오래 소요되기 때문에 Old 영역으로 이동하는 객체의 수를 줄이면 Full GC가 발생하는 빈도를 많이 줄일 수 있다. Old 영역으로 넘어가는 객체의 수를 줄인다는 말을 잘못 이해하면 객체를 마음대로 New 영역에만 남길 수 있다고 생각할 수 있지만, 그렇게는 할 수는 없다. 하지만 New 영역의 크기를 잘 조절함으로써 큰 효과를 볼 수는 있다.</p><p><code>Full GC 시간 줄이기</code></p><p>Full GC의 실행 시간은 상대적으로 Minor GC에 비하여 길다. 그래서 Full GC 실행에 시간이 오래 소요되면(1초 이상) 연계된 여러 부분에서 타임아웃이 발생할 수 있다. 그렇다고 Full GC 실행 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 자칫 OutOfMemoryError가 발생하거나 Full GC 횟수가 늘어난다. 반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다. Old 영역의 크기를 적절하게 ‘잘’ 설정해야 한다.</p><p>이는 정답이 정해져있는 것이 아니라 시스템에 따라 지속적으로 모니터링하면서 수치를 정해야 한다는 뜻으로 지금까지의 내용을 JVM Options으로 예를 들면 아래와 같다.</p><p><code>JVM Options 예시</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.awt.headless=true -server –Xms2048m -Xmx2048m -XX:NewSize=768m -XX:MaxNewSize=768m -XX:NewRatio=2 -XX:PermSize=128m -XX:MaxPermSize=256m -XX:USeParNewGC</span><br></pre></td></tr></table></figure><p>ParallelGC, UseConcMarkSweepGC와 같은 옵션을 볼 수 있는데 구체적으로 각기 다른 GC 알고리즘을 살펴보도록 하겠다.</p><h4 id="The-Serial-GC"><a href="#The-Serial-GC" class="headerlink" title="The Serial GC"></a>The Serial GC</h4><p>Serial GC는 가장 단순한 GC이지만 사용하지 않는 것을 추천한다. 싱글 쓰레드 환경을 위해 설계 되었고 아주 작은 Heap영역을 가진다. Full GC가 일어나는 동안 애플리케이션 전체가 대기해야하는 현상이 발생하기 때문에 서버 애플리케이션에 적당하지 않다.</p><h4 id="The-Parallel-GC-Threads"><a href="#The-Parallel-GC-Threads" class="headerlink" title="The Parallel GC Threads"></a>The Parallel GC Threads</h4><p>Java 8의 디폴트 GC인 Parallel GC는 문자 그대로 병렬로 GC한다. 메모리가 충분하고 CPU의 성능과 코어 개수가 많아 순간적으로 트래픽이 몰려도 일시 중단을 견딜 수 있고 GC에 의해 야기된 CPU 오버 헤드에 대해 최적화할 수 있는 애플리케이션에 가장 적합합니다.</p><ul><li><code>-XX:+UseParallelGC</code> 옵션을 사용하여 Minor GC 에서 활성화 할 수 있다.</li><li><code>-XX:+UseParallelOldGC</code> 옵션을 사용하여 Major GC에서 활성화 할 수 있다.</li></ul><h4 id="The-Concurrent-Mark-amp-Sweep-GC"><a href="#The-Concurrent-Mark-amp-Sweep-GC" class="headerlink" title="The Concurrent Mark &amp; Sweep GC"></a>The Concurrent Mark &amp; Sweep GC</h4><p>간단히 CMS GC라고도 하는데, Class Loader로 부터 최초의 객체 참조가 발생하는 Root를 시작으로 객체의 참조 상태를 관리한다.</p><p><img src="http://d2.naver.com/content/images/2015/06/helloworld-1329-5.png"></p><blockquote><p><a href="http://d2.naver.com/helloworld/1329" target="_blank" rel="external">http://d2.naver.com/helloworld/1329</a></p></blockquote><p>초기 Initial Mark 단계에서는 Class Loader에서 가장 가까운 객체 중 살아 있는 객체만 찾는 것으로 끝낸다. 따라서, 멈추는 시간은 매우 짧다. 그리고 Concurrent Mark 단계에서는 방금 살아있다고 확인한 객체에서 참조하고 있는 객체들을 따라가면서 확인한다. 이 단계의 특징은 다른 스레드가 실행 중인 상태에서 동시에 진행된다는 것이다.</p><p><img src="https://plumbr.eu/wp-content/uploads/2015/06/g1-06.png"></p><p>위의 화살표가 없는 객체와 같이 더이상 Root와 연관된 객체로 부터 참조되지 않는 객체를 Unreachable 객체라고 하며 GC의 대상으로 삼는다. CMS의 단점은 같은 성능을 위해 Parallel GC에 비해 더욱 많은 CPU 자원을 사용한다는 것인데 이와 같이 많은 CPU 리소스를 할당하려는 경우 메모리의 크기가 4GB 미만인 것으로 가정할 때 사용할 수 있는 GC 알고리즘이다.</p><p>만약 운영체제에서 JVM 인스턴스에 할당할 수 있는 메모리의 크기가 4GB보다 큰 경우에는 G1 GC 알고리즘을 사용할 수 있다. CMS는 애플리케이션의 Thread 정지 시간을 최소화 하여 응답시간 지연을 줄이고자 하는 웹 애플리케이션에 적당하다.</p><ul><li>Major GC 실행시 Application Thread와 GC Thread가 동시에 수행된다.</li><li><code>-XX:+UseConcMarkSweepGC</code> 옵션을 사용하여 활성화 할 수 있다.</li><li>Minor GC에서 Parallel Collector를 활성화하기 위해서는 <code>-XX:+UseParNewGC</code> 옵션을 사용해야 하며 <code>-XX:+UseParallelGC</code>와 같이 사용해서는 안된다!</li></ul><h2 id="The-G1-Garbage-First-GC"><a href="#The-G1-Garbage-First-GC" class="headerlink" title="The G1(Garbage First) GC"></a>The G1(Garbage First) GC</h2><p>G1 GC는 <code>JDK 7u4</code> 부터 도입되었으며 4GB이상의 더욱 큰 자원을 제공하고 장기적으로 CMS를 대체하기 위해 설계되었다. G1 GC를 이해하려면 지금까지의 Young 영역과 Old 영역에 대해서는 잊는 것이 좋다.</p><p>GC GC는 Generational 한 알고리즘과는 다르게 백그라운드의 멀티 쓰레드를 활용해 1MB에서 32MB까지의 수 많은 리젼으로 Heap을 분할한다.</p><p><img src="http://d2.naver.com/content/images/2015/06/helloworld-1329-6.png" width="400"></p><blockquote><p><a href="http://d2.naver.com/helloworld/1329" target="_blank" rel="external">http://d2.naver.com/helloworld/1329</a></p></blockquote><p>G1 GC는 위와 같이 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다. 그러다가, 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행한다. 즉, 지금까지 설명한 Young의 세가지 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 GC 방식이라고 이해하면 된다. </p><p>G1 GC의 가장 큰 장점은 성능이다. G1은 지연 시간을 줄이기 위해서 지금까지 설명한 어떤 GC 방식보다도 빠르다.</p><p>하지만 이와 같이 4GB 이상의 큰 Heap을 가지는 것은 요즘과 같이 마이크로 서비스 아키텍쳐에서는 논쟁 거리가 될만하다. 지난 몇 년동안 많은 개발자들이 거대한 시스템을 작은 마이크로 단위로 옮기는 노력을 해왔기 때문이다.</p><p>이는 다양한 애플리케이션을 서로 격리하고 효율적인 배포 프로세스를 통해 거대한 애플리케이션 클래스를 메모리에 로드하는데 소요되는 비용을 절감하는 등 많은 요인을 포함하고 있다. 이는 애플리케이션을 동일한 물리적 머신에 배포할 수 있도록 하는 Docker와 같은 컨테이너 기술에 의해 가속화 되어 왔다.</p><p><code>Class Unloading에 대한 이슈</code></p><ul><li><a href="http://openjdk.java.net/jeps/156" target="_blank" rel="external">http://openjdk.java.net/jeps/156</a></li></ul><p>Hot Deploy(Hot Swapping)를 많이 할 경우 Java 7의 G1 GC에서는 Perm Generation 영역에 문제가 발생할 수 있다.</p><ul><li>JDK 7의 G1 GC는 Class Unloading을 Full GC가 발생했을 시에만 수행하게 된다.</li><li>이 문제는 JDK 8u40 버전에서 Perm Generation을 없애고 Metaspace 방식으로 바꾼 후에 해결되었다.</li></ul><p><code>-XX:+UseLargePagesInMetaspace</code></p><p>JDK 8에서는 Perm 영역이 아니라 Metaspace에 클래스 정보가 올라가는데 이때 그 영역이 크면 GC 시간이 오래 걸릴 수 있는데 이럴 때는 Metaspace에 Large Page를 사용하여 접근하도록 JVM 옵션을 주면 대부분 문제가 해결될 수 있다는 것</p><p><code>JVM Options 예시</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms2048m -Xmx2048m -XX:MaxMetaspaceSize=512m -XX:+UseG1GC -XX:+DisableExplicitGC -XX:+UseStringDeduplication</span><br></pre></td></tr></table></figure><h2 id="Java-9의-디폴트-GC는-G1이다"><a href="#Java-9의-디폴트-GC는-G1이다" class="headerlink" title="Java 9의 디폴트 GC는 G1이다"></a>Java 9의 디폴트 GC는 G1이다</h2><p>최근에 Java 9 출시 소식이 있었다. JDK 9에 포함된 다양한 Features 중 32-bit, 64bit 서버 환경에서 G1을 디폴트 Garbage Collector로 변경한 내용이 있다. 더불어 CMS GC는 JDK 9에서 Deprecated 되었다.</p><p><code>Make G1 the Default Garbage Collector</code></p><ul><li><a href="http://openjdk.java.net/jeps/248" target="_blank" rel="external">JEP248</a></li></ul><p>많은 성능 개선 사항이 JDK 8의 G1과 업데이트 릴리스에 따라 이루어졌으며, 추가 개선 사항이 JDK 9에 추가되었다. 예를 들면 <a href="http://openjdk.java.net/jeps/156" target="_blank" rel="external">JEP156</a> 이슈는 G1을 완전한 품질의 Garbage Collector로 만들 수 있게 해줬다.</p><p>이러한 Garbage Collector에 대한 변화는 Parallel GC와 같이 처리량을 극대화하는 것보다 GC의 지연 시간을 제한하는 것이 더 중요하다는 가정 하에 이루어졌다. 만약 이 가정이 잘못되었다면 이 변화는 재고해야 할 필요가 있을 수 있다.</p><p><code>G1은 튜닝하기 쉽게 설계되었다</code></p><p>Stop The World로 인한 지연 시간을 기본으로 하는 튜닝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx32G -XX:MaxGCPauseMillis=100</span><br></pre></td></tr></table></figure><blockquote><p>-XX:MaxGCPauseMillis의 디폴트 값은 250ms 이다.</p></blockquote><h2 id="어떤-GC-알고리즘을-선택해야-할까"><a href="#어떤-GC-알고리즘을-선택해야-할까" class="headerlink" title="어떤 GC 알고리즘을 선택해야 할까?"></a>어떤 GC 알고리즘을 선택해야 할까?</h2><p><img src="https://blogs.thomsonreuters.com/answerson/wp-content/uploads/sites/3/2015/09/519915153-getty-competition-pursuit-push-performance-800x450.jpg"></p><p>우리는 다양한 GC 알고리즘을 살펴보았지만 중요한 것은 모든 서비스에 완벽하게 맞아 떨어지는 GC 알고리즘은 없다는 것이다. 각 애플리케이션의 특정 동작에 따라 처리량을 극대화하거나 지연 시간을 줄이는 옵션을 따져 적합한 GC를 사용하도록 하자.</p><p>Java 9에서도 여전히 ParallelGC를 사용할 수 있기 때문이다.</p><h2 id="JVM-튜닝-꼭-해야할까"><a href="#JVM-튜닝-꼭-해야할까" class="headerlink" title="JVM 튜닝 꼭 해야할까?"></a>JVM 튜닝 꼭 해야할까?</h2><p>JVM 튜닝은 가장 마지막에 고려하는 것이 좋다. </p><h4 id="quot-JVM-튜닝을-하기전에-스스로에게-3번정도-꼭-다시-물어보자-quot"><a href="#quot-JVM-튜닝을-하기전에-스스로에게-3번정도-꼭-다시-물어보자-quot" class="headerlink" title="&quot;JVM 튜닝을 하기전에 스스로에게 3번정도 꼭 다시 물어보자.&quot;"></a><code>&quot;JVM 튜닝을 하기전에 스스로에게 3번정도 꼭 다시 물어보자.&quot;</code></h4><p>그 이유는 대게의 문제는 JVM 튜닝이 필요한 것이 아니라 애플리케이션 내부에 이슈가 있는 경우가 많기 때문이다. 애플리케이션을 구동하는 운영체제에 메모리가 해제되지 않는 등의 이상 징후가 생긴다면, 먼저 애플리케이션에서 과도하게 많은 메모리를 차지하는 객체를 추적할 필요가 있다. </p><p>특히 웹 애플리케이션과 같은 멀티 쓰레드 환경에서는 한 자원에 여러 쓰레드가 동시에 접근하면서 메모리 참조에 이상이 생기는 경우가 있다.</p><p>이 의미는 Garbage 객체가 누수되어 시스템에 좋지 않은 영향을 미친다는 것이다. 가장 많이 하는 실수는 메모리를 이용하는 클래스를 구현하면서 클래스 내부의 <code>HashMap</code>을 잘못 사용하는 경우이다. <code>HashMap</code>의 put(), get()를 사용할 때에는 동기화 기법을 통해 Thread Safe하게 코드를 작성하거나 <code>ConcurrentHashMap</code> 를 사용하는 것을 추천한다.</p><p>이어서 메모리 참조에 이상이 생긴 객체들을 효과적으로 찾는 다양한 기법을 알아보도록 하자.</p><h2 id="GC-모니터링"><a href="#GC-모니터링" class="headerlink" title="GC 모니터링"></a>GC 모니터링</h2><h4 id="GC-로그를-위한-JVM-Options"><a href="#GC-로그를-위한-JVM-Options" class="headerlink" title="GC 로그를 위한 JVM Options"></a>GC 로그를 위한 JVM Options</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XX:-PrintGC -XX:-PrintGCDetails -XX:-PrintGCTimeStamps -XX:-TraceClassUnloading -XX:-TraceClassLoading</span><br></pre></td></tr></table></figure><h4 id="스레드-덤프-획득"><a href="#스레드-덤프-획득" class="headerlink" title="스레드 덤프 획득"></a>스레드 덤프 획득</h4><p>스레드 덤프를 획득하는 방범은 여러 가지가 있지만 기본적으로 JVM의 옵션을 통해 Out Of Memory 에러 발생시 아래와 같이 쓰레드 덤프를 획득할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</span><br></pre></td></tr></table></figure><p>애플리케이션의 현재 프로세스를 확인하고 실시간으로 쓰레드 덤프를 얻기 위해서는 획득할 당시의 스레드 상태만 알 수 있기 때문에 스레드의 상태 변화를 확인하려면 5초 정도의 간격으로 5 ~ 10회 정도 획득하는 것이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jps -v</span><br><span class="line">8352 GradleMain -Dorg.gradle.appname=gradle</span><br><span class="line">8372 GradleDaemon -XX:MaxPermSize=256m -XX:+HeapDumpOnOutOfMemoryError -Xmx1024m -Dfile.encoding=UTF-8 -Duser.country=US -Duser.language=en -Duser.variant</span><br><span class="line">8409 Jps -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_102.jdk/Contents/Home -Xms8m</span><br><span class="line">...</span><br><span class="line">$ jstack :PID</span><br><span class="line">...</span><br><span class="line">$ kill -3 :PID</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="jstat-명령을-통한-GC-모니터링"><a href="#jstat-명령을-통한-GC-모니터링" class="headerlink" title="jstat 명령을 통한 GC 모니터링"></a>jstat 명령을 통한 GC 모니터링</h4><p>현재 JVM의 메모리 상태를 확인할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$JAVA_HOME/bin/jstat</span><br></pre></td></tr></table></figure><h4 id="Memory-Analyzer-MAT"><a href="#Memory-Analyzer-MAT" class="headerlink" title="Memory Analyzer(MAT)"></a>Memory Analyzer(MAT)</h4><p>이클립스를 사용한다면 MAT 플러그인도 도움이 된다. MAT은 hprof 파일을 분석해서 메모리 분석, 통계를 내는 기능을 제공한다.</p><ul><li><a href="http://eclipse.org/mat" target="_blank" rel="external">http://eclipse.org/mat</a></li></ul><h2 id="정리하며"><a href="#정리하며" class="headerlink" title="정리하며"></a>정리하며</h2><p>지금까지 Java 시스템 운영 중 알아두면 쓸데있는 지식들을 살펴보았습니다. 대용량의 웹 애플리케이션을 운영 하다보면 다양한 문제에 노출되기 쉬운데 여러 각도에서 자신의 시스템을 바라볼 수 있다면 더욱 견고한 시스템을 만들 수 있을 것이라고 생각합니다. 아래는 이 글을 작성하면서 참고한 문서들인데 도움이 되었으면 합니다 :)</p><h2 id="이-문서는-아래의-글을-참고하였습니다"><a href="#이-문서는-아래의-글을-참고하였습니다" class="headerlink" title="이 문서는 아래의 글을 참고하였습니다"></a>이 문서는 아래의 글을 참고하였습니다</h2><ul><li><a href="https://httpd.apache.org/docs/2.4/ko/misc/perf-tuning.html" target="_blank" rel="external">https://httpd.apache.org/docs/2.4/ko/misc/perf-tuning.html</a></li><li><a href="http://presentations2015.s3.amazonaws.com/40_presentation.pdf" target="_blank" rel="external">http://presentations2015.s3.amazonaws.com/40_presentation.pdf</a></li><li><a href="http://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection" target="_blank" rel="external">http://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection</a></li><li><a href="https://www.optaplanner.org/blog/2015/07/31/WhatIsTheFastestGarbageCollectorInJava8.html" target="_blank" rel="external">https://www.optaplanner.org/blog/2015/07/31/WhatIsTheFastestGarbageCollectorInJava8.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></li><li><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="external">http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#available_collectors.selecting" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#available_collectors.selecting</a></li><li><a href="https://docs.oracle.com/cd/E40518_01/integrator.311/integrator_install/src/cli_ldi_server_config.html" target="_blank" rel="external">https://docs.oracle.com/cd/E40518_01/integrator.311/integrator_install/src/cli_ldi_server_config.html</a></li><li><a href="https://databricks.com/blog/2015/05/28/tuning-java-garbage-collection-for-spark-applications.html" target="_blank" rel="external">https://databricks.com/blog/2015/05/28/tuning-java-garbage-collection-for-spark-applications.html</a></li><li><a href="http://d2.naver.com/helloworld/1329" target="_blank" rel="external">http://d2.naver.com/helloworld/1329</a></li><li><a href="http://d2.naver.com/helloworld/37111" target="_blank" rel="external">http://d2.naver.com/helloworld/37111</a></li><li><a href="http://d2.naver.com/helloworld/132178" target="_blank" rel="external">http://d2.naver.com/helloworld/132178</a></li><li><a href="http://d2.naver.com/helloworld/184615" target="_blank" rel="external">http://d2.naver.com/helloworld/184615</a></li><li><a href="http://d2.naver.com/helloworld/6043" target="_blank" rel="external">http://d2.naver.com/helloworld/6043</a></li><li><a href="http://d2.naver.com/helloworld/329631" target="_blank" rel="external">http://d2.naver.com/helloworld/329631</a></li><li><a href="http://d2.naver.com/helloworld/1326256" target="_blank" rel="external">http://d2.naver.com/helloworld/1326256</a></li><li><a href="http://d2.naver.com/helloworld/1134732" target="_blank" rel="external">http://d2.naver.com/helloworld/1134732</a></li><li><a href="https://gist.github.com/hardyoyo/8664b2171d26adcf7b7e" target="_blank" rel="external">https://gist.github.com/hardyoyo/8664b2171d26adcf7b7e</a></li><li><a href="https://gist.github.com/patmandenver/cadb5f3eb567a439ec01" target="_blank" rel="external">https://gist.github.com/patmandenver/cadb5f3eb567a439ec01</a></li><li><a href="https://stackoverflow.com/questions/35824572/g1gc-how-to-use-all-free-memory" target="_blank" rel="external">https://stackoverflow.com/questions/35824572/g1gc-how-to-use-all-free-memory</a></li><li><a href="http://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection" target="_blank" rel="external">http://product.hubspot.com/blog/g1gc-fundamentals-lessons-from-taming-garbage-collection</a></li><li><a href="http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/" target="_blank" rel="external">http://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/</a></li><li><a href="http://blog.takipi.com/7-things-you-thought-you-knew-about-garbage-collection-and-are-totally-wrong/" target="_blank" rel="external">http://blog.takipi.com/7-things-you-thought-you-knew-about-garbage-collection-and-are-totally-wrong/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 기반의 서버 애플리케이션은 운영 중에 아래와 같은 메세지와 함께 장애로 이어지는 결과가 일어나곤 합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.holaxprogramming.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>자바의 역사와 철학</title>
    <link href="https://www.holaxprogramming.com/2017/08/16/java-history/"/>
    <id>https://www.holaxprogramming.com/2017/08/16/java-history/</id>
    <published>2017-08-15T15:49:31.000Z</published>
    <updated>2022-06-07T00:26:23.006Z</updated>
    
    <content type="html"><![CDATA[<p>컴퓨터 언어 혁명은 두 가지 요소에 의해 이루어졌다. 프로그래밍 과학의 진보와 컴퓨터 환경의 변화가 바로 그것이다. 자바도 예외는 아니다. 자바는 C, C++에서 물려받은 풍부한 유산을 선별하여 채택하였고, 그것에 최신 프로그래밍 경향을 반영하는 요소들로 채워졌었다.</p><p>온라인 환경의 출현에 맞추어, 자바는 고도의 분산형 구조에 적합한 능률적인 프로그래밍 방식을 제공한다. 자바는 1991년, Sun Microsystems의 제임스 고슬링(James Gosling,) 패트릭 노튼(Patrick Naughton), 크리스 와츠(Chris Warth), 에드 프랭크(Ed Frank), 그리고 마이크 쉐리든(Mike Sheridan)에 의해 창안되었다. </p><h4 id="플랫폼-독립적인-언어를-만들자"><a href="#플랫폼-독립적인-언어를-만들자" class="headerlink" title="플랫폼 독립적인 언어를 만들자!"></a>플랫폼 독립적인 언어를 만들자!</h4><p>초기에 이 언어는 Oak라 명명 되었으나 1995년에 Java로 바뀌었다. 다소 놀라운 일이지만, 원래 자바는 인터넷을 통한 웹 서비스 또는 Android와 같은 모바일 환경을 위해 개발된 것이 아니었다. </p><p>자바가 지향했던 것은 토스터, 전자레인지, 리모콘 등의 가전제품에 내장될 소프트웨어를 위한 플랫폼(platform) 독립적인(Independent) 언어였다. 대충 짐작할 수 있듯이 중심 제어기로 사용되는 CPU는 매우 다양하다. 문제는 대부분의 컴퓨터 언어가 특수한 아키텍쳐나 OS에 맞게 컴파일 되도록 설계된다는 것이였다.</p><h4 id="Write-Once-Run-Anywhere"><a href="#Write-Once-Run-Anywhere" class="headerlink" title="Write Once Run Anywhere!"></a>Write Once Run Anywhere!</h4><p>가령 C++를 예를 들어 보자. C++ 프로그램은 모든 종류의 CPU에 맞게 컴파일될 수 있지만, 그것을 위해서는 해당<br>CPU에 맞는 C++컴파일러가 필요하다. 하지만, 각각의 환경의 컴파일러를 위한 비용은 비싸고 개발하는데 시간이 너무 많이 소요되는 문제가 있다.  </p><p>좀 더 나은 방식을 찾기 위해 James Gosling 과 그 동료들은 다양한 환경의 CPU에서 실행 되는 코드를 생성 할수 있는, 이식성이 뛰어난 Cross Platform 언어의 개발에 착수 했다. 이러한 배경을 바탕으로 Write Once, Run Anywhere와 같은 철학을 가지고 있는 자바의 탄생으로 이어 지게 된 것 이다.</p><h4 id="인터넷과-자바의-만남"><a href="#인터넷과-자바의-만남" class="headerlink" title="인터넷과 자바의 만남"></a>인터넷과 자바의 만남</h4><p>자바의 세부적인 부분이 개발되고 있을 무렵, 2차적이긴 하지만 자바의 미래를 결정지을 만큼 중요한 요인이 나타났<br>다. 바로 월드 와이드 웹(WWW) 의 출현 으로, 만일 자바가 개발되던 시기에 웹이 형태를 갖추지 못했다면, 자바는 가전제품의 프로그램 개발에만 쓰이는 언어로 남았을 것이다. 그러나 이식 가능한 언어를 요구하는 웹의 출현으로 인해 자바는 당시 컴퓨터 언어 설계 프로젝트의 선두로 부상하게 된다.</p><p>대부분의 프로그래머는 초기 경험을 통해 이식성이 좋은 프로그램은 그만큼 구현하기가 어렵다는 것을 깨닫게 된다. 효율적이며 플랫폼 독립적인 이식성이 뛰어난 프로그램 개발에 대한 요구는 거의 프로그래밍이라는 학문 자체 만큼<br>이나 오래 계속 되어 오긴 했지만, 지금까지는 다른 문제들에 의해 뒷전으로 밀려나 있었다. </p><p>그러나, 인터넷과 웹의 출현으로 이식성의 문제가 다시 전면으로 떠올랐다. 아무튼, 인터넷은 다양한 컴퓨터, 운영 체제, 그리고 CPU로 넘쳐나는 광대한 분산형 시스템인 것이다. </p><p>한 때는 성가시기만 하고 우선 순위에서도 밀려나 있었던 문제가 이제는 명백하게 가장 중요한 사안이 되어버렸다. 1993년 경, 자바 팀은 임베디드(Embeded) 제어기에서 사용할 코드를 개발할 때 자주 나타나던 이식성의 문제가 인터넷을 위한 코드를 개발할 때도 나타난다는 사실을 알게 되었다. </p><p>이리하여 자바의 초점은 가전제품에서 인터넷으로 옮겨지게 된 것이다. 따라서 자바 언어 설계에 최초의 영감을 제공한 것은 아키텍처 중립적인 프로그래밍 언어에 대한 요구이지만 궁극적으로 자바가 대성공을 거두도록 이끈 것은 인터넷이라고 해야 할 것이다.</p><h4 id="자바의-발전"><a href="#자바의-발전" class="headerlink" title="자바의 발전"></a>자바의 발전</h4><p>인터넷은 자바가 프로그래밍 세계의 전면으로 부상하도록 했으며 자바는 인터넷에 큰 영형을 미쳤다. 이유는 간단하<br>다. 자바가 가상 공간을 자유롭게 돌아 다닐 수 있는 객체의 세계를 확장 했기 때문이다. 네트워크에는 서버와 PC사<br>이에 전송 되는 두 가지 객체 영역이 존재하는데, 수동적 정보와 동적이고 능동적인 프로그램이 그것이다.</p><p>예를 들면, e-메일을 읽는 것은 수동적 정보를 보는 것이다. 프로그램을 다운로드할 때도 그것을 실행하기 전까지는 프로그램 코드는 수동적 정보가 된다. 하지만 또 다른 형태의 객체가 PC 컴퓨터에 전송될 수 있는데, 그것이 바로 동적인 자가 실행 프로그램이다. 이러한 프로그램은 서버에 의해 시작되지만 클라이언트 컴퓨터에서 실행된다. 그 예로 서버가 보내는 정보를 클라이언트 컴퓨터의 화면에 표시하기 위해 서버가 제공하는 프로그램을 들 수 있다.</p><p>네트워크 상에서 동작하는 프로그램이 동적일수록 보안이나 이식성의 문제가 심각해진다. 자바 이전의 가상 공간은 현재에 존재하는 실체들의 절반에게만 열려 있었다. 자바는 이 문제에 관심을 가졌고, 이 과정에서 애플릿 이라는 새로운 형식의 프로그램을 정의하게 되었다.</p><h4 id="JDK와-JRE"><a href="#JDK와-JRE" class="headerlink" title="JDK와 JRE"></a>JDK와 JRE</h4><p><img src="https://maneeshchaturvedi.files.wordpress.com/2009/07/jvm-arch.jpeg"></p><p>JRE(Java Runtime Environment)는 Java 애플리케이션을 실행하기 위한 Java Virtual Machine을 구현하는 환경입니다.</p><p>JDK(Java Development Kit)은 Java 기반의 애플리케이션을 개발하는데 필요한 번들을 말한다. JDK는 다양한 도구를 비롯해 JRE 포함하므로 더욱 넓은 디스크 공간이 필요합니다. JDK는 Java 애플리케이션과 애플릿을 작성하는데 필요한 JRE, API 클래스 집합, Java 컴파일러 Web Start 및 추가 파일을 제공합니다.</p><p>JVM, JRE, JDK는 플랫폼에 의존적이지만 덕분에 JDK를 통해 작성된 프로그램은 플랫폼 독립적으로 실행될 수가 있습니다.</p><h4 id="자바-애플리케이션과-애플릿"><a href="#자바-애플리케이션과-애플릿" class="headerlink" title="자바 애플리케이션과 애플릿"></a>자바 애플리케이션과 애플릿</h4><p>자바로 애플리케이션과 애플릿이라는 두 가지 형태의 프로그램을 만들 수 있다. 애플리케이션은 컴퓨터의 운영체제하에서 실행되는 프로그램을 말한다. 자바로 만들어진 프로그램은 비주얼 베이직이나 C++과 같은 그 밖의 컴퓨터 언어로 개발된 프로그램과 비슷하다. </p><p>애플리케이션 개발에 쓰일 경우 자바는 다른 컴퓨터 언어와 별반 다르지 않다. 자바를 독특하게 만드는 것은 애플릿을 개발할 수 있는 자바의 기능이다. 애플릿은 인터넷 상에서 전송되고, 자바를 지원하는 웹브라우저에서 실행될 수 있도록 설계된 프로그램이다. 다른 많은 컴퓨터 언어로도 애플리케이션을 개발할 수 있지만 애플릿은 오직 자바로만 개발 할 수 있는 것이다. 자바가 애플릿을 통해 두 가지 곤란한 문제, 즉 보안과 이식성을 해결했기 때문이다. 인터넷과 관련하여 두 용어가 무엇을 의미하는지 알아보자.</p><p><code>애플릿</code></p><p>네트워크에 연결된 컴퓨터의 사용자는 정상적인 프로그램을 다운로드할 때마다 바이러스에 감염될 위험을 안고 있는 것이다. 자바 이전에는 많은 사용자들이 실행 가능한 프로그램을 자주 다운로드하지 않았으며, 다운로드한 경우라도 그것을 실행하기 전에 바이러스 검사를 했었다. 이렇게 신중을 기하더라도, 대부분의 사용자는 그들의 시스템이 바이러스에 감염되거나 악성 프로그램이 시스템에서 마구잡이로 실행되는 것을 우려했다.(악성 프로그램은 개인 컴퓨터의 파일을 조사해서 신용카드 번호, 은행 계좌 잔고 상태, 암호 등의 개인 정보를 빼돌릴 수도 있다)</p><p>자바는 사용자의 컴퓨터와 네트워크 애플리케이션 사이에 방화벽(firewall)을 제공하여 이 문제를 해결한다. 자바를 지원하는 웹 브라우저를 사용하면 바이러스 감염에 대한 두려움 없이 안전하게 자바 애플릿을 다운로드할 수 있다. 자바가 사용한 방법은 자바 프로그램이 컴퓨터의 다른 부분에는 접근하지 못하게 하고, 제한된 자바 실행 환경 내에서만 접근할 수 있도록 허용하는 것이다. 사실 클라이언트 컴퓨터에 아무런 해를 끼치지 않고 애플릿을 다운로드하는 기능은 자바의 가장 중요한 부분이다.</p><p><code>이식성</code></p><p>앞서 논한 바와 같이 인터넷에는 다양한 타입의 컴퓨터와 운영체제가 연결되어 있다. 다양한 플랫폼에 동적으로 다운로드되는 프로그램을 위해서는 이식성이 있는 실행 코드를 생성하는 방법이 필요하다. 보안 문제를 해결하는 메커니즘은 이식성 문제를 해결하는 데도 도움이 된다. 이 두 가지 문제에 대한 자바의 솔루션은 우아할 뿐 아니라 효과적이기도 하다.</p><h4 id="웹의-발전과-애플릿의-쇠퇴"><a href="#웹의-발전과-애플릿의-쇠퇴" class="headerlink" title="웹의 발전과 애플릿의 쇠퇴"></a>웹의 발전과 애플릿의 쇠퇴</h4><p>애플릿은 자바로 작성한 프로그램을 미리 업로드 하고 브라우저 상에서 애플릿 태그로 불러온다. 애플릿 태그가 실행되면 브라우저에서는 프로그램을 다운로드 한 다음 실행한다. 방식으로 보자면 액티브X, 어도비 플래시 및 AIR, 실버라이트와 크게 다를 것은 없지만, 특징은 운영체제 상에서 직접 실행되는 것이 아니라 자바답게 자바 가상 머신에서 실행된다. 따라서 애플릿을 실행하려면 자바 가상머신을 운영체제에 미리 깔아야 한다.</p><p>액티브X보다는 이미지가 좋은 편이지만, 애플릿 역시 시간이 지날수록 만만치 않게 엄청난 보안 구멍이 있었다. 일반적인 액티브X와는 달리 운영체제와 통합된게 아니라 자바 가상머신에서 돌아가므로 조금 나을 수도 있지만, 초기에는 별 제한 없이 로컬 파일을 액세스 할 수 있었으므로 보안이 뚫린 적도 꽤 많았다. 후에 지속적으로 보안 패치를 했지만 취약점 없는 프로그램이란건 사실상 존재하지 않기에 꾸준히 뚫리고, 막는 창과 방패의 전쟁이 지속됐다. 거기다가 자바 가상 머신을 통해서 실행되며 실행 속도가 비교적 느리다.</p><p>그 와중에 터진 브라우저에서의 자바 플러그인의 보안 취약성으로 인한 일련의 사고 및 이에 대한 오라클의 뒤늦은 대응은 개발자 뿐 아니라 기업의 IT 인프라의 아키텍쳐를 결정하는 데 영향을 줄 수 있는 경영자를 포함한 일반인들에게 까지 자바에 대한 부정적인 인식을 퍼뜨리는 치명적인 결과를 가져오게 된다.</p><p>인터넷의 실행 환경인 웹브라우저가 점점 발전하고 거기다 HTML5, Javascript가 발전하면서 더이상 추가적인 설치가 필요하고 번거로운 애플릿, 플래시같은 웹 플러그인은 그 장점을 점점 잃어갔다.</p><p>모질라 재단에서 2015년 10월 파이어폭스에서 NPAPI 플러그인 지원을 중단하겠다는 발표를 했고, 곧 이어 오라클에서는 2016년 1월  Java 9 부터 애플릿을 위한 자바 플러그인 지원을 중단하겠다고 발표했다. 따라서 자바 애플릿은 Java 9 이후 역사속으로 사라질 예정이며, 이후 자바 애플릿이 했던 역할은 유사한 기술인 Java Web Start 가 대신하게 된다.</p><blockquote><p>HTML5에서는 폐지되었으며 대신 embed 태그를 쓴다.<br>사실 이건 웹 플러그인들의 공통점이다. 널리 쓰이는 플래시랑 AIR, 실버라이트도 보안 문제가 많았다.</p></blockquote><h4 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h4><p><img src="https://steveschols.files.wordpress.com/2013/12/javaee_future.png" width="600"></p><p>Java는 이렇게 애플릿이 쇠퇴하였지만 여전히 서버측 애플리케이션을 개발하기 위한 중심적인 역할을 하고 있다. J2EE는 자바를 이용한 서버측 개발을 위한 플랫폼이다. Java EE 플랫폼은 PC에서 동작하는 표준 플랫폼인 Java SE에 부가하여, 웹 애플리케이션 서버에서 동작하는 장애복구 및 분산 멀티티어를 제공하는 자바 소프트웨어의 기능을 추가한 서버를 위한 플랫폼이다. 이전에는 J2EE라 불리었으나 버전 5.0 이후로 Java EE로 개칭되었다.</p><p>이러한 Java EE 스펙에 따라 제품으로 구현한 것을 웹 애플리케이션 서버 또는 WAS라 불린다. 현재는 Java EE의 복잡도로 인해 스프링과 같은 프레임워크를 통해 웹 애플리케이션 서버를 개발하는 추세이다.</p><h4 id="스프링-프레임워크"><a href="#스프링-프레임워크" class="headerlink" title="스프링 프레임워크"></a>스프링 프레임워크</h4><p><img src="https://docs.spring.io/spring/docs/current/spring-framework-reference/images/spring-overview.png"></p><p>스프링은 로드 존슨(Rod Johnson)이 2002년에 출판한 저서 Expert One-on-One J2EE Design and Development에서 선보인 소스 코드를 시작으로 점점 발전하게 되었다. 2003년 6월에 최초로 아파치 라이선스 2.0으로 공개되었다.</p><p>동적 웹을 개발하기 위한 어플리케이션 프레임워크로 JVM 환경에서 작동하며 아파치 라이선스 2.0를 따르고 있다. 전자정부 표준 프레임워크의 기반 기술이며 한국정보화진흥원에서 공공기관의 웹 서비스 제공시 권장하고 있다.</p><p><code>스프링 프레임워크(Spring Framework)의 특징은 아래와 같다</code></p><ul><li><p>POJO(Plain Old Java Object) 방식 : POJO는 Java EE 등 무거운 프레임워크들을 사용하면서 해당 프레임워크에 종속되어 있는 무거운 객체들을 만드는 것에 반발하며 나타난 용어다. J2EE Framework에 비해 특정 인터페이스를 구현하거나 상속받을 필요가 없어 기존 라이브러리를 지원하기에 용이하고 객체가 가볍다.</p></li><li><p>관점 지향 프로그래밍(Aspect Oriented Programming, AOP) : 로깅, 트랜잭션, 보안 등 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리할 수 있다. AspectJ를 포함하여 사용할 수 있고, 스프링에서 지원하는 실행에 조합하는 방식도 지원한다.</p></li><li><p>의존성 주입(Dependency Injection, DI) : 프로그래밍에서 구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일을 통해 정의되는 방식이다. 코드 재사용을 높여 소스코드를 다양한 곳에 사용할 수 있으며 모듈간의 결합도도 낮출 수 있다. 계층, 서비스 간에 의존성이 존재하는 경우 스프링 프레임워크가 서로 연결시켜준다.</p></li><li><p>제어 반전(Inversion of Control, IoC) : 전통적인 프로그래밍에서는 개발자가 작성한 프로그램이 외부 라이브러리의 코드를 호출해서 이용했다. 제어 반전은 이와 반대로 외부 라이브러리 코드가 개발자의 코드를 호출하게 된다. 즉, 제어권이 프레임워크에게 있어 필요에 따라 스프링 프레임워크가 사용자의 코드를 호출한다.</p></li><li><p>MVC 패턴(Model-View-Controller pattern, MVC) : 웹 프로그래밍 개발에서 필수적인 디자인 패턴인 MVC 패턴을 사용한다. DispatcherServlet이 Controller를 담당하며 요청에 따라<code>@(Annotation)</code>으로 선언되어 있는 각 서비스로 분산시켜준다.</p></li><li><p>트랜잭션 관리 : 추상화된 트랜잭션을 XML 설정파일 등을 이용해 관리할 수 있다.</p></li><li><p>생명주기 : 스프링 프레임워크는 자바 객체의 생성, 소멸을 직접 관리하며 필요한 객체만 사용할 수 있다.</p></li><li><p>다양한 서비스 : myBatis와 같은 데이터베이스 처리 라이브러리나 tiles 같은 유용한 인터페이스를 제공한다.</p></li></ul><h4 id="웹-애플리케이션-서버"><a href="#웹-애플리케이션-서버" class="headerlink" title="웹 애플리케이션 서버"></a>웹 애플리케이션 서버</h4><p>웹 애플리케이션 서버(Web Application Server, WAS)는 인터넷 상에서 HTTP를 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해 주는 미들웨어이다. 웹 애플리케이션 서버는 동적 서버 콘텐츠를 수행하는 것으로 일반적인 웹 서버와 구별이 되며, 주로 데이터베이스 서버와 같이 수행이 된다. 한국에서는 일반적으로 <code>WAS</code>로 통칭하고 있으며 공공기관에서는 <code>웹 응용 서버</code>로 사용되고, 영어권에서는 <code>Application Server</code> 로 불린다.</p><h4 id="안드로이드의-출현"><a href="#안드로이드의-출현" class="headerlink" title="안드로이드의 출현"></a>안드로이드의 출현</h4><p><img src="http://elinux.org/images/c/c2/Android-system-architecture.jpg"></p><p>안드로이드(Android)는 휴대 전화를 비롯한 휴대용 장치를 위한 운영 체제와 미들웨어, 사용자 인터페이스 그리고 표준 응용 프로그램(웹 브라우저, 이메일 클라이언트, 단문 메시지 서비스(SMS), 멀티미디어 메시지 서비스(MMS)등을 포함하고 있는 소프트웨어 스택이자 모바일 운영 체제이다. 안드로이드는 개발자들이 자바 언어로 응용 프로그램을 작성할 수 있게 하였으며, 컴파일된 바이트코드를 구동할 수 있는 런타임 라이브러리를 제공한다. 또한 안드로이드 소프트웨어 개발 키트(Android SDK)를 통해 응용 프로그램을 개발하기 위해 필요한 각종 도구들과 API를 제공한다.</p><p>안드로이드는 리눅스 커널 위에서 동작하며, 다양한 안드로이드 시스템 구성 요소에서 사용되는 C/C++ 라이브러리들을 포함하고 있다. 안드로이드는 기존의 자바 가상 머신과는 다른 가상 머신인 달빅 가상 머신을 통해 자바로 작성된 응용 프로그램을 별도의 프로세스에서 실행하는 구조로 되어 있다.</p><h4 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h4><p><img src="https://santhosh0705.files.wordpress.com/2011/08/dalvik-runtime.png"></p><p>대부분의 안드로이드 응용 프로그램은 자바로 작성되어 있으나 자바와 안드로이드의 API에는 많은 차이가 있으며, 안드로이드는 자바 가상 머신(이하 JVM)이 아닌 달빅(Dalvik)이라는 별개의 가상 머신을 사용한다.</p><p>안드로이드 안에는 JVM이 없고, 따라서 자바 바이트코드도 안드로이드에서 실행되지 않는다. 안드로이드에서는 자바 클래스를 또다른 바이트코드로 컴파일한 것을 달빅이라는 독자적인 가상 머신에서 구동한다.</p><p>JVM과 달빅은 몇 가지 다른 점이 있다.</p><ul><li>JVM은 스택 머신이며, 달빅은 레지스터 머신이다.</li><li>달빅은 디스크 공간을 JVM에 비해 덜 사용하도록 설계되었다.</li><li>달빅의 상수 풀은 32비트 인덱스만을 사용하도록 설계되었다.</li><li>JVM에서는 바이트코드가 8비트 스택 인스트럭션을 실행하며 이 때 지역 변수는 별개의 인스트럭션을 따라 피연산자 스택으로부터 또는 피연산자 스택으로 복사되어야 한다. 반면 달빅에서는 지역 변수에 직접 접근하는 독자적인 16비트 인스트럭션을 사용하며 지역 변수는 통상 4비트짜리 가상 레지스터 영역에 의해 채택된다.</li></ul><p>달빅이 읽는 바이트코드도 JVM이 읽는 그것과 다르고, 달빅이 클래스를 읽는 방식도 JVM의 그것과 다르기 때문에 달빅에서는 JVM으로 패키징된 자바 라이브러리를 읽지 못하며 안드로이드 라이브러리를 읽는 데에도 별도의 로직이 필요하다. (특히 안드로이드 라이브러리를 읽을 수 있게 되기 전에 내부 .dex 파일의 내용이 응용 프로그램 내부의 격리된 공간에 복사되어야 하는 것이 있다)</p><h4 id="Dalvik의-클래스-라이브러리"><a href="#Dalvik의-클래스-라이브러리" class="headerlink" title="Dalvik의 클래스 라이브러리"></a>Dalvik의 클래스 라이브러리</h4><p>달빅은 자바 SE나 자바 ME의 클래스 라이브러리 프로필에 기대지 않으며, 이에 따라 자바 ME의 클래스, AWT, 스윙도 지원하지 않는다. 달빅이 사용하는 라이브러리는 아파치 하모니를 기반으로 한다.</p><p><code>java.lang 패키지</code></p><p>자바의 기본 출력 스트림인 System.out과 System.err은 안드로이드에서 기본적으로는 아무것도 출력하지 않는다(ADB를 통해 설정을 변경해 출력하게 할 수는 있다). 안드로이드에서는 기본적으로 Log 클래스를 통해 출력이 이루어지며 출력된 내용은 logcat 툴을 통해 확인할 수 있다.</p><p><code>그래픽스와 위젯</code></p><p>안드로이드는 AWT나 스윙 대신 View 기반의 여러 클래스들로 스윙과 비슷하게 구성한 독자적인 프레임워크를 사용하며, 응용 프로그램의 Context는 생성될 때 위젯에 제공되어야 한다.</p><p><code>외형</code></p><p>안드로이드의 위젯 라이브러리는 기본적으로 스윙의 교체 가능한 외형같은 것이 없고, 외형은 위젯 자체에 코딩되어 있어야 한다. 그러나 스타일과 테마 일부는 응용 프로그램별로 지정할 수 있다.</p><p><code>레이아웃 관리기</code></p><p>레이아웃 관리기가 어느 컨테이너 위젯에든 적용될 수 있는 자바와 달리 안드로이드는 컨테이너 안에 레이아웃이 인코딩된다.</p><h4 id="Open-JDK와-자바의-현재"><a href="#Open-JDK와-자바의-현재" class="headerlink" title="Open JDK와 자바의 현재"></a>Open JDK와 자바의 현재</h4><p>2010년 자바 진영을 이끌던 Sun사가 오라클에 인수 합병되면서 자바의 미래에도 어둠의 그림자가 드리우기 시작했다. 오라클 스스로도 JDK 6 이후에 무척 어려운 기간이었다고 말하고 있다. 이후 자바 7과 그 이후로 넘어갈 때까지 상당히 오랜 시간이 걸렸다. JDK 코드 베이스를 가져와 OpenJDK를 구성하는 데 많은 시간과 노력이 투입됐다. </p><p>Sun(현재의 Oracle)사가 JDK 7을 개발하기 시작할 때 이전과 다른 점이 하나 있었는데, Sun이 JDK를 오픈소스화 하기 위해 2007년 OpenJDK를 만들었다는 것이다.</p><p>다음 주요 릴리스가 나올 때까지 너무 오랜 시간이 걸렸다는 측면에서 실망스러운 일이었지만, 결국 그것도 지금의 OpenJDK 커뮤니티가 형성되고 자바 7과 8이 나오게 된 과정의 일부였다.</p><p>Sun이 3rd-Party 라이브러리의 저작권자에게 오픈소스로 공개할 수 있도록 설득하고자 했으나 잘되지 않았고, 저작권자가 오픈소스화를 거부한 일부 컴포넌트를 제외한 나머지 JDK 소스코드 전부를 OpenJDK에 제공했고, OpenJDK는 이를 기반으로 이외의 컴포넌트들의 대안 코드를 마련하면서 JDK7 프로젝트를 시작했다.</p><p><code>Java 주요 릴리즈 히스토리</code></p><table><thead><tr><th>Version</th><th>Date</th><th>Issues</th></tr></thead><tbody><tr><td>1.0</td><td>1996</td><td>Oak로 출시되었으며 1.0.2 버전부터 Java로 불리우기 시작</td></tr><tr><td>1.1</td><td>1997</td><td>AWT, Innner Class, JDBC, RMI, 윈도우즈 시스템의 JIT(Just In Time) 컴파일러, 유니코드 통합</td></tr><tr><td>1.2</td><td>1998</td><td>애플릿, Sun의 JVM에 처음으로 JIT이 탑재, Collections</td></tr><tr><td>1.3</td><td>2000</td><td>HotSpot JVM 추가, JNDI</td></tr><tr><td>1.4</td><td>2002</td><td>NIO, Logging API, IPv6 지원, XML 파서 통합, Java Web Start</td></tr><tr><td>1.5</td><td>2004</td><td>Generics, Autoboxing/Unboxing, Enumerations, 향상된 for 문, static imports</td></tr><tr><td>1.6</td><td>2006</td><td>Security</td></tr><tr><td>1.7</td><td>2011</td><td>Null-safe Method invocaton, Multi-Exception catch, Type Inference, String in Switch, Automatic Resource Management, NIO 2.0, G1 Garbage Collector</td></tr><tr><td>1.8</td><td>2014</td><td>Lambda Expression, Streams, Method Reference</td></tr></tbody></table><h4 id="JVM에서-작동하는-다양한-언어들의-출현"><a href="#JVM에서-작동하는-다양한-언어들의-출현" class="headerlink" title="JVM에서 작동하는 다양한 언어들의 출현"></a>JVM에서 작동하는 다양한 언어들의 출현</h4><p><img src="https://zeroturnaround.com/wp-content/uploads/2013/05/jvm-languages-report-1.jpg"></p><p>자바가 1.7로 업데이트가 늦을 이유 때문이였을까? JVM에서 동작하는 새로운 언어들이 출현하기 시작하였다.</p><p>최근에는 대량의 데이터와 클라우드 환경에서 동시성의 문제가 중요한 화두로 대두되었고 이러한 문제를 해결하기 위해서는 불변(Immutable)의 데이터형의 활용을 핵심으로 하는 접근이 대세로 떠오르게 되었다.</p><p>이러한 맥락에서 함수형 패러다임의 접근 방법이나 메시징 기반 아키텍쳐가 빠르게 입지를 넓혀 나가기 시작했고 스칼라와 같은 함수형 언어나 기술들이 그 대안으로 떠오르고 있다.</p><p>따라서 JVM 플랫폼 자체와 그 위에서 돌아가는 여러 라이브러리는 그대로 두고, 컴파일을 통해 클래스 파일을 생성하는 원본 언어만을 대체하는 접근이 널리 쓰이고 있으며, JVM 환경에서 작동하는 자바의 대안 언어들이 이와 같은 방식을 채택하고 있습니다.</p><p>JVM에서 동작하는 언어는 컴퓨터 프로그래밍 언어로 문자 그대로 자바 가상 머신 위에서 실행될 수 있도록 바이트코드를 생성하거나 자바 가상 머신 위에서 실행되는 인터프리터를 지원하는 언어를 말한다. 다양한 언어가 출현했는데 현재 대표적인 JVM 언어는 아래와 같다.</p><ul><li>Clojure</li><li>Groovy</li><li>Kotlin</li><li>Scala</li></ul><h4 id="자바의-미래"><a href="#자바의-미래" class="headerlink" title="자바의 미래"></a>자바의 미래</h4><p>JVM에서 작동하는 언어가 많아지는 것은 자바에게도 좋은 일이다. 한 가지 상기해야 할 점은 자바는 가장 광범위하게 사용되는 언어이며, 실제 사용되는 애플리케이션 수도 가장 많다는 사실이다. 따라서 그만큼 책임도 크다. 따라서 잘 작동하리란 보장이 없는 기능을 함부로 실험하는 것은 자바에겐 무책임한 일이다. 자바 입장에서는 시행착오를 감수하고 다양한 것들을 시도하는 방식은 지양하는 것이 바람직하다.</p><p>그보다 자바는 새로운 발전과 새로운 기술을 충분한 시간동안 검토해 매끄럽게 작동하고 이해하고 사용하기 쉬우며 확장 가능한 상태로 만든 다음 최대한 폭넓은 사용자에게 제공하는 방식을 추구한다. 자바 8의 람다가 바로 이런 예다. </p><p>자바는 앞으로 JVM의 다양한 언어를 개발하는 사람들 사이에서 대화도 활발히 이뤄지는 만큼 흥미롭게 지켜볼 부분이라고 생각한다.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://ko.wikipedia.org/wiki/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80_%EC%9E%90%EB%B0%94%EC%9D%98_%EB%B9%84%EA%B5%90" target="_blank" rel="external">https://ko.wikipedia.org/wiki/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80_%EC%9E%90%EB%B0%94%EC%9D%98_%EB%B9%84%EA%B5%90</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0_%EC%A7%80%EC%9B%90_%EC%96%B8%EC%96%B4" target="_blank" rel="external">https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0_%EC%A7%80%EC%9B%90_%EC%96%B8%EC%96%B4</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;컴퓨터 언어 혁명은 두 가지 요소에 의해 이루어졌다. 프로그래밍 과학의 진보와 컴퓨터 환경의 변화가 바로 그것이다. 자바도 예외는 아니다. 자바는 C, C++에서 물려받은 풍부한 유산을 선별하여 채택하였고, 그것에 최신 프로그래밍 경향을 반영하는
      
    
    </summary>
    
      <category term="java" scheme="https://www.holaxprogramming.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>파이썬의 실행 환경을 지탱하는 도구들</title>
    <link href="https://www.holaxprogramming.com/2017/07/15/python-virtual-environments/"/>
    <id>https://www.holaxprogramming.com/2017/07/15/python-virtual-environments/</id>
    <published>2017-07-15T06:24:49.000Z</published>
    <updated>2022-06-07T00:26:23.018Z</updated>
    
    <content type="html"><![CDATA[<p>지금까지 파이썬을 통해 테스트 코드를 작성해 나아가면서 점차적으로 프로젝트를 구조화하는 모습을 살펴보았습니다. <a href="https://www.holaxprogramming.com/2017/06/28/python-project-structures/">이전 글들</a>을 통해서 아래와 같은 의문이 다소 해소되었기를 바랍니다. (물론 저에게도 말이죠)</p><ul><li>파이썬 프로그래밍을 위한 기본적인 개발 환경은 무엇인가</li><li>테스트에 필요한 도구 그리고 테스트 코드는 어떻게 작성하는가</li><li>파이썬 프로젝트의 구조는 어떠한 모습이며 내부 프로젝트의 모듈은 어떻게 관리해야 하는가</li><li>외부의 유용한 모듈은 어떻게 설치하는가</li></ul><p>그렇다면 앞으로 파이썬 프로젝트를 일관적으로 관리하고 배포하기 위해서는 어떻게 해야할까요? 먼저 프로젝트를 일관적으로 관리한다는 의미는 다음과 같습니다.</p><ul><li>프로젝트에 관여하는 모든 멤버가 애플리케이션을 쉽게 설치하고 실행할 수 있어야 합니다.</li><li>프로젝트에 포함되는 모듈의 버전과 의존성을 효율적으로 관리할 수 있어야 합니다.</li><li>다양한 운영체제에 쉽게 배포할 수 있어야 합니다.</li></ul><p>이 글에서는 새롭게 생긴 의문들을 해소하기 위해서 파이썬의 실행 환경을 지탱하는 도구들을 살펴보도록 하겠습니다.</p><h2 id="파이썬의-패키지들"><a href="#파이썬의-패키지들" class="headerlink" title="파이썬의 패키지들"></a>파이썬의 패키지들</h2><p>우리는 앞서 <code>pip</code>을 통해 개발에 필요한 유용한 모듈을 프로젝트에 포함시킬 수 있었습니다. 이러한 외부의 모듈은 시스템의 아래의 경로에 설치됩니다.</p><p><code>Linux</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/python3.6/site-packages/</span><br></pre></td></tr></table></figure><p><code>Mac OSX</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/</span><br></pre></td></tr></table></figure></p><p>디렉토리의 개수는 위와 같이 시스템에 설치된 파이썬 인터프리터의 버전의 종류에 따라 결정됩니다. 파이썬 인터프리터 뿐만 아니라 pip 역시 버전 별로 아래와 같이 명령어가 나뉘게 됩니다.</p><p><code>시스템에 파이썬 인터프리터 2.7.10, 3.6.1를 설치한 상태</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python --version</span><br><span class="line">Python 2.7.10</span><br><span class="line">$ python3 --version</span><br><span class="line">Python 3.6.1</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pip --version</span><br><span class="line">pip 9.0.1 from /Library/Python/2.7/site-packages/pip-9.0.1-py2.7.egg (python 2.7)</span><br><span class="line">$ pip3 --version</span><br><span class="line">pip 9.0.1 from /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages (python 3.6)</span><br></pre></td></tr></table></figure><p>이렇게 설치된 모듈은 파이썬 인터프리터와 시스템에 설치된 모든 애플리케이션에서 사용할 수 있습니다.</p><h2 id="Virtual-Environments"><a href="#Virtual-Environments" class="headerlink" title="Virtual Environments"></a>Virtual Environments</h2><p>파이썬의 패키징 표준은 위와 같이 한 시스템에서 다양한 애플리케이션을 설치하는 방식으로 시작되었습니다. 하지만 이러한 점은 다양한 애플리케이션에서 의존하는 모듈의 버전이 다를 때 문제가 됩니다.</p><p>파이썬의 <code>Virtual Environments</code>는 특정 애플리케이션을 위해 필요한 모듈을 구분하여 관리할 수 있도록 합니다.</p><h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><p>이 의미는 시스템에서 다양한 파이썬 프로젝트를 동시에 작업하는 경우 모듈의 버전 충돌 문제를 우회할 필요가 있다는 것입니다. <code>virtualenv</code>는 이러한 문제를 해결하기 위해 프로젝트마다 독립적인 실행 환경을 만들도록 도와줍니다. </p><p>이 의미는 <code>A 프로젝트</code>에서 특정 Module을 1.x 버전을 사용해 유지 보수하면서 <code>B 프로젝트</code>에서는 2.x 버전을 사용하는 것을 말합니다. 뿐만 아니라 파이썬 인터프리터의 버전도 프로젝트별로 구분할 수 있습니다. </p><p><code>virtualenv 설치 하기</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install virtualenv</span><br></pre></td></tr></table></figure><p><code>설치 확인</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --version</span><br></pre></td></tr></table></figure><p>virtualenv는 파이썬 인터프리터의 실행 바이너리를 프로젝트 내부의 <code>site-packages</code>로 복사한 뒤 파이썬의 전역 상태를 관리하는 <code>sys.path</code>에 설정된 site-packages의 경로를 내부 환경의 site-packages 경로로 변경합니다. 이 방식은 아래와 같은 명령어를 통해 프로젝트별로 개발 환경을 관리할 수 있게 합니다.</p><blockquote><p><code>sys.path</code> - <a href="https://docs.python.org/3/library/sys.html" target="_blank" rel="external">https://docs.python.org/3/library/sys.html</a><br><code>PEP 730</code> - <a href="https://www.python.org/dev/peps/pep-0370/" target="_blank" rel="external">https://www.python.org/dev/peps/pep-0370/</a></p></blockquote><p><code>새로운 실행 환경을 생성</code></p><p><code>app</code> 이라는 이름을 가진 새로운 프로젝트를 위한 환경을 아래와 같이 생성할 수 있습니다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> app</span><br><span class="line">$ virtualenv env</span><br></pre></td></tr></table></figure><p><code>-p</code> 옵션을 통해 파이썬 인터프리터의 버전을 지정하여 실행 환경을 생성합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv -p /usr/bin/python2.7 env</span><br></pre></td></tr></table></figure><p><code>새로운 실행 환경을 활성화</code></p><p>파이썬의 실행 환경은 <code>activate</code> 단계를 거쳐 활성화 됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> env/bin/activate</span><br></pre></td></tr></table></figure><p><code>외부 모듈 설치</code></p><p>활성화된 실행 환경에서 설치된 모듈은 시스템의 전역 상태가 아닌 프로젝트 내부의 실행 환경에서만 설치됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install requests</span><br></pre></td></tr></table></figure><p><code>실행 환경을 비활성화</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ deactivate</span><br></pre></td></tr></table></figure><p><code>실행 환경을 삭제</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf env</span><br></pre></td></tr></table></figure><h4 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h4><p>만약 파이썬의 버전을 3.3 이상만을 사용한다면 아래와 같은 방법으로도 실행 환경을 생성할 수 있습니다. 버전 3.3 부터 추가된 기능으로 <code>venv</code> 모듈을 통해 실행 환경을 다루는 기능이 내장되어 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m venv venv</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.python.org/3/library/venv.html" target="_blank" rel="external">https://docs.python.org/3/library/venv.html</a><br><a href="https://www.python.org/dev/peps/pep-0405/" target="_blank" rel="external">https://www.python.org/dev/peps/pep-0405/</a></p></blockquote><p>파이썬의 가상 환경을 관리하는 방법을 정리하면 다음과 같습니다.</p><ul><li><code>virtualenv</code>는 버전 <code>2.6+</code> 그리고 <code>3.3+</code>를 동시에 사용한다면 추천한다. pip, setuptools 그리고 wheel은 언제나 디폴트로 새로운 가상 환경에 설치된다.</li><li><code>venv</code> 버전 3.3 부터 내장되었다. 역시 pip, setuptools가 새로운 가상 환경에 설치된다.</li></ul><blockquote><p>파이썬 버전 <code>3.3</code> <code>3.4</code>에서는 <code>pyvenv</code>를 통해 가상 환경을 생성하는 것을 추천하였지만 <code>3.6</code> 에서 Deprecated 되었다.</p></blockquote><h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><p><code>virtualenv</code>는 시스템에 다양한 파이썬 실행 환경을 효율적으로 관리할 수 있도록 하였습니다. 하지만 프로젝트를 생성할 때 마다 새로운 실행 환경을 생성하고 활성화와 비활성화하는 것이 비효율적으로 느껴진 개발자가 있었나 봅니다. </p><p><code>virtualenvwrapper</code>를 설치하면 이러한 문제를 해결할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install virtualenvwrapper</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://virtualenvwrapper.readthedocs.io/en/latest/" target="_blank" rel="external">https://virtualenvwrapper.readthedocs.io/en/latest/</a></p></blockquote><ul><li>실행 환경을 별도의 디렉토리에서 통합하여 관리할 수 있습니다</li><li>실행 환경의 생성, 삭제, 복사를 더욱 쉽게 활용합니다</li><li>한 번의 명령으로 실행 환경을 변경합니다</li></ul><h2 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h2><p>라이브러리 개발자는 다양한 버전의 파이썬에서 실행되는 호환성을 제공해야 합니다. 이것은 여러 버전의 파이썬을 시스템에 동시에 설치할 필요가 있다는 것입니다.</p><p><code>pyenv</code>는 시스템에 다양한 파이썬 인터프리터를 효율적으로 설치할 수 있도록 합니다. 시스템에서 디폴트로 사용되어 지는 파이썬 인터프리터의 버전도 지정하는 등 다양한 기능을 제공합니다.</p><p><code>pyenv 설치</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br><span class="line">$ brew install pyenv</span><br></pre></td></tr></table></figure><p><code>설치가능한 버전을 조회</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv install -list</span><br><span class="line">Available versions:</span><br><span class="line">  2.1.3</span><br><span class="line">  2.2.3</span><br><span class="line">  2.7.13</span><br><span class="line">...</span><br><span class="line">  3.6.3</span><br></pre></td></tr></table></figure><p><code>지정한 버전의 파이썬 설치</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv install 3.6.3</span><br></pre></td></tr></table></figure><p><code>.bash_profile에 환경 변수 설정 후 적용</code></p><p>pyenv를 설치하고 Python의 버전을 관리하면 패키지도 아래와 같은 <code>.pyenv</code> 폴더에서 관리하게 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> .bash_profile</span><br><span class="line">$ pip -V</span><br><span class="line">pip 9.0.1 from /Users/user/.pyenv/versions/3.6.3/lib/python3.6.3/site-packages</span><br></pre></td></tr></table></figure><p><code>시스템에 설치된 버전 조회</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv versions</span><br><span class="line">*  system</span><br><span class="line">   3.6.3</span><br></pre></td></tr></table></figure><p><code>지정한 버전을 시스템의 디폴트로 사용</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv global 3.6.3</span><br><span class="line">$ python -V</span><br><span class="line">Python 3.6.3</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/pyenv/pyenv" target="_blank" rel="external">https://github.com/pyenv/pyenv</a></p></blockquote><h2 id="pyenv-virtualenvwrapper"><a href="#pyenv-virtualenvwrapper" class="headerlink" title="pyenv-virtualenvwrapper"></a>pyenv-virtualenvwrapper</h2><p><code>pyenv</code>가 익숙해졌다면 동시에 <code>virtualenvwrapper</code>의 장점까지 활용할 수도 있습니다. 예를 들어 <code>pyenv-virtualenvwrapper</code>로 다양한 파이썬 버전을 설치했다면 프로젝트에서 사용할 파이썬 버전과 의존되는 모듈을 관리하기 위한 환경을 효율적으로 관리할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install pyenv-virtualenvwrapper</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv virtualenvwrapper</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/pyenv/pyenv-virtualenvwrapper" target="_blank" rel="external">https://github.com/pyenv/pyenv-virtualenvwrapper</a></p></blockquote><h2 id="정리하며"><a href="#정리하며" class="headerlink" title="정리하며"></a>정리하며</h2><p>지금까지 우리는 파이썬을 시작할 때 TDD를 통해 테스트 코드를 작성하면서 다양한 문제를 만났습니다. 이러한 문제들을 해결하는 과정을 아래와 같이 다시 한번 정리하면서 마무리를 짓겠습니다.</p><ul><li><a href="https://www.holaxprogramming.com/2017/06/15/python-get-started/">파이썬 TDD로 시작하기</a></li><li><a href="https://www.holaxprogramming.com/2017/06/17/python-with-test/">unittest와 함께하는 파이썬 테스트</a></li><li><a href="https://www.holaxprogramming.com/2017/06/28/python-project-structures/">파이썬 프로젝트의 구조</a></li><li><a href="https://www.holaxprogramming.com/2017/07/15/python-virtual-environments.md/">파이썬의 실행 환경을 지탱하는 도구들</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://docs.python.org/3/library/site.html" target="_blank" rel="external">https://docs.python.org/3/library/site.html</a></li><li><a href="https://packaging.python.org/tutorials/installing-packages/#install-pip-setuptools-and-wheel" target="_blank" rel="external">https://packaging.python.org/tutorials/installing-packages/#install-pip-setuptools-and-wheel</a></li><li><a href="https://github.com/kennethreitz/python-guide/tree/master/docs/dev" target="_blank" rel="external">https://github.com/kennethreitz/python-guide/tree/master/docs/dev</a></li><li><a href="https://github.com/pyenv/pyenv" target="_blank" rel="external">https://github.com/pyenv/pyenv</a></li><li><a href="https://spoqa.github.io/2017/10/06/python-env-managers.html" target="_blank" rel="external">https://spoqa.github.io/2017/10/06/python-env-managers.html</a></li><li><a href="https://blog.outsider.ne.kr/1324" target="_blank" rel="external">https://blog.outsider.ne.kr/1324</a></li><li><a href="https://blog.outsider.ne.kr/1325" target="_blank" rel="external">https://blog.outsider.ne.kr/1325</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;지금까지 파이썬을 통해 테스트 코드를 작성해 나아가면서 점차적으로 프로젝트를 구조화하는 모습을 살펴보았습니다. &lt;a href=&quot;https://www.holaxprogramming.com/2017/06/28/python-project-structu
      
    
    </summary>
    
      <category term="python" scheme="https://www.holaxprogramming.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Gradle은 정말 Maven보다 100배나 빠를까?</title>
    <link href="https://www.holaxprogramming.com/2017/07/04/devops-gradle-is-faster-than-maven/"/>
    <id>https://www.holaxprogramming.com/2017/07/04/devops-gradle-is-faster-than-maven/</id>
    <published>2017-07-04T04:37:31.000Z</published>
    <updated>2022-06-07T00:26:22.995Z</updated>
    
    <content type="html"><![CDATA[<p>Gradle은 2017년 4월에 3.5 버전을 릴리즈하면서 <code>Build Cache</code>의 특징을 소개하면서 Gradle의 빌드 속도가 드라마틱하게(?) 향상되었다고 발표하였다. Build Cache는 Gradle 3.5에 베타 테스트를 위해 포함된 기능으로 Gradle Tasks의 결과를 로컬에서 재사용하는 것뿐만 아니라 빌드 머신사이에도 Remote로 Tasks의 결과의 캐시가 공유되 빌드 타임을 줄여준다고 한다.</p><p>Gradle에서는 다음 버전에서 Build Cache를 정식으로 릴리즈하기 위해 아래와 같이 사용자들의 피드백을 요구했는데 내용은 아래와 같다.</p><h4 id="프로젝트에서-아래의-옵션을-통해-두-번째-빌드-타임-좀-확인해볼래"><a href="#프로젝트에서-아래의-옵션을-통해-두-번째-빌드-타임-좀-확인해볼래" class="headerlink" title="프로젝트에서 아래의 옵션을 통해 두 번째 빌드 타임 좀 확인해볼래?"></a>프로젝트에서 아래의 옵션을 통해 두 번째 빌드 타임 좀 확인해볼래?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gradle --build-cache clean assemble</span><br><span class="line">$ gradle --build-cache clean assemble</span><br></pre></td></tr></table></figure><h4 id="Remote-Cache도-함-사용해봐"><a href="#Remote-Cache도-함-사용해봐" class="headerlink" title="Remote Cache도 함 사용해봐!"></a>Remote Cache도 함 사용해봐!</h4><p>Remote로 캐시를 공유할려면 backend가 필요한데 <a href="https://github.com/gradle/task-output-cache-demos/tree/master/samples/03-use-http-backend" target="_blank" rel="external">예제</a>를 줄테니 참고하렴. 그런데 <a href="https://gradle.com/enterprise" target="_blank" rel="external">Gradle Enterprise</a>에서는 이미 제공하고 있음</p><h4 id="피드백을-줘"><a href="#피드백을-줘" class="headerlink" title="피드백을 줘!"></a>피드백을 줘!</h4><p>아무튼 직접 사용해보고 피드백을 주면 너의 프로젝트의 빌드 타임을 줄이는데 많은 도움이 될거임(..)</p><h2 id="Gradle-v4-0-Release"><a href="#Gradle-v4-0-Release" class="headerlink" title="Gradle v4.0 Release"></a>Gradle v4.0 Release</h2><p>Gradle Enterprise 그리고 Gradle의 빌드 속도에 불만이 있던 사용자들이 피드백을 잘 줬는지 이전 버전이 발표된지 두 달만에 v4.0이 릴리즈 되었다. Gradle v4.0의 다양한 Feature들은 아래의 링크를 통해 확인할 수 있으며 이 글에서는 Build Cache를 통한 빌드 성능의 향상에 대해 살펴보도록 하겠다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Dependencies를 병렬처리로 다운로드가 가능하다.</span><br><span class="line">- Build Cache가 Production에 적용가능한 수준으로 향상되었다.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.gradle.org/4.0/release-notes.html#new-and-noteworthy" target="_blank" rel="external">https://docs.gradle.org/4.0/release-notes.html#new-and-noteworthy</a></p></blockquote><h4 id="Gradle은-Maven보다-100배이상-빠르다"><a href="#Gradle은-Maven보다-100배이상-빠르다" class="headerlink" title="Gradle은 Maven보다 100배이상 빠르다?"></a>Gradle은 Maven보다 100배이상 빠르다?</h4><p>Gradle에서는 아래와 같은 일반적인 시나리오에서 빌드 성능에 대한 테스트 결과를 공개하였다. 테스트에 사용된 하드웨어는 <code>Dell XPS 15, I7-4712HQ CPU @ 2.30GHz, 16GB of RAM, SSD, Linux Min 18.1</code> 이다.</p><blockquote><p><a href="https://gradle.org/gradle-vs-maven-performance/" target="_blank" rel="external">https://gradle.org/gradle-vs-maven-performance/</a></p></blockquote><h4 id="Scenario-Java-Library"><a href="#Scenario-Java-Library" class="headerlink" title="Scenario: Java Library"></a>Scenario: Java Library</h4><p>Apache Commons Lang 3를 Maven에서 Gradle로 변경하여 테스트한 결과이다. 테스트를 실행한 결과는 Gradle이 약 1.7배 정도 빠르며 Build Cache로 인한 빌드는 약 72배이상 빠르다.</p><p><img src="http://image.toast.com/aaaaahq/gradle4-1.png"></p><h4 id="Scenario-Small-multi-project-build"><a href="#Scenario-Small-multi-project-build" class="headerlink" title="Scenario: Small multi-project build"></a>Scenario: Small multi-project build</h4><p>50개의 소스 파일과 50개의 테스트를 가지고 있는 모듈 10개로 구성된 프로젝트를 테스트한 결과이다.</p><p><img src="http://image.toast.com/aaaaahq/gradle4-2.png"></p><p><img src="https://gradle.org/images/performance/maven-vs-gradle.gif"></p><h4 id="Scenario-Medium-multi-project-build"><a href="#Scenario-Medium-multi-project-build" class="headerlink" title="Scenario: Medium multi-project build"></a>Scenario: Medium multi-project build</h4><p>100개의 소스 파일과 100개의 테스트를 가지고 있는 모듈 100개로 구성된 프로젝트를 테스트한 결과이다.</p><p><img src="http://image.toast.com/aaaaahq/gradle4-3.png"></p><h4 id="Scenario-Large-multi-project-build"><a href="#Scenario-Large-multi-project-build" class="headerlink" title="Scenario: Large multi-project build"></a>Scenario: Large multi-project build</h4><p>100개의 소스 파일과 100개의 테스트를 가지고 있는 모듈 500개로 구성된 프로젝트를 테스트한 결과이다.</p><p><img src="http://image.toast.com/aaaaahq/gradle4-4.png"></p><h4 id="Scenario-Large-monolithic-application"><a href="#Scenario-Large-monolithic-application" class="headerlink" title="Scenario: Large monolithic application"></a>Scenario: Large monolithic application</h4><p>마지막으로 흔치는 않지만 모든 소스 코드가 하나의 모듈에 구성된 프로젝트의 테스트 결과이다.</p><p><img src="http://image.toast.com/aaaaahq/gradle4-5.png"></p><h4 id="결과를-요약하면-아래와-같다"><a href="#결과를-요약하면-아래와-같다" class="headerlink" title="결과를 요약하면 아래와 같다."></a>결과를 요약하면 아래와 같다.</h4><ul><li>모든 결과를 비추어 볼때 Gradle은 모든 시나리오에서 적어도 2배 이상 빠르다.</li><li>변경 사항을 반영한 빌드에서는 Gradle이 Maven에 비해 10~100배 빠르며, 하위 프로젝트가 많을수록 더욱 유리하다.</li></ul><h2 id="Your-Turn"><a href="#Your-Turn" class="headerlink" title="Your Turn"></a>Your Turn</h2><p>사실 이전의 Gradle의 빌드 타임은 체감상으로도 Maven 비해 느리게 느껴졌다. 위의 그래프에서 Gradle의 이전 버전이 포함되지 않은 점이 이를 증명해준다. v4.0에서 Maven보다 100배이상 빠르다는 표현은 과장되어 보이지만 Build Cache의 안정화로 인해 Gradle의 빌드 타임이 대폭 향상된 것은 사실이다. 구구절절 설명이 길었지만 Gradle을 v4.0으로 업그레이드하고 직접 빌드와 테스트를 실행하는 것을 추천한다.</p><h4 id="Gradle-Wrapper를-통해-업그레이드"><a href="#Gradle-Wrapper를-통해-업그레이드" class="headerlink" title="Gradle Wrapper를 통해 업그레이드"></a>Gradle Wrapper를 통해 업그레이드</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew wrapper --gradle-version=4.0 --distribution-type=bin</span><br></pre></td></tr></table></figure><h4 id="Homebrew로-업그레이드"><a href="#Homebrew로-업그레이드" class="headerlink" title="Homebrew로 업그레이드"></a>Homebrew로 업그레이드</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ brew upgrade gradle</span><br><span class="line">==&gt; Upgrading 1 outdated package, with result:</span><br><span class="line">gradle 4.0</span><br><span class="line">==&gt; Upgrading gradle</span><br><span class="line">==&gt; Using the sandbox</span><br><span class="line">==&gt; Downloading https://services.gradle.org/distributions/gradle-4.0-all.zip</span><br><span class="line">==&gt; Downloading from https://downloads.gradle.org/distributions/gradle-4.0-all.zip</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">🍺  /usr/<span class="built_in">local</span>/Cellar/gradle/4.0: 169 files, 71.8MB, built <span class="keyword">in</span> 48 seconds</span><br></pre></td></tr></table></figure><h4 id="업데이트된-버전을-확인해보자"><a href="#업데이트된-버전을-확인해보자" class="headerlink" title="업데이트된 버전을 확인해보자"></a>업데이트된 버전을 확인해보자</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gradle --version</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 4.0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="설치하기"><a href="#설치하기" class="headerlink" title="설치하기"></a>설치하기</h4><p>아직 Gradle을 설치하지 않았다면 Homebrew를 통해 설치하거나 수동으로 직접 <a href="https://gradle.org/releases/" target="_blank" rel="external">Download</a> 하여 설치할 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew update &amp;&amp; brew install gradle</span><br></pre></td></tr></table></figure><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><blockquote><p><a href="https://gradle.org/gradle-vs-maven-performance/" target="_blank" rel="external">https://gradle.org/gradle-vs-maven-performance/</a><br><a href="https://blog.gradle.org/introducing-gradle-build-cache" target="_blank" rel="external">https://blog.gradle.org/introducing-gradle-build-cache</a><br><a href="https://gradle.org/install/" target="_blank" rel="external">https://gradle.org/install/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gradle은 2017년 4월에 3.5 버전을 릴리즈하면서 &lt;code&gt;Build Cache&lt;/code&gt;의 특징을 소개하면서 Gradle의 빌드 속도가 드라마틱하게(?) 향상되었다고 발표하였다. Build Cache는 Gradle 3.5에 베타 테
      
    
    </summary>
    
      <category term="devops" scheme="https://www.holaxprogramming.com/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>파이썬 프로젝트의 구조</title>
    <link href="https://www.holaxprogramming.com/2017/06/28/python-project-structures/"/>
    <id>https://www.holaxprogramming.com/2017/06/28/python-project-structures/</id>
    <published>2017-06-28T06:24:49.000Z</published>
    <updated>2022-06-07T00:26:23.017Z</updated>
    
    <content type="html"><![CDATA[<p>지금까지 우리는 아래의 두 꼭지를 통해 테스트 코드를 먼저 작성하는 것으로 파이썬을 시작하였다.</p><a id="more"></a><ul><li><a href="https://www.holaxprogramming.com/2017/06/15/python-get-started/">파이썬 시작하기 TDD부터 PyPI에 배포까지 </a></li><li><a href="https://www.holaxprogramming.com/2017/06/17/python-with-test/">unittest와 함께하는 파이썬 테스트</a></li></ul><p>그리고 우리는 이 과정에서 <code>Walking Skeleton</code>을 통해 프로젝트를 지탱하는 구성 요소를 아래와 같이 정의하였다. 이번 글에서는 <code>unittest</code>와 함께 테스트 코드를 작성하는 과정에 이어 앞으로 발생되는 문제를 더욱 효율적으로 해결하기 위한 방법들을 살펴보도록 하자.</p><ul><li><del>테스트 전략</del></li><li>파이썬 프로젝트의 구조</li><li>파이썬 프로젝트를 지탱하는 실행 환경</li><li>빌드 또는 패키징, 배포</li></ul><h2 id="모듈과-패키지"><a href="#모듈과-패키지" class="headerlink" title="모듈과 패키지"></a>모듈과 패키지</h2><p>프로그래밍은 문제를 해결하는 과정을 프로그래밍 언어로 표현한 것이다. 그리고 대부분의 문제들은 다시 반복되며 우리는 이를 해결하기 위해 한 번 작성한 코드를 재사용하기 위해 노력하고 있다.</p><p><br></p><p><div align="center"><br><img src="http://image.toast.com/aaaaahq/python_project.png"><br></div><br><br></p><p>모듈(Module)은 파이썬에서 재사용이 가능한 기본 단위이다. <code>.py</code>라는 확장자를 갖는 단일 파일에 작성되며 여러 모듈들은 다시 패키지(Package)라는 단위로 관리된다. 우리가 지금까지 작성한 결과를 구조적으로 표현하면 다음과 같은 프로젝트의 형태를 가진다.</p><h4 id="파이썬-프로젝트의-구조"><a href="#파이썬-프로젝트의-구조" class="headerlink" title="파이썬 프로젝트의 구조"></a>파이썬 프로젝트의 구조</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ROOT</span><br><span class="line">├── setup.py</span><br><span class="line">└── algorithms</span><br><span class="line">   ├── __init__.py</span><br><span class="line">   ├── array.py</span><br><span class="line">└── tests</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── test_array.py</span><br></pre></td></tr></table></figure><p>TDD와 함께 파이썬을 시작하면서 우리는 먼저 <code>Array</code> 클래스를 테스트하는 코드를 작성하였다. 그 결과 <code>array.py</code> 모듈을 구현하였고 이는 <code>algorithms</code>이라는 이름을 갖는 패키지에 포함되어 있는 모습이다. 다음으로 우리는 새롭게 출현한 <code>__init__.py</code>와 <code>setup.py</code>에 주목할 필요가 있어 보인다.</p><h4 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h4><p>파이썬은 디렉토리에 <code>__init__.py</code> 파일이 존재하면 이를 패키지라 여긴다. 아래의 테스트 코드는 <code>algorithms</code>이라는 패키지로부터 테스트 대상인 <code>array</code>라는 모듈을 사용하고 있는 모습이다.</p><p><code>test_array.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> algorithms <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestArray</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create class instance</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.array = array.Array(<span class="string">'1 2 3 4 10 11'</span>)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p><p>요약하면 패키지로부터 모듈을 사용하기 위한 파이썬 키워드는 <code>from</code> 그리고 <code>import</code>이며 표현 방법은 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> [package_name] <span class="keyword">import</span> [module_name]</span><br></pre></td></tr></table></figure><p>그리고 외부에서 패키지를 참조하는 시점에 해당 패키지의 <code>__init__.py</code>이 실행된다는 점을 기억하도록 하자. 이를 이용해 패키지가 참조되는 시점에 필요한 내용이 있다면 아래와 같이 정의할 수 있다.</p><p><code>algorithms/__init__.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Description for Package</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> algorithms.array <span class="keyword">import</span> Array</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'array'</span>] <span class="comment"># 이 배열에 포함되는 모듈의 이름은 from algorithms import * 를 통해서도 참조될 수 있다.</span></span><br><span class="line">__version__ = <span class="string">'0.1.0'</span> <span class="comment"># 패키지의 버전을 정의한다.</span></span><br></pre></td></tr></table></figure></p><blockquote><p><a href="https://www.python.org/dev/peps/pep-0420/" target="_blank" rel="external">[PEP 420]</a> 파이썬 버전 3.3 이후에는 디렉토리에 __init__.py 파일이 없어도 패키지로 인식된다. 하지만 배포용 라이브러리를 개발한다면 하위 버전의 호환성을 위해 __init__.py 파일을 생성하는 것을 추천한다.</p></blockquote><h4 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a><code>setup.py</code></h4><p>패키지를 <code>__init__.py</code>를 통해서 식별하는 것과 같이 파이썬은 <code>setup.py</code>을 통해 프로젝트의 최상위 디렉토리를 결정한다. setup.py 의 역할은 프로젝트의 테스트, 빌드, 배포에 필요한 정보들을 담고 있으며 <code>setuptools</code>라는 패키지를 활용하여 이 모든 과정을 쉽게 관리할 수 있도록 도와준다.</p><h2 id="setuptools"><a href="#setuptools" class="headerlink" title="setuptools"></a>setuptools</h2><p>복잡한 문제를 해결하기 위해 프로젝트를 구조화하는 일은 쉬운일이 아니다. 파이썬에서는 아래와 같이 setuptools 패키지를 활용해 프로젝트의 테스트, 빌드, 배포 과정을 쉽게 관리할 수 있도록 도와준다.</p><p><code>setup.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> find_packages, setup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read in the README for the long description on PyPI</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_description</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> io.open(<span class="string">'README.rst'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        readme = f.read()</span><br><span class="line">    <span class="keyword">return</span> readme</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">'algorithms'</span>,</span><br><span class="line">      version=<span class="string">'0.1'</span>,</span><br><span class="line">      description=<span class="string">'practice python with solving algorithms'</span>,</span><br><span class="line">      long_description=long_description(),</span><br><span class="line">      url=<span class="string">'https://github.com/stunstunstun/awesome-algorithms'</span>,</span><br><span class="line">      author=<span class="string">'stunstunstun'</span>,</span><br><span class="line">      author_email=<span class="string">'agileboys.com@gmail.com'</span>,</span><br><span class="line">      license=<span class="string">'MIT'</span>,</span><br><span class="line">      packages=find_packages(),</span><br><span class="line">      classifiers=[</span><br><span class="line">          <span class="string">'Programming Language :: Python :: 2.7'</span>,</span><br><span class="line">          <span class="string">'Programming Language :: Python :: 3'</span>,</span><br><span class="line">          <span class="string">'Programming Language :: Python :: 3.6'</span>,</span><br><span class="line">          ],</span><br><span class="line">      zip_safe=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h4 id="setup"><a href="#setup" class="headerlink" title="setup()"></a><code>setup()</code></h4><p><code>setup()</code> Function의 Arguments는 프로젝트의 자세한 정보를 어떻게 정의할 것인지를 결정한다.</p><table><thead><tr><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>name</td><td>패키지의 이름</td></tr><tr><td>version</td><td>패키지의 배포 버전</td></tr><tr><td>description</td><td>패키지에 대한 설명</td></tr><tr><td>url</td><td>패키지를 대표하는 웹페이지</td></tr><tr><td>author</td><td>패키지의 작성자</td></tr><tr><td>license</td><td>패키지의 라이센스</td></tr><tr><td>packages</td><td>프로젝트에 포함되는 패키지 리스트</td></tr><tr><td>install_requires</td><td>실행 환경에 필요한 최소한의 패키지 리스트</td></tr><tr><td>python_requires</td><td>실행 환경에 필요한 파이썬 버전</td></tr></tbody></table><blockquote><p><a href="https://packaging.python.org/tutorials/distributing-packages/#setup-args" target="_blank" rel="external">https://packaging.python.org/tutorials/distributing-packages/#setup-args</a></p></blockquote><h4 id="CLI-Command-Line-Interface"><a href="#CLI-Command-Line-Interface" class="headerlink" title="CLI(Command Line Interface)"></a>CLI(Command Line Interface)</h4><p>이렇게 setuptools 를 활용한 setup.py 는 파이썬에 의해 실행되는 CLI 프로그램의 역할을 하는데 기본적으로 제공되는 명령은 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py --<span class="built_in">help</span>-commands</span><br><span class="line">Standard commands:</span><br><span class="line">  build             build everything needed to install</span><br><span class="line">  build_py          <span class="string">"build"</span> pure Python modules (copy to build directory)</span><br><span class="line">  build_ext         build C/C++ and Cython extensions (compile/link to build directory)</span><br><span class="line">  build_clib        build C/C++ libraries used by Python extensions</span><br><span class="line">  build_scripts     <span class="string">"build"</span> scripts (copy and fixup <span class="comment">#! line)</span></span><br><span class="line">  clean             clean up temporary files from <span class="string">'build'</span> <span class="built_in">command</span></span><br><span class="line">  install           install everything from build directory</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>프로젝트의 실행 환경에서 필요한 패키지를 설치할 수도 있으며</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py install</span><br></pre></td></tr></table></figure><p>아래와 같이 프로젝트를 빌드하거나 테스트하기 위한 명령을 제공하기도 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py build</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py <span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>파이썬은 인터프리터 언어이기 때문에 여기서 말하는 빌드는 컴파일 과정은 아니며 저장소에 배포하기 위해 패키징하는 단계를 말한다.</p></blockquote><p>위의 명령들은 프로젝트를 테스트, 빌드, 배포를 쉽게 할수 있도록 도와주며 이를 통해 파이썬 저장소인 PyPI 에 자신이 구현한 파이썬 패키지를 배포할 수 있다. setup.py 를 통해 패키지를 배포하기 위한 전략은 이후 <code>PyPI에 파이썬 모듈 배포하기</code>에서 자세히 다루도록 하겠다.</p><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><p>우리는 앞으로 반복되는 문제를 패키지와 모듈을 통해 효율적으로 해결할 수 있게 되었다. 하지만 프로그래밍을 통해 모든 문제를 직접 해결하는 것은 매우 어렵다. 현재는 Github 저장소를 통해 유용한 오픈 소스들이 넘쳐나고 있으며 대부분의 글로벌 서비스 역시 이러한 오픈 소스를 적극적으로 활용하고 있다. 예를 들어 당신의 애플리케이션에서 HTTP 요청을 위해 <code>requests</code>와 같은 유용한 패키지를 활용할 수 있으며 반대로 자신이 개발한 패키지를 다른 이들을 위해 배포할 수도 있다.</p><p>우리는 당신의 직면한 문제를 해결하기 위해 node의 <code>npm</code>과 유사한 파이썬 저장소인 PyPI 로부터 패키지를 다운로드해 프로젝트에 통합하는 과정을 살펴보도록 하겠다. 이를 위해 <code>pip</code>이라는 도구를 활용하는데 pip은 이미 당신의 운영체제에 파이썬과 함께 설치가 된 상태이다. pip을 활용한 명령을 살펴보도록 하자.</p><h4 id="pip의-버전을-확인하자"><a href="#pip의-버전을-확인하자" class="headerlink" title="pip의 버전을 확인하자"></a>pip의 버전을 확인하자</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip --version</span><br></pre></td></tr></table></figure><h4 id="pip을-최신의-버전으로-업데이트하자"><a href="#pip을-최신의-버전으로-업데이트하자" class="headerlink" title="pip을 최신의 버전으로 업데이트하자"></a>pip을 최신의 버전으로 업데이트하자</h4><p><code>On Linux or OS X</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U pip</span><br></pre></td></tr></table></figure></p><p><code>On Windows</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m pip install -U pip</span><br></pre></td></tr></table></figure></p><h4 id="PyPI-Python-Package-Index에-등록된-패키지를-설치하자"><a href="#PyPI-Python-Package-Index에-등록된-패키지를-설치하자" class="headerlink" title="PyPI, Python Package Index에 등록된 패키지를 설치하자"></a>PyPI, Python Package Index에 등록된 패키지를 설치하자</h4><p><a href="https://pypi.python.org/pypi" target="_blank" rel="external">PyPI</a>는 파이썬으로 작성된 프로그램을 위한 일종의 저장소이다. 2017년 6월을 기준으로 현재 PyPI에는 111003개의 패지지가 등록된 상태이다. 우리는 HTTP 요청을 위한 <code>requests</code>라는 패키지를 설치하는 예제를 살펴보도록 하겠다.</p><p>최신 버전의 패키지를 설치하기 위한 명령은 아래와 같으며</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install requests</span><br></pre></td></tr></table></figure><p>패키지의 특정 버전을 지정하여 설치할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install requests==2.18.0</span><br></pre></td></tr></table></figure><p>패키지가 설치되면 프로젝트 뿐만 아니라 아래와 같이 로컬 PC의 파이썬 인터프리터에서도 사용할 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import requests</span><br><span class="line">&gt;&gt;&gt; session = requests.Session()</span><br><span class="line">&gt;&gt;&gt; response = session.get(<span class="string">'https://httpbin.org/cookies'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(response.text)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cookies"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Requirments-Files을-이용한-패키지-설치"><a href="#Requirments-Files을-이용한-패키지-설치" class="headerlink" title="Requirments Files을 이용한 패키지 설치"></a>Requirments Files을 이용한 패키지 설치</h4><p>우리는 필요에 따라 <code>requests</code> 뿐만 아니라 다양한 패키지를 프로젝트에 통합하기를 원할 것이다. 파이썬은 프로젝트 내부에서 패키지 리스트를 관리하기 위한 파일 형식을 제공하는데 이는 <code>Requirement Files</code>로 불린다. 아래와 같이 <code>.txt</code> 확장자를 갖는 파일을 생성해보자.</p><p><code>requirements.txt</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests</span><br></pre></td></tr></table></figure></p><p>앞으로 requirements.txt 를 통해 프로젝트에 필요한 패키지를 추가할 수 있게 되었으며 아래의 명령을 통해 다양한 패키지를 동시에 설치할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h4 id="지금까지의-과정을-통해-우리가-활용한-명령은-아래와-같다"><a href="#지금까지의-과정을-통해-우리가-활용한-명령은-아래와-같다" class="headerlink" title="지금까지의 과정을 통해 우리가 활용한 명령은 아래와 같다."></a>지금까지의 과정을 통해 우리가 활용한 명령은 아래와 같다.</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="comment"># 파이썬 인터프리터를 실행한다</span></span><br><span class="line">$ python hello_world.py <span class="comment"># 파일로 작성된 파이썬 프로그램을 실행한다</span></span><br><span class="line">$ python -m unittest <span class="comment"># 모든 테스트 코드를 실행한다</span></span><br><span class="line">$ python -m unittest tests/test_array.py <span class="comment"># 특정 테스트 코드를 실행한다</span></span><br><span class="line">$ python setup.py install <span class="comment"># 프로젝트에 포함되는 모든 패키지를 설치한다</span></span><br><span class="line">$ python setup.py <span class="built_in">test</span> <span class="comment"># 프로젝트의 모든 테스트를 실행한다</span></span><br><span class="line">$ pip install [package_name] <span class="comment"># PyPI로부터 패키지를 설치한다</span></span><br><span class="line">$ pip install -U [package_name] <span class="comment"># PyPI로부터 패키지를 업데이트한다</span></span><br><span class="line">$ pip install -r requirements.txt <span class="comment"># Requirements 파일에 정의된 패키지 리스트를 설치한다</span></span><br><span class="line">$ pip install -U -r requirements.txt <span class="comment"># Requirements 파일에 정의된 패키지 리스트를 업데이트한다</span></span><br></pre></td></tr></table></figure><h4 id="지금까지의-과정을-프로젝트로-구조화한-결과이다"><a href="#지금까지의-과정을-프로젝트로-구조화한-결과이다" class="headerlink" title="지금까지의 과정을 프로젝트로 구조화한 결과이다."></a>지금까지의 과정을 프로젝트로 구조화한 결과이다.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ROOT</span><br><span class="line">├── setup.py</span><br><span class="line">├── requirements.txt</span><br><span class="line">└── algorithms</span><br><span class="line">   ├── __init__.py</span><br><span class="line">   ├── array.py</span><br><span class="line">└── tests</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── test_array.py</span><br></pre></td></tr></table></figure><p>우리는 이렇게 지금까지 테스트 코드를 작성하는 것을 시작으로 다양한 문제를 해결하면서 그 과정을 프로젝트의 형태로 구조화하였다. 다음 글에서는 더욱 효율적으로 프로젝트를 관리하기 위해 파이썬의 실행 환경을 일관적으로 유지하는 이야기를 할 예정이다.</p><ul><li><del>테스트 전략</del></li><li><del>파이썬 프로젝트의 구조</del></li><li><strong>파이썬 프로젝트를 지탱하는 실행 환경</strong></li><li>빌드 또는 패키징, 배포</li></ul><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><blockquote><p><a href="https://packaging.python.org/tutorials/installing-packages/#requirements-for-installing-packages" target="_blank" rel="external">https://packaging.python.org/tutorials/installing-packages/#requirements-for-installing-packages</a><br><a href="https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format" target="_blank" rel="external">https://pip.pypa.io/en/latest/reference/pip_install/#requirements-file-format</a><br><a href="http://python-guide-pt-br.readthedocs.io/en/latest/writing/structure/" target="_blank" rel="external">http://python-guide-pt-br.readthedocs.io/en/latest/writing/structure/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;지금까지 우리는 아래의 두 꼭지를 통해 테스트 코드를 먼저 작성하는 것으로 파이썬을 시작하였다.&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.holaxprogramming.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>unittest와 함께하는 파이썬 테스트</title>
    <link href="https://www.holaxprogramming.com/2017/06/17/python-with-test/"/>
    <id>https://www.holaxprogramming.com/2017/06/17/python-with-test/</id>
    <published>2017-06-17T06:24:49.000Z</published>
    <updated>2022-06-07T00:26:23.019Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.holaxprogramming.com/2017/06/15/python-get-started/">지난 글</a>에서는 TDD와 함께 파이썬의 개발 환경을 준비하고 첫 테스트 케이스를 작성하였다. 테스트 코드를 먼저 작성함으로써 다양한 문제에 자연스럽게 노출될 수 있었는데 여전히 테스트를 실행하기 위한 의문을 남겨놓은 상태이다. 의문을 풀기 위해 테스트를 위한 표준 라이브러리인 <code>unittest</code>에 대해 자세히 살펴볼 필요가 있다. Google의 검색창에서 아래의 키워드를 통해 검색해본다. </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python unittest</span><br></pre></td></tr></table></figure><p>검색한 결과에서 가장 상위에 노출되고 있는 <a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="external"><code>26.4. unittest — Unit testing framework — Python 3.6.1 documentation</code></a>를 참고하기로 했다. 문서에 의하면 테스트를 실행하기 위한 클래스는 <code>unittest</code> 패키지의 <code>TestCase</code> 클래스를 상속받는다. 자 그럼 다시 테스트 클래스를 살펴볼 차례다.</p><p><code>test_array.py</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from algorithms import array</span><br><span class="line"></span><br><span class="line">class TestArray(unittest.TestCase):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Test that the result sum of all numbers</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def test_sum(self):</span><br><span class="line">        instance = array.Array()</span><br><span class="line">        result = instance.sum(6, &apos;1 2 3 4 10 11&apos;)</span><br><span class="line">        self.assertEqual(result, 31)</span><br></pre></td></tr></table></figure></p><p>TestCase 클래스를 상속받아 구현하였으며 구현 클래스의 첫 테스트 케이스를 검증하기 위한 <code>test_sum</code> Function을 가지고 있다. 테스트 코드를 실행하기 위한 커맨드 라인 명령은 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest</span><br></pre></td></tr></table></figure><p>실행해야 할 테스트가 많다면 위와 같이 모든 테스트를 실행할 수도 있으며 아래와 같이 특정 Test Case만 실행할 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest tests/test_array.py</span><br></pre></td></tr></table></figure><p>자 그럼 테스트를 실행해볼 차례다!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FF</span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_sum (tests.test_array.TestArray)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/jungminhyuck/github/awesome-algorithms/tests/test_array.py"</span>, line 10, <span class="keyword">in</span> test_sum</span><br><span class="line">    self.assertEqual(result, 31)</span><br><span class="line">AssertionError: 0 != 31</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 tests <span class="keyword">in</span> 0.005s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br></pre></td></tr></table></figure><p>테스트가 역시 실패하였다(..) 하지만 긍정적인 점은 앞으로 <code>sum</code> Function을 검증하기 위해 프로그램 내부에서 직접 확인할 필요도 없으며 위와 같이 테스트를 실행하는 것만으로 <code>실패한 원인과 위치</code>를 쉽게 알 수 있게 되었다. 이제는 구현 클래스로 돌아가 볼 차례다.</p><p><code>array.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, size, array_string)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Array 클래스의 <code>sum</code>은 아무 일도 하지 않고 <code>0</code>을 반환하기 때문에 우리가 기대하는 대로 동작하지 않고 있다. Function을 아래와 같이 수정한 뒤 다시 테스트해 보았다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, size, array_string)</span>:</span></span><br><span class="line">        numbers = [int(number) <span class="keyword">for</span> number <span class="keyword">in</span> array_string.split(<span class="string">' '</span>)]</span><br><span class="line">        <span class="keyword">return</span> sum(numbers)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest</span><br><span class="line">..</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 tests <span class="keyword">in</span> 0.000s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>드디어 테스트가 성공하였다! PyCharm을 사용한다면 처음으로 초록 막대기를 보게 되는 행복한 일도 생겼다. 이제 다시 Array 클래스의 요구사항을 살펴볼 차례다.</p><ul><li>[x] 첫 번째 Argument는 덧셈에 필요한 숫자의 개수를 전달한다.</li><li>[x] 두 번째 Argument는 덧셈에 필요한 숫자를 공백을 포함한 문자열의 형태로 전달한다.</li><li>[x] 두 번째 Argument로 전달된 숫자들의 합을 반환한다.</li><li>[ ] 첫 번째 Argument의 숫자와 두 번째 Argument의 숫자의 개수가 같은지 체크하고 틀리다면 예외를 발생시킨다.</li></ul><p>우리는 지금까지 많은 문제들을 해결하였지만 현재의 테스트 케이스로는 마지막 문제를 검증할 수 없는 상태이다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">첫 번째 Argument의 숫자와 두 번째 Argument의 숫자의 개수가 같은지 체크하고 틀리다면 예외를 발생시킨다.</span><br></pre></td></tr></table></figure><p>즉 아래와 같이 첫 번째 인자의 값과 두 번째 인자의 문자열에 포함되는 숫자들의 개수가 다르면 <code>sum</code>에서는 예외를 발생시켜야 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance = array.Array()</span><br><span class="line">instance.sum(<span class="number">5</span>, <span class="string">'1 2 3 4 10 11'</span>)</span><br></pre></td></tr></table></figure><p>앞서 미리 살펴본 <code>unittest</code>의 <a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="external">문서</a>를 통해 TestCase 클래스에서는 <code>assertRaises</code>와 파이썬의 람다식을 통해 아래와 같이 예외가 발생하는지에 대한 여부를 검증할 수가 있었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestArray</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Tests that an exception occurs when the number of arguments is different</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_raise_exception</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertRaises(Exception, <span class="keyword">lambda</span>: array.Array().sum(<span class="number">5</span>, <span class="string">'1 2 3 4 10 11'</span>))</span><br></pre></td></tr></table></figure><p>테스트 코드를 작성하였으니 주저 말고 테스트를 실행해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest</span><br><span class="line">.F</span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_sum_raise_exception (tests.test_array.TestArray)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/jungminhyuck/github/awesome-algorithms/tests/test_array.py&quot;, line 19, in test_sum_raise_exception</span><br><span class="line">    self.assertRaises(Exception, lambda: array.Array().sum(5, &apos;1 2 3 4 10 11&apos;))</span><br><span class="line">AssertionError: Exception not raised by &lt;lambda&gt;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.003s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br></pre></td></tr></table></figure><p>기존의 <code>test_sum</code>에서는 테스트가 성공하였지만 마지막 문제를 검증하기 위한 <code>test_sum_raise_exception</code>에서는 테스트가 실패한 것을 볼 수 있다. 이대로라면 <code>sum</code> Function은 올바르지 않은 Argument가 전달되어도 정상으로 작동되는 무서운 결과를 초래할 수 있어 보인다.</p><p>파이썬에서 예외를 발생하기 위한 방법은 무엇일까? 이번에는 검색 결과로 얻은 <a href="https://docs.python.org/3/tutorial/errors.html" target="_blank" rel="external"><code>8. Errors and Exceptions — Python 3.6.1 documentation</code></a>이라는 문서를 참고해 보았다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, size, array_string)</span>:</span></span><br><span class="line">        numbers = [int(number) <span class="keyword">for</span> number <span class="keyword">in</span> array_string.split(<span class="string">' '</span>)]</span><br><span class="line">        <span class="keyword">if</span> size != len(numbers):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'array size is not matched'</span>)</span><br><span class="line">        <span class="keyword">return</span> sum(numbers)</span><br></pre></td></tr></table></figure><p>위와 같이 예외를 발생시키기 위해 파이썬의 <code>raise</code> 키워드와 Built-in 클래스인 <code>Exception</code>을 통해서 <code>sum</code>의 첫 번째 인자의 값과 두 번째 인자의 문자열에 포함되는 숫자들의 개수가 다르면 예외를 발생시키는 모습이다. 다시 테스트해보자!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest </span><br><span class="line">..</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests in 0.001s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><br></p><p>테스트가 성공한 행복한 일이 벌어졌으니 이 쯤에서 TestCase 클래스를 자세히 살펴봐도 좋아 보인다. 먼저 TestCase 클래스에서 제공하는 assert Functions의 리스트는 아래와 같다.</p><table><thead><tr><th>Method</th><th>Checks that</th><th>New in</th></tr></thead><tbody><tr><td>assertEqual(a, b)</td><td>a == b</td><td></td></tr><tr><td>assertNotEqual(a, b)</td><td>a != b</td><td></td></tr><tr><td>assertTrue(x)</td><td>bool(x) is True</td><td></td></tr><tr><td>assertFalse(x)</td><td>bool(x) is False</td><td></td></tr><tr><td>assertIs(a, b)</td><td>a is b</td><td>3.1</td></tr><tr><td>assertIsNot(a, b)</td><td>a is not b</td><td>3.1</td></tr><tr><td>assertIsNone(x)</td><td>x is None</td><td>3.1</td></tr><tr><td>assertIsNotNone(x)</td><td>x is not None</td><td>3.1</td></tr><tr><td>assertIn(a, b)</td><td>a in b</td><td>3.1</td></tr><tr><td>assertNotIn(a, b)</td><td>a not in b</td><td>3.1</td></tr><tr><td>assertIsInstance(a, b)</td><td>isinstance(a, b)</td><td>3.2</td></tr><tr><td>assertNotIsInstance(a, b)</td><td>not isinstance(a, b)</td><td>3.2</td></tr></tbody></table><p>그리고 테스트 전과 후에 필요한 행동이 있다면 TestCase 클래스의 <code>setUp()</code> <code>tearDown()</code> Functions를 활용할 수도 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestArray</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create class instance</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.array = array.Array(<span class="string">'1 2 3 4 10 11'</span>)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Test that the result sum of all numbers</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self.array.sum(<span class="number">6</span>)</span><br><span class="line">        self.assertEqual(result, <span class="number">31</span>)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Tests that an exception occurs when the number of arguments is different</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_raise_exception</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertRaises(Exception, <span class="keyword">lambda</span>: self.array.sum(<span class="number">5</span>))</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Print array elements</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'elements = &#123;&#125;'</span>.format(self.array))</span><br></pre></td></tr></table></figure><p><br></p><p><code>TestCase</code>는 <code>unittest.main()</code>이 동작하는 과정에서 자동으로 수집해 실행하지만 아래와 같이 사용자가 원하는 TestCase를 정의해 실행할 수도 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">suite</span><span class="params">()</span>:</span></span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    suite.addTest(TestArray())</span><br><span class="line">    suite.addTest(TestHttp())</span><br><span class="line">    <span class="keyword">return</span> suite</span><br></pre></td></tr></table></figure><p><br></p><p>마지막으로 우리가 지금까지 살펴 본 <code>unittest</code>를 통한 테스트의 전체적인 흐름을 표현하면 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> test_case <span class="keyword">in</span> test_suite:</span><br><span class="line">        <span class="keyword">for</span> test_method <span class="keyword">in</span> test_case.test_methods:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                test_case.setUp()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                ..예외를 기록한다</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    test_method()</span><br><span class="line">                <span class="keyword">except</span> AssertionError:</span><br><span class="line">                    ..실패 케이스를 기록한다</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    ..예외를 기록한다</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ..성공 케이스를 기록한다</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        test_case.tearDown()</span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        ..예외를 기록한다</span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure><p><br></p><p>지금까지 테스트 코드를 먼저 작성하는 것으로 파이썬에 적응해 나아가는 모습을 살펴보았다. 모든 내용을 정리하지는 못했지만 이 과정에서 파이썬의 Built-in Keyword 부터 Function, Classes, Variables를 표현하는 연습도 저절로 할 수 있었다.</p><p>파이썬을 A부터 Z까지 학습한 뒤 프로젝트에 활용할 수도 있겠지만 TDD를 통해 다양한 문제에 노출되면서 주도적으로 학습에 필요한 내용을 찾아보았다. 예제는 단순했지만 앞으로 우리가 작성하는 코드는 점점 복잡해지며 나중에는 <code>레거시</code>라는 괴물로 변하기도 한다.</p><p>TDD를 통해 지속적으로 변경이 용이한 코드를 작성하는 것을 기대하면서 이 글을 마무리한다. 다음 글에서는 파이썬 프로젝트의 구조와 파이썬의 실행 환경을 지탱하는 다양한 도구들을 살펴보도록 하겠다.</p><blockquote><p><a href="https://www.holaxprogramming.com/2017/06/28/python-project-structures/">https://www.holaxprogramming.com/2017/06/28/python-project-structures/</a></p></blockquote><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><blockquote><p><a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="external">https://docs.python.org/3/library/unittest.html</a><br><a href="https://docs.python.org/3/tutorial/errors.html" target="_blank" rel="external">https://docs.python.org/3/tutorial/errors.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.holaxprogramming.com/2017/06/15/python-get-started/&quot;&gt;지난 글&lt;/a&gt;에서는 TDD와 함께 파이썬의 개발 환경을 준비하고 첫 테스트 케이스를 작성하였다. 테스트 코드를 먼저 작성함으로써 다양한 문제에 자연스럽게 노출될 수 있었는데 여전히 테스트를 실행하기 위한 의문을 남겨놓은 상태이다. 의문을 풀기 위해 테스트를 위한 표준 라이브러리인 &lt;code&gt;unittest&lt;/code&gt;에 대해 자세히 살펴볼 필요가 있다. Google의 검색창에서 아래의 키워드를 통해 검색해본다. &lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.holaxprogramming.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>파이썬 시작하기 TDD부터 PyPI에 배포까지</title>
    <link href="https://www.holaxprogramming.com/2017/06/15/python-get-started/"/>
    <id>https://www.holaxprogramming.com/2017/06/15/python-get-started/</id>
    <published>2017-06-14T15:24:49.000Z</published>
    <updated>2022-06-07T00:26:23.016Z</updated>
    
    <content type="html"><![CDATA[<p>필자는 보통 새로운 언어를 학습하기 위해서 먼저 프로그래밍을 위한 개발 환경을 설치하고 그 이후에는 <code>TDD(Test Driven Development)</code>를 통해 다양한 문제에 노출되는 것으로 시작한다. TDD는 소프트웨어를 개발하는 방법론 중 하나이며, 우리가 작성하게 되는 모든 코드는 올바르게 작동하는지에 대한 검증이 필요한데 보통 이러한 과정을 <code>테스트</code>라고 불린다. </p><a id="more"></a><p>테스트는 직접 기능을 사용하면서 사용자 관점에서 테스트하기도 하며 개발자가 직접 테스트하거나 혹은 테스트를 위한 팀이 있을 수도 있다. 여기서 결론은 누군가는 당신이 작성한 코드를 테스트해야 한다는 것이다. TDD는 여기서 개발자가 자신의 코드를 직접 테스트하는 것을 말하며 문자 그대로 <code>테스트</code>를 위한 코드를 먼저 작성하는 것을 의미한다. </p><p>개인적으로는 TDD를 테스트 코드를 먼저 작성하는 습관이라고 말하고 싶다. TDD를 통해 새로운 프로그래밍 언어를 학습하면 아래와 같은 장점이 있다.</p><ul><li>테스트 코드는 비교적 쉬운 기본적인 문법으로 시작할 수 있다</li><li>기존의 자신에게 익숙했던 언어와 새로운 언어에 대한 차이를 쉽게 파악할 수 있다.</li><li>기본적인 문법의 부재부터 그리고 예상하지 못한 다양한 문제에 부딪히면서 주도적으로 학습할 수 있게 도와준다.</li><li>테스트 코드를 실행하기 위한 고민을 시작으로 새로운 개발 환경에 자연스럽게 익숙해질 수 있다.</li></ul><blockquote><p>TDD에 대해 자세히 알고 싶다면 <code>Test Driven Development By Example</code>이라는 Kent Beck의 저서를 추천한다.<br><a href="https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530" target="_blank" rel="external">https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530</a></p></blockquote><p>이 글에서는 TDD를 시작으로 새로운 언어를 접근하는 개인적인 습관에 대한 내용을 파이썬을 시작하면서 정리하고자 한다.</p><h2 id="파이썬-설치하기"><a href="#파이썬-설치하기" class="headerlink" title="파이썬 설치하기"></a>파이썬 설치하기</h2><p>우리는 파이썬 프로그래밍을 위한 기본적인 환경이 필요하기 때문에, 먼저 운영체제에 파이썬과 개발 도구를 설치하는 과정을 살펴보자.</p><h4 id="파이썬-Interpreter-설치"><a href="#파이썬-Interpreter-설치" class="headerlink" title="파이썬 Interpreter 설치"></a>파이썬 Interpreter 설치</h4><p>파이썬은 공식 사이트인 <a href="https://www.python.org/" target="_blank" rel="external">python.org</a>에서 다운로드할 수 있다. 설치가 매우 간단하며 OSX 사용자라면 이미 파이썬이 설치되어 있을 것이다. 설치 후 커맨드 라인에서 아래와 같이 입력하면, 파이썬 Interpeter를 통해 프로그래밍할 수 있는 환경이 갖추어진다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">Python 3.6.0 |Anaconda 4.3.1 (x86_64)| (default, Dec 23 2016, 13:19:00) </span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; _</span><br></pre></td></tr></table></figure><h4 id="IDLE과-PyCharm-IDE"><a href="#IDLE과-PyCharm-IDE" class="headerlink" title="IDLE과 PyCharm IDE"></a>IDLE과 PyCharm IDE</h4><p>Interpreter 언어인 파이썬은 위와 같은 Interactive 모드를 통해 별도의 도구 없이 한 줄 한 줄 프로그래밍하도록 도와준다. 하지만 앞으로의 대부분의 구현은 파일에 작성하게 되는데, 파이썬에는 파일에 작성하기 위한 기본 도구인 IDLE를 포함하고 있지만 JetBrain의 <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm IDE</a>를 사용하는 것을 추천한다. 자 뻔한 과정은 생략하고 아래와 같이 <code>Hello World</code>를 출력하는 첫 파이썬 프로그램을 작성해보자.</p><p><code>hello_world.py</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;Hello World&apos;)</span><br></pre></td></tr></table></figure></p><p>파일에 작성된 코드 역시 파이썬 Interpreter에 의해서 실행되며 방법은 아래와 같다. 정상적으로 출력이 된다면 우리는 파이썬 프로그래밍을 위한 모든 준비를 마쳤다!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python hello_world.py</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="파이썬으로-TDD-맛보기"><a href="#파이썬으로-TDD-맛보기" class="headerlink" title="파이썬으로 TDD 맛보기"></a>파이썬으로 TDD 맛보기</h2><p>TDD는 테스트 코드를 먼저 작성하는 습관이라고 말했는데 아주 간단한 예제를 보면서 살펴보자. 지금부터 작성하는 예제에 대한 요구사항은 아래와 같다.</p><p>Array라는 클래스는 <code>sum</code>이라는 Function을 갖는데 <code>sum</code>의 입력 값은 아래와 같다.</p><ul><li>첫 번째 Argument는 덧셈에 필요한 숫자의 개수를 전달한다.</li><li>두 번째 Argument는 덧셈에 필요한 숫자를 공백을 포함한 문자열의 형태로 전달한다.</li></ul><p>그리고 출력 값은 아래와 같다.</p><ul><li>두 번째 Argument로 전달된 숫자들의 합을 반환한다.</li><li>첫 번째 Argument의 숫자와 두 번째 Argument의 숫자의 개수가 같은지 체크하고 틀리다면 예외를 발생시킨다.</li></ul><p>예상되는 <code>INPUT</code>과 <code>OUTPUT</code>의 형태를 통해 정리해보자.</p><h4 id="INPUT"><a href="#INPUT" class="headerlink" title="INPUT"></a>INPUT</h4><p>이와 같이 첫 번째 Argument가 6이라면 두 번째 Argument에는 6개의 숫자와 공백을 포함하는 문자열을 전달한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>만약 아래와 같이 숫자의 개수가 틀리다면 예외가 발생할 것이다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">10</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><h4 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h4><p>결과는 두 번째 Argument를 통해 전달된 숫자들의 합인 31이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure><h4 id="첫-테스트-케이스-만들기"><a href="#첫-테스트-케이스-만들기" class="headerlink" title="첫 테스트 케이스 만들기"></a>첫 테스트 케이스 만들기</h4><p>일단 무작정 테스트 코드부터 먼저 작성해 보았다. Array 클래스를 통해 인스턴스를 하나 생성하고 2개의 Argument를 전달해 <code>sum</code> Function을 테스트하는 클래스이다.</p><p><code>test_array.py</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class TestArray(unittest.TestCase):</span><br><span class="line">    def test_sum(self):</span><br><span class="line">        instance = Array()</span><br><span class="line">        result = instance.sum(6, &apos;1 2 3 4 10 11&apos;)</span><br><span class="line">        self.assertEqual(result, 31)</span><br></pre></td></tr></table></figure></p><p>어이쿠 역시 PyCharm IDE에서 <code>unittest</code>라는 패키지를 참조할 수 없다고 붉은색으로 무섭게 표시하면서 알려준다. 파이썬에서 제공하는 외부 패키지에 대한 <a href="https://docs.python.org/3/tutorial/modules.html" target="_blank" rel="external">문서</a>를 참고한 뒤 다시 코드를 작성해본다.</p><p><code>test_array.py</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestArray(unittest.TestCase):</span><br><span class="line">    def test_sum(self):</span><br><span class="line">        instance = Array()</span><br><span class="line">        result = instance.sum(6, &apos;1 2 3 4 10 11&apos;)</span><br><span class="line">        self.assertEqual(result, 31)</span><br></pre></td></tr></table></figure></p><p>다행히 파이썬의 내장 키워드인 <code>import</code>를 통해서 <code>unittest</code> 패키지를 참조한 뒤에는 붉은색의 경고는 사라졌지만 여전히 Array 클래스는 아직 존재하지 않는다.</p><h4 id="실제-작동하는-구현-코드"><a href="#실제-작동하는-구현-코드" class="headerlink" title="실제 작동하는 구현 코드"></a>실제 작동하는 구현 코드</h4><p>테스트 클래스에 이어서 실제 동작하는 Array 클래스를 작성하였다. 실제 구현은 잠시 미뤄두고 테스트 클래스에서 참조 가능한 상태로 만들고 싶다.</p><p><code>array.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, size, array_string)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>하지만 여전히 IDE에서는 Array 클래스를 참조할 수 없다고 한다. <code>unittest</code>에서 얻은 경험으로 파이썬의 <code>import</code> 키워드를 통해 Array 클래스를 참조하였다.</p><p><code>test_array.py</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">from algorithms import array</span><br><span class="line"></span><br><span class="line">class TestArray(unittest.TestCase):</span><br><span class="line">    def test_sum(self):</span><br><span class="line">        instance = array.Array()</span><br><span class="line">        result = instance.sum(6, &apos;1 2 3 4 10 11&apos;)</span><br><span class="line">        self.assertEqual(result, 31)</span><br></pre></td></tr></table></figure><p>이제야 IDE에서 붉은색 경고가 더 이상 보이지 않는 행복한 일이 벌어졌다. 그런데 여기서 의문점이 생기지 않나? 아래와 같이 말이다.</p><ul><li>테스트는 어떻게 실행해야 할까?</li><li>파이썬 프로젝트는 앞으로 어떻게 효율적으로 관리해야 할까?</li></ul><p>다행히 테스트를 위해서는 파이썬의 표준 라이브러리(Standard Library) 중 하나인 <code>unittest</code>를 사용했지만 앞으로는 더욱 다양한 모듈과 모듈 간의 의존성을 관리해야 한다. 경우에 따라서는 외부의 저장소에서 모듈을 다운로드해야 할 필요도 있을 것이다.</p><p>이와 같이 테스트 코드를 통해 프로젝트를 관리하기 위한 고민을 시작하면 쉽게 다양한 문제에 노출되어 새로운 환경에서 필요한 요소들을 주도적으로 찾아갈 수 있다.</p><h4 id="Walking-Skeleton"><a href="#Walking-Skeleton" class="headerlink" title="Walking Skeleton"></a>Walking Skeleton</h4><p><img src="https://d341kum51qu34d.cloudfront.net/images/posts/skeleton-83d0cd49.gif" width="500"></p><blockquote><p><a href="http://alistair.cockburn.us/Walking+skeleton" target="_blank" rel="external">http://alistair.cockburn.us/Walking+skeleton</a></p></blockquote><p><code>Walking Skeleton</code>이란 실제로 동작하는 프로젝트의 골격을 말하는데, 여기서 <code>동작하다</code>라는 추상적인 표현은 기능을 말하는 것이 아닌 프로젝트가 빌드되고 배포되기까지의 과정을 위한 기반을 말한다. 문자 그대로 아래와 같이 프로젝트를 지탱하는 <code>뼈대(Skeleton)</code>되시겠다.</p><ul><li>테스트 전략</li><li>프로젝트를 지탱하는 파이썬 실행 환경</li><li>빌드 또는 패키징</li><li>배포</li></ul><p>다음 글에서는 <code>TDD</code>와 <code>Walking Skelton</code>를 이용해 점차 프로젝트를 구성해 나아가는 과정을 살펴보도록 하겠다.</p><blockquote><p><a href="https://www.holaxprogramming.com/2017/06/17/python-with-test/">https://www.holaxprogramming.com/2017/06/17/python-with-test/</a></p></blockquote><p><br></p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li><a href="https://python.org/" target="_blank" rel="external">https://python.org/</a></li><li><a href="https://docs.python.org/3.6/library/unittest.html" target="_blank" rel="external">https://docs.python.org/3.6/library/unittest.html</a></li><li><a href="http://doc.pytest.org/en/latest/index.html" target="_blank" rel="external">http://doc.pytest.org/en/latest/index.html</a></li><li><a href="http://wiki.c2.com/?WalkingSkeleton" target="_blank" rel="external">http://wiki.c2.com/?WalkingSkeleton</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;필자는 보통 새로운 언어를 학습하기 위해서 먼저 프로그래밍을 위한 개발 환경을 설치하고 그 이후에는 &lt;code&gt;TDD(Test Driven Development)&lt;/code&gt;를 통해 다양한 문제에 노출되는 것으로 시작한다. TDD는 소프트웨어를 개발하는 방법론 중 하나이며, 우리가 작성하게 되는 모든 코드는 올바르게 작동하는지에 대한 검증이 필요한데 보통 이러한 과정을 &lt;code&gt;테스트&lt;/code&gt;라고 불린다. &lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.holaxprogramming.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA를 이용한 암호화와 서명</title>
    <link href="https://www.holaxprogramming.com/2017/06/12/encryption-with-rsa/"/>
    <id>https://www.holaxprogramming.com/2017/06/12/encryption-with-rsa/</id>
    <published>2017-06-12T02:54:07.000Z</published>
    <updated>2022-06-07T00:26:22.998Z</updated>
    
    <content type="html"><![CDATA[<p>암호화는 과거부터 현재까지 소중한 정보를 지키는데 중요한 수단으로 활용되어 왔다. 세계 2차 대전에서 독일군의 최초의 자동화된 암호화 기계인 <code>에니그마</code>를 해독해 연합군을 승리로 이끈 튜링의 일화는 그 예를 가장 잘 보여주고 있다.</p><a id="more"></a><p>그뿐만 아니라 튜링은 암호학뿐만 아니라 인류에게 또 다른 선물을 안긴 천재 수학자이기도 하다. 튜링은 현대 컴퓨터의 이론적 모델인 <code>튜링머신</code>을 고안했다.</p><p><img src="http://www.stutteringhelp.org/sites/default/files/pictures/alan-turing.jpg" width="500"></p><p>이처럼 암호학은 현대 컴퓨터의 기초가 되었으며, 지금의 인터넷을 기반으로 한 서비스에서도 암호화 기법은 중요하고 다양하게 활용되고 있는데 이 글에서는 공개키를 통한 <a href="https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8" target="_blank" rel="external">RSA 알고리즘</a>의 활용 방법에 대해 설명하고자 한다.</p><p>공개키를 이용한 RSA는 암호화뿐만 아니라 전자 서명이 가능한 알고리즘이다. RSA를 이용한 서명과 암호화 기법을 설명하기 이전에 <code>대칭키</code> 암호화 방식에 대한 지식이 없다면 앞으로의 내용이 추상적으로 들릴 수 있기 때문에 대칭키 암호화 방식을 먼저 살펴보도록 하겠다.</p><h2 id="대칭키를-이용한-암호화"><a href="#대칭키를-이용한-암호화" class="headerlink" title="대칭키를 이용한 암호화"></a>대칭키를 이용한 암호화</h2><p>암호화를 위해서는 기본적으로 암호화의 대상이 되는 <code>평서문(Plain Text)</code>과 암호화를 위한 일종의 비밀번호인 <code>암호키(Cryptography Key)</code> 그리고 마지막으로 암호화 <code>알고리즘(Algorithm)</code>이 필요한데, 대칭키 암호화 방식은 문자 그대로 암호화와 복호화를 동일한 암호키를 이용하는 방식을 말한다.</p><p><img src="https://uploads.skyhighnetworks.com/2015/07/15150142/In_Page_Encryption_Decryption_Diagram_700.png" width="500"></p><blockquote><p>사진 - <a href="https://www.skyhighnetworks.com/cloud-security-university/tokenization-vs-encryption/" target="_blank" rel="external">https://www.skyhighnetworks.com/cloud-security-university/tokenization-vs-encryption/</a></p></blockquote><p> 위의 그림을 통해 살펴보면 동일한 암호키를 통해 <code>암호화(Encryption)</code>, <code>복호화(Decryption)</code>하는 것을 볼 수 있는데, 대칭키를 사용하는 암호화 알고리즘은 <code>AES</code>와 <code>DES</code>가 대표적이다. 본문은 RSA를 이용한 서명과 암호화의 활용 방법을 전달하는 것이 주된 목적이기 때문에 대칭키를 이용한 암호화 알고리즘에 대한 자세한 설명은 생략한다.</p><h4 id="openssl을-통해-구체적으로-암호화-복호화되는-과정을-살펴보도록-하자"><a href="#openssl을-통해-구체적으로-암호화-복호화되는-과정을-살펴보도록-하자" class="headerlink" title="openssl을 통해 구체적으로 암호화, 복호화되는 과정을 살펴보도록 하자"></a>openssl을 통해 구체적으로 암호화, 복호화되는 과정을 살펴보도록 하자</h4><p><code>plain.txt</code>라는 파일의 내용을 <code>DES3</code> 알고리즘을 통해 암호화하는 과정이다. 예시로 암호화를 위한 패스워드는 <code>123456</code> 이라고 가정한다. 암호화된 결과는 <code>cipher.bin</code>를 통해 저장한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;안녕 프로그래밍&apos; &gt; plain.txt</span><br><span class="line">$ openssl enc -e -des3 -in plain.txt -out cipher.bin</span><br><span class="line">enter des-ede3-cbc encryption password: 123456</span><br><span class="line">Verifying - enter des-ede3-cbc encryption password: _</span><br></pre></td></tr></table></figure><p>암호화된 <code>cipher.bin</code>은 기존의 내용을 식별할 수 없는 상태이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat cipher.bin</span><br><span class="line">Salted__�Bd����������m��LoS�t��ɽҝ��J</span><br></pre></td></tr></table></figure></p><p>마지막으로 <code>DES3</code> 알고리즘을 통해 복호화하는 과정이다. 암호화에 사용한 패스워드를 통해 아래와 같이 동일한 평서문을 얻을 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl enc -d -des3 -in cipher.bin -out hola.txt</span><br><span class="line">enter des-ede3-cbc decryption password: 123456</span><br><span class="line">$ cat hola.txt</span><br><span class="line">안녕 프로그래밍</span><br></pre></td></tr></table></figure></p><blockquote><p>OpenSSL(<a href="https://www.openssl.org/)은" target="_blank" rel="external">https://www.openssl.org/)은</a> TLS/SSL 프로토콜을 구현하는 오픈소스 프로젝트이다. OpenSSL에서는 TLS/SSL 프로토콜을 위한 다양한 암호화와 서명 기법을 제공한다.</p></blockquote><h2 id="RSA를-이용한-암호화"><a href="#RSA를-이용한-암호화" class="headerlink" title="RSA를 이용한 암호화"></a>RSA를 이용한 암호화</h2><p><code>RSA</code>는 공개키를 이용하는 대표적인 암호화 방식이며 전자서명이 가능한 최초의 알고리즘으로 알려져 있다. <code>AES</code>, <code>DES</code>와 같은 대칭키 암호화 방식에서 발생하는 문제점을 해결하였다.</p><p>과거의 암호 방식은 암호화를 위한 키뿐만 아니라 알고리즘 역시 노출되지 않기 위해 노력하였으나 현대의 암호에서는 알고리즘을 공개하도록 하고 있다. 그 이유는 키 이외에 암호 시스템의 모든 것이 공개되어도 안전해야 한다고 Kerckhoff은 주장을 했는데 이것을 <code>Kerckhoff의 법칙</code>이라고 한다.</p><p>이 때문에 암호화를 위한 비밀번호인 키(Key)는 사용자가 인터넷 서비스를 위해 로그인할 때 필요한 비밀번호와 같이 가장 중요한 요소라고 할 수 있겠다. 하지만 대칭키 암호화 방식은 수신자와 발신자 간에 키를 공유하는 과정이 필요하기 때문에 보안적으로 해결해야 하는 문제가 남아있었다.</p><h4 id="공개키와-비밀키를-이용한-암호화-방식"><a href="#공개키와-비밀키를-이용한-암호화-방식" class="headerlink" title="공개키와 비밀키를 이용한 암호화 방식"></a>공개키와 비밀키를 이용한 암호화 방식</h4><p>RSA는 수학적인 기법을 통해 한 쌍의 공개키와 비밀키를 생성하는데, 각각의 키는 이론적으로 아래와 같은 용도로 사용된다.</p><p><img src="https://www.amatisnetworks.com/wp-content/uploads/2016/06/Public-Key-Encryption-shutterstock_224144242.jpg" width="500"></p><table><thead><tr><th>구분</th><th>목적</th></tr></thead><tbody><tr><td>Public Key</td><td>누구에게나 공개될 수 있으며 메세지를 보내는 발신자는 공개키를 통해 정보를 암호화한다</td></tr><tr><td>Private Key</td><td>수신자는 비밀키를 암호화된 메세지를 복호화 하는데 사용한다, 외부에 노출되지 않도록 안전하게 보관해야 한다.</td></tr></tbody></table><blockquote><p>RSA 알고리즘은 반대로 <code>Private Key</code>로 암호화하고 <code>Public Key</code>를 통해 복호화할 수도 있다.</p></blockquote><p>이와 같이 RSA를 이용한 공개키 암호화 방식은 비밀키(Private Key)를 외부에 노출할 위험이 없어 기존의 대칭키 암호화 방식의 문제를 해결하고 있다.</p><p>현대의 암호화에서는 대칭키와 공개키 암호화 방식을 적절히 혼합하여 사용하고 있는데 구체적으로 어떻게 활용되고 있는지 살펴보자.</p><h2 id="어디에서-활용되고-있을까"><a href="#어디에서-활용되고-있을까" class="headerlink" title="어디에서 활용되고 있을까?"></a>어디에서 활용되고 있을까?</h2><p>우리에게 익숙한 인터넷 서비스에서는 대칭키와 공개키를 이용한 암호화를 다양하게 활용하고 있는데 대표적으로 <code>TLS(Transport Layer Security)</code>라고 불리는 암호 규약이 대표적이며 쉽게 예를 들면 웹 브라우징 시에 사용되는 보안 계층을 말한다.</p><p>TLS는 기존의 <code>SSL(Secure Sockets Layer)</code>가 표준화되면서 바뀐 이름이며 우리가 인터넷에서 익숙하게 접하는 <code>HTTPS</code> 프로토콜에서 이를 활용하고 있다.</p><h4 id="웹-페이지에서-우리의-아이디와-비밀번호는-안전하게-전달될까"><a href="#웹-페이지에서-우리의-아이디와-비밀번호는-안전하게-전달될까" class="headerlink" title="웹 페이지에서 우리의 아이디와 비밀번호는 안전하게 전달될까?"></a>웹 페이지에서 우리의 아이디와 비밀번호는 안전하게 전달될까?</h4><p>우리는 검색 포털 또는 소셜 미디어 서비스를 이용할 때 먼저 아이디와 패스워드를 통해 로그인을 하는 과정을 거친다. 이와 같이 사용자의 중요한 정보가 웹 브라우저를 통해 서버에 전달될 때는 HTTPS 프로토콜을 통해 안전하게 전달된다.</p><p>HTTPS 프로토콜은 내부적으로 앞서 말한 표준화된 <code>TLS(Transport Layer Security)</code> 암호 규약을 사용하는데, TLS를 통해 메세지를 안전하게 주고받는 원리는 다음과 같다.</p><p>먼저 지원 가능한 알고리즘 정보를 교환한다. 이 단계에서 키 교환과 인증에 사용될 암호화 방법이 결정된다.</p><p><img src="http://image.toast.com/aaaaahq/RSA_1.png"></p><p>키 교환과 인증 알고리즘은 RSA와 같은 공개키 기법을 사용하거나 미리 공유된 키(TLS-PSK)를 사용할 수도 있다.</p><p><img src="http://image.toast.com/aaaaahq/RSA_2.png"></p><p>교환된 공개키를 통해 앞으로 메세지 암호화에 사용될 대칭키를 암호화하여 교환한다</p><p><img src="http://image.toast.com/aaaaahq/RSA_3.png"></p><p>마지막으로 대칭키를 통해 메세지를 암호화하여 안전하게 전송한다.</p><p><img src="http://image.toast.com/aaaaahq/RSA_4.png"></p><h4 id="서명과-검증"><a href="#서명과-검증" class="headerlink" title="서명과 검증"></a>서명과 검증</h4><p>TLS에서는 메세지 원본을 암호화하는 것뿐만 아니라 메세지가 인증된 사용자로부터 전달된 것인지 확인하기 위해서 서명과 검증 절차를 거치는데 내용은 아래와 같다.</p><p>즉, 원래의 문서 내용을 <code>Message</code>라고 하면 Hash 함수인 SHA256 같은 함수 하나를 정해 <code>Hash된 Message</code>값을 구하고 이 Hash 값을 Client의 비밀키로 암호화한다. 여기까지의 과정을 <code>서명</code>이라고 하며 서명된 결과를 보통 <code>Signature</code>라고 불린다.</p><p>최종적으로 원본의 <code>Message</code>끝에 <code>Signature</code>를 첨부하여 전송하며 메세지를 받는 Server는 전달된 <code>Message</code>를 동일한 Hash 함수를 통해 <code>Hash된 Message</code>를 얻는다. 그리고 사전에 교환한 Client의 공개키를 통해 <code>Signature</code> 역시 복호화하는 과정을 가진다.</p><p>최종적으로 얻게 된 두 쌍의 <code>Hash된 Message</code>를 비교하여 동일한 값이면 서명이 올바른 것이고 값이 서로 다르거나 변환하는 과정에서 오류가 있다면 서명이 틀리다고 보는 것이다.</p><p>아래의 그림과 같이 정리할 수 있다.</p><p><img src="http://image.toast.com/aaaaahq/sign-and-verification.png"></p><h4 id="Google-Play는-인앱-결제-정보를-어떻게-검증할까"><a href="#Google-Play는-인앱-결제-정보를-어떻게-검증할까" class="headerlink" title="Google Play는 인앱 결제 정보를 어떻게 검증할까?"></a>Google Play는 인앱 결제 정보를 어떻게 검증할까?</h4><p>이 서명과 검증은 특히 돈이 오고가는 결제 내역에 대한 검증에 많이 사용되며 Google Play에서 제공하는 인앱 결제에서는 상품을 지급하기 전에 아래와 같이 결제 내역을 검증하도록 하고 있다.</p><p>Google Play에서 제공하는 IPC 방식으로 결제가 완료되면 결제를 요청한 애플리케이션은 아래와 같은 결과를 전달받게 된다.</p><p><code>결제 내역 정보가 담긴 JSON</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;orderId&quot;: &quot;12999763169054705758.1374081541263051&quot;,</span><br><span class="line">   &quot;packageName&quot;: &quot;com.holaxapps.chomdoi&quot;,</span><br><span class="line">   &quot;productId&quot;: &quot;gas&quot;,</span><br><span class="line">   &quot;purchaseTime&quot;: 1396577500292,</span><br><span class="line">   &quot;purchaseState&quot;: 0,</span><br><span class="line">   &quot;purchaseToken&quot;: &quot;aamhleobcgnmmlgnpiepncjh.AO-J1OwabKCNS0fXo9u8ycee9wOhSGtIrI1EXLp_rGIuAjhv6CE6cPUq1sTPkgNhh_ZlXKdi2sP4DcBTyRdCViHPcypYFultoC9qUseC5C9RPwl-4CcFJKU&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>결제 내역에 대한 서명 값(Signature)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gw4rkP6nWnNZVS66r9afyqrJSVp5km9R+O3Ie2YW1rtmabOVyO0LyfZRWiYGbzc5/HmlkZ4zWNiIrNPptWogBS1ovuGLUkkh+9tnURzDWEsIYgzhd91/0RlRgj5NE8PFHZ32RCwyPy3LccsGTCM1dcKErN/7XRdGmV+8HsgF5lShKmrjOl11ZLPotlgBLbYLMphWDogLrjc3Xo5/ib2rXSLvnjjGSf+WPe0zRtMYnQ4YR7cJFnknD38ejYWserFllTfvRkjKA2qOmxYYPfuIJMKKlFGJxu2GsDJXOphJ9sKz30D2fIlanczXGSgPf1JRtWeMsdhapRh4hEwJRTntag==</span><br></pre></td></tr></table></figure><p>결제가 완료되면 전달받는 Message와 Signature를 통해서 앞서 말한 서명과 검증 과정을 통해서 생성한 한 쌍의 Hash 값을 비교해 안전하게 결제 내역에 대한 검증을 할 수 있게 되는 것이다. 마지막으로 Java 프로그래밍을 통해 직접 구현해 보도록 하겠다.</p><h2 id="Java-프로그래밍을-통해-RSA-구현해보기"><a href="#Java-프로그래밍을-통해-RSA-구현해보기" class="headerlink" title="Java 프로그래밍을 통해 RSA 구현해보기"></a>Java 프로그래밍을 통해 RSA 구현해보기</h2><p>지금까지 우리는 익숙한 HTTPS의 작동 방식과 Google Play의 인앱 결제 시에 서명과 검증 과정을 통해 RSA 알고리즘이 이론적으로 어떻게 작동되는지 살펴보았다. 지금 부터는 우리의 서비스에서 직접 활용해 볼 차례다. 본문에서는 Java 프로그래밍을 통해 구현해 보도록 하겠다.</p><h4 id="한-쌍의-공캐키와-비밀키-생성"><a href="#한-쌍의-공캐키와-비밀키-생성" class="headerlink" title="한 쌍의 공캐키와 비밀키 생성"></a>한 쌍의 공캐키와 비밀키 생성</h4><p>먼저 RSA는 한 쌍의 공개 키와 비밀 키를 필요로 하는데 필자는 테스트 코드를 먼저 작성해 아래와 같이 한 쌍의 키를 얻는 것을 기대해 보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        KeyPair keyPair = Security.generateKeyPair();</span><br><span class="line">        assertThat(keyPair.getPrivate()).isNotNull();</span><br><span class="line">        assertThat(keyPair.getPublic()).isNotNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트 코드만 있을 뿐 아직은 <code>Security</code> 클래스는 존재하지 않아 아래와 같이 클래스를 만들고 <code>java.security</code> 패키지의 <code>KeyPairGenerator</code> 클래스를 이용해 한 쌍의 키를 획득하는 함수를 작성하였다. RSA 알고리즘을 사용하는 것을 볼 수 있으며 RSA 알고리즘에 필요한 키는 2048 bit의 크기가 가장 안전하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_KEY_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_FACTORY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">generateKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        KeyPairGenerator generator = KeyPairGenerator.getInstance(KEY_FACTORY_ALGORITHM);</span><br><span class="line">        generator.initialize(DEFAULT_KEY_SIZE, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">        KeyPair pair = generator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> pair;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수 작성을 완료하고 테스트가 정상적으로 실행된다면 생성한 공개키, 비밀키를 이용해 암호화와 복호화를 해보자.</p><h4 id="암호화와-복호화"><a href="#암호화와-복호화" class="headerlink" title="암호화와 복호화"></a>암호화와 복호화</h4><p>우리는 이미 한 쌍의 키를 생성하는 과정을 거쳤으며 이를 이용해 테스트 코드에서는 아래와 같이 암호화, 복호화되는 것을 기대해 보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptAndDecrypt</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    String plainText = <span class="string">"&#123;&#125;"</span>;</span><br><span class="line">    KeyPair keyPair = Security.generateKeyPair();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] encodedPublicKey = keyPair.getPublic().getEncoded();</span><br><span class="line">    <span class="keyword">byte</span>[] encodedPrivateKey = keyPair.getPrivate().getEncoded();</span><br><span class="line"></span><br><span class="line">    String cipherText = Security.encrypt(plainText, encodedPublicKey);</span><br><span class="line">    assertThat(plainText).isEqualTo(Security.decrypt(cipherText, encodedPrivateKey));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래의 코드를 통해 암호화는 RSA 알고리즘을 통해 생성된 공개키를 이용하며, 암호화된 메세지는 비밀키를 이용해 복호화하는 것을 알 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_KEY_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_FACTORY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String plainText, <span class="keyword">byte</span>[] encodedPublicKey)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        PublicKey publicKey = Security.generatePublicKey(encodedPublicKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(KEY_FACTORY_ALGORITHM);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = cipher.doFinal(plainText.getBytes(CHARSET));</span><br><span class="line">            <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchPaddingException | InvalidKeyException | UnsupportedEncodingException | IllegalBlockSizeException | BadPaddingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String cipherText, <span class="keyword">byte</span>[] encodedPrivateKey)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        PrivateKey privateKey = Security.generatePrivateKey(encodedPrivateKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(cipherText);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(KEY_FACTORY_ALGORITHM);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(cipher.doFinal(bytes), CHARSET);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchPaddingException | InvalidKeyException | UnsupportedEncodingException | IllegalBlockSizeException | BadPaddingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="서명과-검증하기"><a href="#서명과-검증하기" class="headerlink" title="서명과 검증하기"></a>서명과 검증하기</h4><p>서명은 Signature를 생성하는 과정이다. 아래와 같이 Hash된 원본 메세지를 비밀키를 통해 암호화하는 과정을 기대해 보았다. Signature가 정상적으로 생성되는 것으로 가정하고 원본 메세지는 동일한 함수로 Hash하고 암호화된 메세지는 공개키를 통해 복호화해 두 Hash 값을 비교하는 과정이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signAndVerify</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    String plainText = <span class="string">"&#123;&#125;"</span>;</span><br><span class="line">    KeyPair keyPair = Security.generateKeyPair();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] encodedPrivateKey = keyPair.getPrivate().getEncoded();</span><br><span class="line">    <span class="keyword">byte</span>[] encodedPublicKey = keyPair.getPublic().getEncoded();</span><br><span class="line"></span><br><span class="line">    String signature = Security.sign(plainText, encodedPrivateKey);</span><br><span class="line">    System.out.println(<span class="string">"signature = "</span> + signature);</span><br><span class="line">    assertThat(signature).isNotNull();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = Security.verify(plainText, signature, encodedPublicKey);</span><br><span class="line">    assertThat(result).isTrue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.security</code> 패키지의 <code>Signature</code> 클래스를 이용해 앞서 말한 과정을 구현할 수 있으며 생성한 Signature는 REST API에서 자주 활용될 수 있으므로 Base64로 인코딩하는 것을 추천한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(String plainText, <span class="keyword">byte</span>[] encodedPrivateKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Signature privateSignature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        privateSignature.initSign(Security.generatePrivateKey(encodedPrivateKey));</span><br><span class="line">        privateSignature.update(plainText.getBytes(CHARSET));</span><br><span class="line">        <span class="keyword">byte</span>[] signature = privateSignature.sign();</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(signature);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | InvalidKeyException | UnsupportedEncodingException | SignatureException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String plainText, String signature, <span class="keyword">byte</span>[] encodedPublicKey)</span> </span>&#123;</span><br><span class="line">    PublicKey publicKey = Security.generatePublicKey(encodedPublicKey);</span><br><span class="line">    <span class="keyword">return</span> Security.verifySignarue(plainText, signature, publicKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title">generatePrivateKey</span><span class="params">(<span class="keyword">byte</span>[] encodedPrivateKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);</span><br><span class="line">        <span class="keyword">return</span> keyFactory.generatePrivate(<span class="keyword">new</span> PKCS8EncodedKeySpec(encodedPrivateKey));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidKeySpecException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifySignarue</span><span class="params">(String plainText, String signature, PublicKey publicKey)</span> </span>&#123;</span><br><span class="line">    Signature sig;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sig = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">        sig.initVerify(publicKey);</span><br><span class="line">        sig.update(plainText.getBytes());</span><br><span class="line">        <span class="keyword">if</span> (!sig.verify(Base64.getDecoder().decode(signature)))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidSignatureException(<span class="string">"It was awesome! Signature hasn't be invalid"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | InvalidKeyException | SignatureException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>JDK 8</code>에서는 위와 같이 Base64 Encoding/Decoding을 위해서 표준 API를 제공하고 있으니 더 이상 <code>common-codec</code>과 같은 라이브러리는 사용할 필요가 없다.</p></blockquote><p><br></p><p>지금까지 대칭키와 공개키를 이용한 기본적인 암호화 기법에 대해 설명하고 Java 프로그래밍을 통해 직접 구현해 보기도 하였습니다. RSA를 이용한 암호화와 서명을 추상적으로 이해하는 것이 아니라 그 원리를 제대로 이해하고 서비스에 활용한다면 더욱 안전한 애플리케이션을 개발할 수 있을 것으로 기대합니다. 본문에 사용된 전체 소스코드는 아래의 Gist 링크에서 확인할 수 있습니다.</p><blockquote><p><a href="https://gist.github.com/stunstunstun/5ea5670b5bfd6459cbebdfbfd4674063" target="_blank" rel="external">https://gist.github.com/stunstunstun/5ea5670b5bfd6459cbebdfbfd4674063</a><br><a href="https://gist.github.com/stunstunstun/8dbc82bd86f38c9232139e0ba9a7d8ad" target="_blank" rel="external">https://gist.github.com/stunstunstun/8dbc82bd86f38c9232139e0ba9a7d8ad</a></p></blockquote><p><br></p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" target="_blank" rel="external">https://en.wikipedia.org/wiki/Symmetric-key_algorithm</a><br><a href="https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8" target="_blank" rel="external">https://ko.wikipedia.org/wiki/RSA_%EC%95%94%ED%98%B8</a><br><a href="https://www.openssl.org/" target="_blank" rel="external">https://www.openssl.org/</a><br><a href="https://ko.wikipedia.org/wiki/HTTPS" target="_blank" rel="external">https://ko.wikipedia.org/wiki/HTTPS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;암호화는 과거부터 현재까지 소중한 정보를 지키는데 중요한 수단으로 활용되어 왔다. 세계 2차 대전에서 독일군의 최초의 자동화된 암호화 기계인 &lt;code&gt;에니그마&lt;/code&gt;를 해독해 연합군을 승리로 이끈 튜링의 일화는 그 예를 가장 잘 보여주고 있다.&lt;/p&gt;
    
    </summary>
    
      <category term="fundamental" scheme="https://www.holaxprogramming.com/categories/fundamental/"/>
    
    
  </entry>
  
  <entry>
    <title>Github Pages에 Custom Domain 적용하기</title>
    <link href="https://www.holaxprogramming.com/2017/05/15/github-page-and-custom-domain/"/>
    <id>https://www.holaxprogramming.com/2017/05/15/github-page-and-custom-domain/</id>
    <published>2017-05-15T06:14:40.000Z</published>
    <updated>2022-06-07T00:26:22.999Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.dribbble.com/users/14268/screenshots/949452/photo-x2.png" width="500"></p><p>이 포스팅은 <a href="http://holaxprogramming.com/2017/04/16/github-page-and-hexo/" target="_blank" rel="external"><code>Github Pages와 Hexo를 통해 30분만에 기술 블로그 만들기</code></a> 후에 Github Pages에 새로운 Domain을 적용하는 과정을 담고 있습니다. Github Pages를 통해 블로그를 만들고 싶다면 먼저 위의 글을 참고해주세요. 자 그럼 시작해 볼까요, 기본적으로 Github Pages를 통해 정적 페이지(Static Page)를 호스팅(Hosting)하는 경우에는 아래와 같은 도메인(Domain)을 제공 받게 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USERNAME.github.io</span><br></pre></td></tr></table></figure><p>그렇다면 직접 DNS을 구입해 Github Pages에 적용 할 수는 없을까요? Github에서는 Custom DNS를 통해서 새로운 Domain을 Github Pages에 적용 할 수 있도록 하고 있습니다. 지금 보시는 블로그 역시 같은 방법으로 github.io 에서 Custom Domain으로 변경하여 운영하고 있습니다.</p><h2 id="Github-Pages-설정"><a href="#Github-Pages-설정" class="headerlink" title="Github Pages 설정"></a>Github Pages 설정</h2><p>Github Pages의 Repository 메뉴의 <code>Settings &gt; Options &gt; Github Pages</code> 로 이동:</p><p><img src="http://image.toast.com/aaaaahq/git-page-ssl.png"></p><p>Github Pages 메뉴의 Custom domain을 자신이 소유하고 있는 Domain 주소로 변경하면, Repository의 Root 디렉토리에 아래와 같이 <a href="https://en.wikipedia.org/wiki/CNAME_record" target="_blank" rel="external"><code>CNAME</code></a> 파일이 생성 됩니다. 이후에는 USERNAME.github.io 접근되는 요청은 변경된 Domain으로 Redirect 됩니다.</p><p><strong>CNAME</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.holaxprogramming.com</span><br></pre></td></tr></table></figure></p><blockquote><p>참고<br><a href="https://github.com/holaxapps/holaxapps.github.io/blob/master/CNAME" target="_blank" rel="external">https://github.com/holaxapps/holaxapps.github.io/blob/master/CNAME</a></p></blockquote><h2 id="DNS-설정"><a href="#DNS-설정" class="headerlink" title="DNS 설정"></a>DNS 설정</h2><p>그 다음으로는 Domain을 구입하신 서비스에서 DNS에 대한 Host Records 설정을 해야 합니다. 안녕 프로그래밍의 DNS은 Namecheap이라는 서비스를 통해 운영되고 있습니다</p><h4 id="Host-Record-설정"><a href="#Host-Record-설정" class="headerlink" title="Host Record 설정"></a>Host Record 설정</h4><p>Github에서는 Github Pages에서 Custom Domain을 사용할 경우에 DNS 설정을 아래와 같이 반영할 것을 요구하고 있습니다. Advanced DNS Guide: If your custom domain name is <code>example.com</code> you need to modify the Host records information as shown below.</p><table><thead><tr><th>Type</th><th>Host</th><th>Value</th></tr></thead><tbody><tr><td>A Record</td><td>@</td><td>192.30.252.153</td></tr><tr><td>A Record</td><td>@</td><td>192.30.252.154</td></tr><tr><td>CName Record</td><td>www</td><td>USERNAME.github.io</td></tr></tbody></table><blockquote><p>A Record는 Domain을 물리적인 IP 주소로 연결 할 수 있도록 합니다. 192.30.252.153, 192.30.252.154는 Github Page의 Static Page를 관리하는 IP입니다.<br>CName은 물리적인 IP 주소가 아닌 다른 Domain을 연결 합니다. 대상 Domain의 IP의 변경 내역을 알 필요가 없습니다.</p></blockquote><div class="tip"><br>혹시 Github Pages와 Hexo를 통해 블로그를 만들었는데 위의 모든 과정을 진행 하였음에도 불구하고 CNAME 파일이 원하는대로 생성되지 않았나요?<br></div><h4 id="그렇다면-Hexo에서-CNAME-플러그인을-설정할-필요가-있어요"><a href="#그렇다면-Hexo에서-CNAME-플러그인을-설정할-필요가-있어요" class="headerlink" title="그렇다면 Hexo에서 CNAME 플러그인을 설정할 필요가 있어요"></a>그렇다면 Hexo에서 CNAME 플러그인을 설정할 필요가 있어요</h4><p>CNAME 생성을 위한 패키지를 아래와 같이 설치하세요</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure><p>그리고 <code>_config.yml</code> 파일에서 아래와 같이 플러그인 설정을 해주시면 됩니다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-cname</span></span><br></pre></td></tr></table></figure><p><code>_config.yml</code> 에서 url 이름도 적용한 Domain과 일치하는지 확인해 보세요.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="attr">https://www.holaxprogramming.com</span></span><br></pre></td></tr></table></figure><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/" target="_blank" rel="external">https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/</a></li><li><a href="https://developer.ubuntu.com/en/blog/2016/02/17/how-host-your-static-site-https-github-pages-and-cloudflare/" target="_blank" rel="external">https://developer.ubuntu.com/en/blog/2016/02/17/how-host-your-static-site-https-github-pages-and-cloudflare/</a></li><li><a href="https://support.dnsimple.com/articles/differences-a-cname-records/" target="_blank" rel="external">https://support.dnsimple.com/articles/differences-a-cname-records/</a></li><li><a href="https://www.namecheap.com/support/knowledgebase/article.aspx/579/2237/which-record-type-option-should-i-choose-for-the-information-im-about-to-enter" target="_blank" rel="external">https://www.namecheap.com/support/knowledgebase/article.aspx/579/2237/which-record-type-option-should-i-choose-for-the-information-im-about-to-enter</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://cdn.dribbble.com/users/14268/screenshots/949452/photo-x2.png&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 포스팅은 &lt;a href=&quot;http://holaxprogrammi
      
    
    </summary>
    
      <category term="git" scheme="https://www.holaxprogramming.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Github Page와 Hexo를 통해 30분만에 기술 블로그 만들기</title>
    <link href="https://www.holaxprogramming.com/2017/04/16/github-page-and-hexo/"/>
    <id>https://www.holaxprogramming.com/2017/04/16/github-page-and-hexo/</id>
    <published>2017-04-16T06:14:40.000Z</published>
    <updated>2022-06-07T00:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>이 포스팅에서는 GitHub Page를 통해 손쉽게 개발 블로그를 Hosting 해보고 Command Line 명령을 통해 쉽게 블로그를 만들 수 있는 Hexo 프레임워크를 소개하고자 합니다.</p><a id="more"></a><p><img src="http://www.ybrikman.com/assets/img/blog/github-pages/github-pages.png" width="500"></p><ul><li>GitHub Page - <a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></li><li>Hexo - <a href="https://hexo.io/" target="_blank" rel="external">https://hexo.io/</a></li></ul><p>지금 보고 계시는 블로그 역시 동일한 방법으로 30분 이내에 블로그를 개설 할 수 있었습니다. Git Page와 Hexo를 통해 개인의 기술 관련 문서를 손쉽게 관리하고 알릴 수 있기를 바랍니다.</p><h2 id="Git-Page로-정적-페이지-Hosting하기"><a href="#Git-Page로-정적-페이지-Hosting하기" class="headerlink" title="Git Page로 정적 페이지 Hosting하기"></a>Git Page로 정적 페이지 Hosting하기</h2><p>Git Page를 통해 손쉽게 USERNAME.github.io 도메인을 통해 정적 페이지를 호스팅(Hosting) 할 수가 있습니다.</p><h4 id="Github-Repository-생성하기"><a href="#Github-Repository-생성하기" class="headerlink" title="Github Repository 생성하기"></a>Github Repository 생성하기</h4><p>먼저 Github에 가입한 후에 아래와 같은 순서로 Repository를 생성합니다.</p><ul><li>New Repository, Repository 이름은 USERNAME.github.io</li><li>USERNAME 은 Github의 가입시에 사용자의 username을 입력한다</li><li>Public / Private 중 Public 선택</li><li>Create Repository 버튼을 통해 Repository 생성</li></ul><h4 id="Clone-the-repository"><a href="#Clone-the-repository" class="headerlink" title="Clone the repository"></a>Clone the repository</h4><p>Github Repository 생성 이후에는 아래의 Command Line을 순차적으로 실행한다. 먼저 생성한 Repository를 로컬에 복사한다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/username/username.github.io</span><br></pre></td></tr></table></figure><blockquote><p>Terminal 환경이 익숙하지 않다면 아래의 링크에서 Windows, Mac 운영체제별 클라이언트 프로그램을 통한 Step을 소개하고 있다.<br><a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></p></blockquote><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>root 디렉토리에 index.html 파일을 생성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> username.github.io</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; index.html</span><br></pre></td></tr></table></figure><h4 id="Push-it"><a href="#Push-it" class="headerlink" title="Push it"></a>Push it</h4><p>Remote 저장소에 변경내역을 Push 한다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all</span><br><span class="line">$ git commit -m <span class="string">"Initial commit"</span></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><h4 id="It’s-done"><a href="#It’s-done" class="headerlink" title="It’s done!"></a>It’s done!</h4><p>아주 손쉽게 여러분의 웹페이지를 하나 만들었다. 이제는 브라우저에서 정상적으로 <a href="https://USERNAME.github.io" target="_blank" rel="external">https://USERNAME.github.io</a> 에 접속되는지 확인 한다.</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo는 Jekyll와 함께 대표적으로 정적 페이지를 쉽게 만들 수 있도록 도와주는 서비스이다. 두 서비스 역시 블로그 지향적인 서비스이며 Hexo의 경우에는 npm을 통해 쉽게 설치가 가능하고 한 줄의 Command Line을 통해 Github에 바로 배포 할 수 있으며, Jekyll과 마찬가지로 다양한 플러그인과 테마를 지원하고 있다</p><p><img src="http://www.devzhou.com/2016/06/04/my-first-blog/hexo-logo.png" width="600"></p><blockquote><p>A fast, simple &amp; powerful blog framework</p></blockquote><h4 id="설치-전-준비"><a href="#설치-전-준비" class="headerlink" title="설치 전 준비"></a>설치 전 준비</h4><p>Hexo를 이용하기 위해서는 먼저 아래의 구성 요소들이 사전에 설치가 되어 있어야 한다. 이미 설치가 되어 있다면 생략해도 좋다.</p><ul><li><strong><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></strong></li><li><strong><a href="https://git-scm.com/" target="_blank" rel="external">Git</a></strong></li></ul><h4 id="Hexo-CLI-설치-및-블로그-생성"><a href="#Hexo-CLI-설치-및-블로그-생성" class="headerlink" title="Hexo CLI 설치 및 블로그 생성"></a>Hexo CLI 설치 및 블로그 생성</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h4 id="설정파일-업데이트"><a href="#설정파일-업데이트" class="headerlink" title="설정파일 업데이트"></a>설정파일 업데이트</h4><p>Command Line을 통해 Hexo를 설치하고 블로그 생성이 완료가 되면 root 디렉토리에 <code>_config.yml</code> 이라는 설정파일이 생성이 되는데 이 곳에 블로그에 대한 대부분의 설정을 할 수 있다. 이 중 중요한 설정 요소들을 소개하도록 하겠다. 나머지 설정 값에 대한 자세한 정보는 Hexo의 Document를 통해 확인이 가능하다.</p><ul><li>Documentation - <a href="https://hexo.io/docs/" target="_blank" rel="external">https://hexo.io/docs/</a></li></ul><h4 id="Site-정보"><a href="#Site-정보" class="headerlink" title="Site 정보"></a>Site 정보</h4><p>블로그의 이름과 간략한 소개등을 수정 할 수 있다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">안녕</span> <span class="string">프로그래밍</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">모두가</span> <span class="string">프로그래밍에서</span> <span class="string">자유로워지는</span> <span class="string">그</span> <span class="string">날까지</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Minhyeok</span> <span class="string">Jung</span></span><br></pre></td></tr></table></figure><h4 id="URL-정보"><a href="#URL-정보" class="headerlink" title="URL 정보"></a>URL 정보</h4><p>블로그 URL정보를 설정 할 수 있다</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="attr">https://USERNAME.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><blockquote><p>만약 본인의 Custom Domain을 적용하고 싶다면 url값은 이후에 Custom Domain 설정시 CNAME 파일을 생성 할 때도 참조한다.</p></blockquote><h4 id="Github-정보"><a href="#Github-정보" class="headerlink" title="Github 정보"></a>Github 정보</h4><p>자신의 Git Page의 Repository 정보를 입력하면 이후에 손쉽게 배포가 가능하다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://stunstunstun@github.com/holaxapps/holaxapps.github.io</span></span><br></pre></td></tr></table></figure><h4 id="로컬에서-테스트"><a href="#로컬에서-테스트" class="headerlink" title="로컬에서 테스트"></a>로컬에서 테스트</h4><p>기본적인 설정이 완료가 되면 아래의 Command Line을 통해 로컬에서 서버를 구동 할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>서버가 구동이 되면 아래의 주소를 통해 브라우저에서 블로그에 접속 할 수 있다.</p><ul><li><a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></li></ul><h2 id="Github에-배포하기"><a href="#Github에-배포하기" class="headerlink" title="Github에 배포하기"></a>Github에 배포하기</h2><p>로컬에서 정상적으로 블로그에 접속이 되었다면 이미 생성한 Github Page Repository에 손쉽게 배포가 가능하다.</p><p><strong>Hexo 설정을 통해 정적 리소스 생성하기</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p><p><strong>배포하기</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p><p><strong>아래와 같이 Generate와 Deploy를 동시에 실행 할 수도 있다</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure></p><p>배포가 완료가 되면 브라우저에서 USERNAME.github.io로 접속해 정상적으로 배포가 되었는지 확인한다.</p><h4 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h4><p>간혹 hexo의 deploy기능을 통해 정상적으로 배포가 되었음에도 불구하고 페이지가 업데이트 되지 않는 현상이 있는데, 이 경우에는 아래와 같이 페이지를 clean후에 배포를 하면 해결된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure><h2 id="테마-적용하기"><a href="#테마-적용하기" class="headerlink" title="테마 적용하기"></a>테마 적용하기</h2><p>USERNAME.github.io를 통해 성공적으로 블로그 접속이 되었다면, 멋진 디자인을 적용한 테마(Theme)를 적용하고 싶을 것이다. Hexo에서는 아래의 페이지에서 다양한 Theme가 적용된 페이지를 소개하고 있다.</p><blockquote><p><a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a></p></blockquote><p>대부분의 Theme 페이지에서는 Github 링크가 포함되어 있는데 Theme를 적용하기 위한 자세한 설명을 포함하고 있다. 안녕 프로그래밍은 자체 제작한 hexo-theme-chiangmai 라는 Theme를 사용하고 있다.</p><blockquote><p><a href="https://github.com/stunstunstun/hexo-theme-chiangmai" target="_blank" rel="external">https://github.com/stunstunstun/hexo-theme-chiangmai</a></p></blockquote><p>Theme를 적용하기 위해서는 hexo-theme-chiangmai Github 페이지에서 자세한 내용을 확인 할 수 있다. 주의사항으로는 Theme를 적용하기 위해서는 아래와 같이 Repository 상태를 clean한 이후에 재배포 해야만 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure><h2 id="포스트-작성하기"><a href="#포스트-작성하기" class="headerlink" title="포스트 작성하기"></a>포스트 작성하기</h2><p>멋진 디자인의 Theme까지 적용하였다면 이제는 앞으로 블로그의 주인공이 될 기술 문서를 작성 할 일만 남았다. 아래의 Command Line을 입력하면, root 디렉토리의 <code>source/_posts</code> 폴더에 Markdown 파일이 하나 생성되는데 Hexo에서는 <code>Markdown</code>문서를 통해 포스트를 작성해 나가면 된다.</p><h4 id="새-포스트-만들기"><a href="#새-포스트-만들기" class="headerlink" title="새 포스트 만들기"></a>새 포스트 만들기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post [post_name]</span><br></pre></td></tr></table></figure><p><strong>예제</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post github-page-and-hexo</span><br></pre></td></tr></table></figure><p><strong>아래와 같은 경로에 Markdown 문서가 생성 된다</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ㄴ <span class="built_in">source</span></span><br><span class="line">   ㄴ _posts</span><br><span class="line">          - github-page-and-hexo.md</span><br></pre></td></tr></table></figure><p><strong>github-page-and-hexo.md 에서 아래와 같이 포스트의 제목을 수정 할 수 있다</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Github Page와 Hexo를 통해 30분만에 기술 블로그 만들기</span><br><span class="line">date: 2017-04-16 22:37:53</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="Github-Markdown-Guide"><a href="#Github-Markdown-Guide" class="headerlink" title="Github Markdown Guide"></a>Github Markdown Guide</h4><p>Markdown 문서가 생소하다면 아래의 링크를 확인하자</p><blockquote><p><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="external">https://guides.github.com/features/mastering-markdown/</a></p></blockquote><h2 id="체크리스트"><a href="#체크리스트" class="headerlink" title="체크리스트"></a>체크리스트</h2><p>지금까지 GitHub Page와 Hexo를 통해서 블로그를 개설하는 과정을 살펴보았는데요, 이 과정에서 소소한 시행 착오를 겪었습니다. 만약 저와 같은 동일한 이슈가 재현이 됐을 때의 해결 방법을 안내하는 것을 마지막으로 이 글을 마치도록 할께요.</p><h4 id="Theme를-변경하고-배포시에-적용이-되지-않는-이슈"><a href="#Theme를-변경하고-배포시에-적용이-되지-않는-이슈" class="headerlink" title="Theme를 변경하고 배포시에 적용이 되지 않는 이슈"></a>Theme를 변경하고 배포시에 적용이 되지 않는 이슈</h4><p>이 경우에는 Hexo를 <code>clean</code> 하고 재배포를 합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure><h4 id="배포시에-아래와-같은-에러메세지와-함께-배포가-되지-않는-이슈"><a href="#배포시에-아래와-같은-에러메세지와-함께-배포가-되지-않는-이슈" class="headerlink" title="배포시에 아래와 같은 에러메세지와 함께 배포가 되지 않는 이슈"></a>배포시에 아래와 같은 에러메세지와 함께 배포가 되지 않는 이슈</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure><p><strong><code>hexo-deployer-git</code> 플러그인 설치</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong><code>_config.yml</code>에 플러그인 설정</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-deployer-git</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이 포스팅에서는 GitHub Page를 통해 손쉽게 개발 블로그를 Hosting 해보고 Command Line 명령을 통해 쉽게 블로그를 만들 수 있는 Hexo 프레임워크를 소개하고자 합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://www.holaxprogramming.com/categories/git/"/>
    
    
  </entry>
  
</feed>
